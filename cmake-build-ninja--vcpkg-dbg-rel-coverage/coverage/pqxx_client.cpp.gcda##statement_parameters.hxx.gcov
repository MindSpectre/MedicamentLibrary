        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/pqxx/internal/statement_parameters.hxx
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/** Common implementation for statement parameter lists.
        -:    2: *
        -:    3: * These are used for both prepared statements and parameterized statements.
        -:    4: *
        -:    5: * DO NOT INCLUDE THIS FILE DIRECTLY.  Other headers include it for you.
        -:    6: *
        -:    7: * Copyright (c) 2000-2024, Jeroen T. Vermeulen.
        -:    8: *
        -:    9: * See COPYING for copyright license.  If you did not receive a file called
        -:   10: * COPYING with this source code, please notify the distributor of this
        -:   11: * mistake, or contact the author.
        -:   12: */
        -:   13:#ifndef PQXX_H_STATEMENT_PARAMETER
        -:   14:#define PQXX_H_STATEMENT_PARAMETER
        -:   15:
        -:   16:#include <cstring>
        -:   17:#include <iterator>
        -:   18:#include <string>
        -:   19:#include <vector>
        -:   20:
        -:   21:#include "pqxx/binarystring.hxx"
        -:   22:#include "pqxx/strconv.hxx"
        -:   23:#include "pqxx/util.hxx"
        -:   24:
        -:   25:
        -:   26:namespace pqxx::internal
        -:   27:{
        -:   28:template<typename ITERATOR>
        -:   29:constexpr inline auto const iterator_identity{
        -:   30:  [](decltype(*std::declval<ITERATOR>()) x) { return x; }};
        -:   31:
        -:   32:
        -:   33:/// Marker type: pass a dynamically-determined number of statement parameters.
        -:   34:/** @deprecated Use @ref params instead.
        -:   35: *
        -:   36: * Normally when invoking a prepared or parameterised statement, the number
        -:   37: * of parameters is known at compile time.  For instance,
        -:   38: * `t.exec_prepared("foo", 1, "x");` executes statement `foo` with two
        -:   39: * parameters, an `int` and a C string.
        -:   40: *
        -:   41: * But sometimes you may want to pass a number of parameters known only at run
        -:   42: * time.  In those cases, a @ref dynamic_params encodes a dynamically
        -:   43: * determined number of parameters.  You can mix these with regular, static
        -:   44: * parameter lists, and you can re-use them for multiple statement invocations.
        -:   45: *
        -:   46: * A dynamic_params object does not store copies of its parameters, so make
        -:   47: * sure they remain accessible until you've executed the statement.
        -:   48: *
        -:   49: * The ACCESSOR is an optional callable (such as a lambda).  If you pass an
        -:   50: * accessor `a`, then each parameter `p` goes into your statement as `a(p)`.
        -:   51: */
        -:   52:template<typename IT, typename ACCESSOR = decltype(iterator_identity<IT>)>
        -:   53:class dynamic_params
        -:   54:{
        -:   55:public:
        -:   56:  /// Wrap a sequence of pointers or iterators.
        -:   57:  constexpr dynamic_params(IT begin, IT end) :
        -:   58:          m_begin(begin), m_end(end), m_accessor(iterator_identity<IT>)
        -:   59:  {}
        -:   60:
        -:   61:  /// Wrap a sequence of pointers or iterators.
        -:   62:  /** This version takes an accessor callable.  If you pass an accessor `acc`,
        -:   63:   * then any parameter `p` will go into the statement's parameter list as
        -:   64:   * `acc(p)`.
        -:   65:   */
        -:   66:  constexpr dynamic_params(IT begin, IT end, ACCESSOR &acc) :
        -:   67:          m_begin(begin), m_end(end), m_accessor(acc)
        -:   68:  {}
        -:   69:
        -:   70:  /// Wrap a container.
        -:   71:  template<typename C>
        -:   72:  explicit constexpr dynamic_params(C &container) :
        -:   73:          dynamic_params(std::begin(container), std::end(container))
        -:   74:  {}
        -:   75:
        -:   76:  /// Wrap a container.
        -:   77:  /** This version takes an accessor callable.  If you pass an accessor `acc`,
        -:   78:   * then any parameter `p` will go into the statement's parameter list as
        -:   79:   * `acc(p)`.
        -:   80:   */
        -:   81:  template<typename C>
        -:   82:  explicit constexpr dynamic_params(C &container, ACCESSOR &acc) :
        -:   83:          dynamic_params(std::begin(container), std::end(container), acc)
        -:   84:  {}
        -:   85:
        -:   86:  constexpr IT begin() const noexcept { return m_begin; }
        -:   87:  constexpr IT end() const noexcept { return m_end; }
        -:   88:
        -:   89:  constexpr auto access(decltype(*std::declval<IT>()) value) const
        -:   90:    -> decltype(std::declval<ACCESSOR>()(value))
        -:   91:  {
        -:   92:    return m_accessor(value);
        -:   93:  }
        -:   94:
        -:   95:private:
        -:   96:  IT const m_begin, m_end;
        -:   97:  ACCESSOR m_accessor = iterator_identity<IT>;
        -:   98:};
        -:   99:
        -:  100:
        -:  101:/// Internal type: encode statement parameters.
        -:  102:/** Compiles arguments for prepared statements and parameterised queries into
        -:  103: * a format that can be passed into libpq.
        -:  104: *
        -:  105: * Objects of this type are meant to be short-lived: a `c_params` lives and
        -:  106: * dies entirely within the call to execute.  So, for example, if you pass in a
        -:  107: * non-null pointer as a parameter, @ref params may simply use that pointer as
        -:  108: * a parameter value, without arranging longer-term storage for the data to
        -:  109: * which it points.  All values referenced by parameters must remain "live"
        -:  110: * until the parameterised or prepared statement has been executed.
        -:  111: */
        -:  112:struct PQXX_LIBEXPORT c_params
        -:  113:{
        -:  114:  c_params() = default;
        -:  115:  /// Copying these objects is pointless and expensive.  Don't do it.
        -:  116:  c_params(c_params const &) = delete;
        -:  117:  c_params(c_params &&) = default;
        -:  118:
        -:  119:  /// Pre-allocate storage for `n` parameters.
        -:  120:  void reserve(std::size_t n) &;
        -:  121:
        -:  122:  /// As used by libpq: pointers to parameter values.
        -:  123:  std::vector<char const *> values;
        -:  124:  /// As used by libpq: lengths of non-null arguments, in bytes.
        -:  125:  std::vector<int> lengths;
        -:  126:  /// As used by libpq: effectively boolean "is this a binary parameter?"
        -:  127:  std::vector<format> formats;
        -:  128:};
        -:  129:} // namespace pqxx::internal
        -:  130:#endif
