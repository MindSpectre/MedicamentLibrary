        -:    0:Source:/usr/include/c++/12/bits/regex_scanner.tcc
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// class template regex -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2013-2022 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/**
        -:   26: *  @file bits/regex_scanner.tcc
        -:   27: *  This is an internal header file, included by other library headers.
        -:   28: *  Do not attempt to use it directly. @headername{regex}
        -:   29: */
        -:   30:
        -:   31:// FIXME make comments doxygen format.
        -:   32:
        -:   33:// N3376 specified 6 regex styles: ECMAScript, basic, extended, grep, egrep
        -:   34:// and awk
        -:   35:// 1) grep is basic except '\n' is treated as '|'
        -:   36:// 2) egrep is extended except '\n' is treated as '|'
        -:   37:// 3) awk is extended except special escaping rules, and there's no
        -:   38://    back-reference.
        -:   39://
        -:   40:// References:
        -:   41://
        -:   42:// ECMAScript: ECMA-262 15.10
        -:   43://
        -:   44:// basic, extended:
        -:   45:// http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html
        -:   46://
        -:   47:// awk: http://pubs.opengroup.org/onlinepubs/000095399/utilities/awk.html
        -:   48:
        -:   49:namespace std _GLIBCXX_VISIBILITY(default)
        -:   50:{
        -:   51:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   52:
        -:   53:namespace __detail
        -:   54:{
        -:   55:  template<typename _CharT>
        -:   56:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcEC2EPKcS3_NSt15regex_constants18syntax_option_typeESt6locale called 1 returned 100% blocks executed 60%
        2:   57:    _Scanner(const _CharT* __begin, const _CharT* __end,
        -:   58:	     _FlagT __flags, std::locale __loc)
        1:   59:    : _ScannerBase(__flags),
        1:   60:      _M_current(__begin), _M_end(__end),
        1:   61:      _M_ctype(std::use_facet<_CtypeT>(__loc)),
        1:   62:      _M_eat_escape(_M_is_ecma()
        1:   62-block  0
branch  0 taken 1
branch  1 taken 0
        -:   63:		    ? &_Scanner::_M_eat_escape_ecma
        -:   64:		    : &_Scanner::_M_eat_escape_posix)
        1:   65:    { _M_advance(); }
        1:   65-block  0
branch  0 taken 1
branch  1 taken 0
        1:   65-block  1
    $$$$$:   65-block  2
    $$$$$:   65-block  3
        -:   66:
        -:   67:  template<typename _CharT>
        -:   68:    void
        -:   69:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE10_M_advanceEv called 26 returned 100% blocks executed 57%
       26:   70:    _M_advance()
        -:   71:    {
       26:   72:      if (_M_current == _M_end)
       26:   72-block  0
branch  0 taken 24
branch  1 taken 2
        -:   73:	{
        2:   74:	  _M_token = _S_token_eof;
        2:   75:	  return;
        2:   75-block  0
        -:   76:	}
        -:   77:
       24:   78:      if (_M_state == _S_state_normal)
       24:   78-block  0
branch  0 taken 19
branch  1 taken 5
        5:   79:	_M_scan_normal();
        5:   79-block  0
       19:   80:      else if (_M_state == _S_state_in_bracket)
       19:   80-block  0
branch  0 taken 19
branch  1 taken 0
       19:   81:	_M_scan_in_bracket();
       19:   81-block  0
    #####:   82:      else if (_M_state == _S_state_in_brace)
    $$$$$:   82-block  0
branch  0 never executed
branch  1 never executed
    #####:   83:	_M_scan_in_brace();
    $$$$$:   83-block  0
        -:   84:      else
        -:   85:	{
    #####:   86:	  __glibcxx_assert(!"unexpected state while processing regex");
    $$$$$:   86-block  0
    $$$$$:   86-block  1
        -:   87:	}
       26:   88:    }
       26:   88-block  0
        -:   89:
        -:   90:  // Differences between styles:
        -:   91:  // 1) "\(", "\)", "\{" in basic. It's not escaping.
        -:   92:  // 2) "(?:", "(?=", "(?!" in ECMAScript.
        -:   93:  template<typename _CharT>
        -:   94:    void
        -:   95:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE14_M_scan_normalEv called 5 returned 100% blocks executed 33%
        5:   96:    _M_scan_normal()
        -:   97:    {
        5:   98:      auto __c = *_M_current++;
        -:   99:
        5:  100:      if (__builtin_strchr(_M_spec_char, _M_ctype.narrow(__c, ' ')) == nullptr)
        5:  100-block  0
branch  0 taken 5
branch  1 taken 0
        -:  101:	{
    #####:  102:	  _M_token = _S_token_ord_char;
    #####:  103:	  _M_value.assign(1, __c);
    #####:  104:	  return;
    $$$$$:  104-block  0
        -:  105:	}
        5:  106:      if (__c == '\\')
        5:  106-block  0
branch  0 taken 5
branch  1 taken 0
        -:  107:	{
    #####:  108:	  if (_M_current == _M_end)
    $$$$$:  108-block  0
branch  0 never executed
branch  1 never executed
    #####:  109:	    __throw_regex_error(
    $$$$$:  109-block  0
        -:  110:	      regex_constants::error_escape,
        -:  111:	      "Invalid escape at end of regular expression");
        -:  112:
    #####:  113:	  if (!_M_is_basic()
    $$$$$:  113-block  0
branch  0 never executed
branch  1 never executed
    #####:  114:	      || (*_M_current != '('
    $$$$$:  114-block  0
branch  0 never executed
branch  1 never executed
    #####:  115:		  && *_M_current != ')'
    $$$$$:  115-block  0
branch  0 never executed
branch  1 never executed
    #####:  116:		  && *_M_current != '{'))
    $$$$$:  116-block  0
branch  0 never executed
branch  1 never executed
        -:  117:	    {
    #####:  118:	      (this->*_M_eat_escape)();
    $$$$$:  118-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  118-block  1
    $$$$$:  118-block  2
    #####:  119:	      return;
    $$$$$:  119-block  0
        -:  120:	    }
    #####:  121:	  __c = *_M_current++;
    #####:  122:	}
    $$$$$:  122-block  0
        5:  123:      if (__c == '(')
        5:  123-block  0
branch  0 taken 0
branch  1 taken 5
        -:  124:	{
    #####:  125:	  if (_M_is_ecma() && *_M_current == '?')
    $$$$$:  125-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  125-block  1
branch  2 never executed
branch  3 never executed
        -:  126:	    {
    #####:  127:	      if (++_M_current == _M_end)
    $$$$$:  127-block  0
branch  0 never executed
branch  1 never executed
    #####:  128:		__throw_regex_error(regex_constants::error_paren);
    $$$$$:  128-block  0
        -:  129:
    #####:  130:	      if (*_M_current == ':')
    $$$$$:  130-block  0
branch  0 never executed
branch  1 never executed
        -:  131:		{
    #####:  132:		  ++_M_current;
    #####:  133:		  _M_token = _S_token_subexpr_no_group_begin;
    #####:  134:		}
    $$$$$:  134-block  0
    #####:  135:	      else if (*_M_current == '=')
    $$$$$:  135-block  0
branch  0 never executed
branch  1 never executed
        -:  136:		{
    #####:  137:		  ++_M_current;
    #####:  138:		  _M_token = _S_token_subexpr_lookahead_begin;
    #####:  139:		  _M_value.assign(1, 'p');
    #####:  140:		}
    $$$$$:  140-block  0
    #####:  141:	      else if (*_M_current == '!')
    $$$$$:  141-block  0
branch  0 never executed
branch  1 never executed
        -:  142:		{
    #####:  143:		  ++_M_current;
    #####:  144:		  _M_token = _S_token_subexpr_lookahead_begin;
    #####:  145:		  _M_value.assign(1, 'n');
    #####:  146:		}
    $$$$$:  146-block  0
        -:  147:	      else
    #####:  148:		__throw_regex_error(regex_constants::error_paren,
    $$$$$:  148-block  0
        -:  149:				    "Invalid '(?...)' zero-width assertion "
        -:  150:				    "in regular expression");
    #####:  151:	    }
    $$$$$:  151-block  0
    #####:  152:	  else if (_M_flags & regex_constants::nosubs)
    $$$$$:  152-block  0
branch  0 never executed
branch  1 never executed
    #####:  153:	    _M_token = _S_token_subexpr_no_group_begin;
    $$$$$:  153-block  0
        -:  154:	  else
    #####:  155:	    _M_token = _S_token_subexpr_begin;
    $$$$$:  155-block  0
    #####:  156:	}
    $$$$$:  156-block  0
        5:  157:      else if (__c == ')')
        5:  157-block  0
branch  0 taken 0
branch  1 taken 5
    #####:  158:	_M_token = _S_token_subexpr_end;
    $$$$$:  158-block  0
        5:  159:      else if (__c == '[')
        5:  159-block  0
branch  0 taken 2
branch  1 taken 3
        -:  160:	{
        2:  161:	  _M_state = _S_state_in_bracket;
        2:  162:	  _M_at_bracket_start = true;
        2:  163:	  if (_M_current != _M_end && *_M_current == '^')
        2:  163-block  0
branch  0 taken 2
branch  1 taken 0
        2:  163-block  1
branch  2 taken 2
branch  3 taken 0
        -:  164:	    {
    #####:  165:	      _M_token = _S_token_bracket_neg_begin;
    #####:  166:	      ++_M_current;
    #####:  167:	    }
    $$$$$:  167-block  0
        -:  168:	  else
        2:  169:	    _M_token = _S_token_bracket_begin;
        2:  169-block  0
        2:  170:	}
        2:  170-block  0
        3:  171:      else if (__c == '{')
        3:  171-block  0
branch  0 taken 0
branch  1 taken 3
        -:  172:	{
    #####:  173:	  _M_state = _S_state_in_brace;
    #####:  174:	  _M_token = _S_token_interval_begin;
    #####:  175:	}
    $$$$$:  175-block  0
        3:  176:      else if (__builtin_expect(__c == _CharT(0), false))
        3:  176-block  0
branch  0 taken 3
branch  1 taken 0
        -:  177:	{
    #####:  178:	  if (!_M_is_ecma())
    $$$$$:  178-block  0
branch  0 never executed
branch  1 never executed
    #####:  179:	    __throw_regex_error(regex_constants::_S_null);
    $$$$$:  179-block  0
    #####:  180:	  _M_token = _S_token_ord_char;
    #####:  181:	  _M_value.assign(1, __c);
    #####:  182:	}
    $$$$$:  182-block  0
        3:  183:      else if (__c != ']' && __c != '}')
        3:  183-block  0
branch  0 taken 3
branch  1 taken 0
        3:  183-block  1
branch  2 taken 0
branch  3 taken 3
        -:  184:	{
        3:  185:	  auto __it = _M_token_tbl;
        3:  186:	  auto __narrowc = _M_ctype.narrow(__c, '\0');
        7:  187:	  for (; __it->first != '\0'; ++__it)
        3:  187-block  0
        7:  187-block  1
branch  0 taken 7
branch  1 taken 0
        4:  187-block  2
        7:  188:	    if (__it->first == __narrowc)
        7:  188-block  0
branch  0 taken 3
branch  1 taken 4
        4:  188-block  1
        -:  189:	      {
        3:  190:		_M_token = __it->second;
        3:  191:		return;
        3:  191-block  0
        -:  192:	      }
    #####:  193:	  __glibcxx_assert(!"unexpected special character in regex");
    $$$$$:  193-block  0
    $$$$$:  193-block  1
    #####:  194:	}
    $$$$$:  194-block  0
        -:  195:      else
        -:  196:	{
    #####:  197:	  _M_token = _S_token_ord_char;
    #####:  198:	  _M_value.assign(1, __c);
    $$$$$:  198-block  0
        -:  199:	}
        5:  200:    }
        5:  200-block  0
        -:  201:
        -:  202:  // Differences between styles:
        -:  203:  // 1) different semantics of "[]" and "[^]".
        -:  204:  // 2) Escaping in bracket expr.
        -:  205:  template<typename _CharT>
        -:  206:    void
        -:  207:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE18_M_scan_in_bracketEv called 19 returned 100% blocks executed 39%
       19:  208:    _M_scan_in_bracket()
        -:  209:    {
       19:  210:      if (_M_current == _M_end)
       19:  210-block  0
branch  0 taken 19
branch  1 taken 0
    #####:  211:	__throw_regex_error(regex_constants::error_brack);
    $$$$$:  211-block  0
        -:  212:
       19:  213:      auto __c = *_M_current++;
        -:  214:
       19:  215:      if (__c == '-')
       19:  215-block  0
branch  0 taken 5
branch  1 taken 14
        5:  216:	_M_token = _S_token_bracket_dash;
        5:  216-block  0
       14:  217:      else if (__c == '[')
       14:  217-block  0
branch  0 taken 0
branch  1 taken 14
        -:  218:	{
    #####:  219:	  if (_M_current == _M_end)
    $$$$$:  219-block  0
branch  0 never executed
branch  1 never executed
    #####:  220:	    __throw_regex_error(regex_constants::error_brack,
    $$$$$:  220-block  0
        -:  221:				"Incomplete '[[' character class in "
        -:  222:				"regular expression");
        -:  223:
    #####:  224:	  if (*_M_current == '.')
    $$$$$:  224-block  0
branch  0 never executed
branch  1 never executed
        -:  225:	    {
    #####:  226:	      _M_token = _S_token_collsymbol;
    #####:  227:	      _M_eat_class(*_M_current++);
    #####:  228:	    }
    $$$$$:  228-block  0
    #####:  229:	  else if (*_M_current == ':')
    $$$$$:  229-block  0
branch  0 never executed
branch  1 never executed
        -:  230:	    {
    #####:  231:	      _M_token = _S_token_char_class_name;
    #####:  232:	      _M_eat_class(*_M_current++);
    #####:  233:	    }
    $$$$$:  233-block  0
    #####:  234:	  else if (*_M_current == '=')
    $$$$$:  234-block  0
branch  0 never executed
branch  1 never executed
        -:  235:	    {
    #####:  236:	      _M_token = _S_token_equiv_class_name;
    #####:  237:	      _M_eat_class(*_M_current++);
    #####:  238:	    }
    $$$$$:  238-block  0
        -:  239:	  else
        -:  240:	    {
    #####:  241:	      _M_token = _S_token_ord_char;
    #####:  242:	      _M_value.assign(1, __c);
    $$$$$:  242-block  0
        -:  243:	    }
    #####:  244:	}
    $$$$$:  244-block  0
        -:  245:      // In POSIX, when encountering "[]" or "[^]", the ']' is interpreted
        -:  246:      // literally. So "[]]" and "[^]]" are valid regexes. See the testcases
        -:  247:      // `.../empty_range.cc`.
       14:  248:      else if (__c == ']' && (_M_is_ecma() || !_M_at_bracket_start))
       14:  248-block  0
branch  0 taken 2
branch  1 taken 12
        2:  248-block  1
branch  2 taken 0
branch  3 taken 2
    $$$$$:  248-block  2
branch  4 never executed
branch  5 never executed
        -:  249:	{
        2:  250:	  _M_token = _S_token_bracket_end;
        2:  251:	  _M_state = _S_state_normal;
        2:  252:	}
        2:  252-block  0
        -:  253:      // ECMAScript and awk permits escaping in bracket.
       12:  254:      else if (__c == '\\' && (_M_is_ecma() || _M_is_awk()))
       12:  254-block  0
branch  0 taken 0
branch  1 taken 12
    $$$$$:  254-block  1
branch  2 never executed
branch  3 never executed
    $$$$$:  254-block  2
branch  4 never executed
branch  5 never executed
    #####:  255:	(this->*_M_eat_escape)();
    $$$$$:  255-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  255-block  1
    $$$$$:  255-block  2
    $$$$$:  255-block  3
        -:  256:      else
        -:  257:	{
       12:  258:	  _M_token = _S_token_ord_char;
       12:  259:	  _M_value.assign(1, __c);
       12:  259-block  0
        -:  260:	}
       19:  261:      _M_at_bracket_start = false;
       19:  262:    }
       19:  262-block  0
        -:  263:
        -:  264:  // Differences between styles:
        -:  265:  // 1) "\}" in basic style.
        -:  266:  template<typename _CharT>
        -:  267:    void
        -:  268:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE16_M_scan_in_braceEv called 0 returned 0% blocks executed 0%
    #####:  269:    _M_scan_in_brace()
        -:  270:    {
    #####:  271:      if (_M_current == _M_end)
    $$$$$:  271-block  0
branch  0 never executed
branch  1 never executed
    #####:  272:	__throw_regex_error(regex_constants::error_brace);
    $$$$$:  272-block  0
        -:  273:
    #####:  274:      auto __c = *_M_current++;
        -:  275:
    #####:  276:      if (_M_ctype.is(_CtypeT::digit, __c))
    $$$$$:  276-block  0
branch  0 never executed
branch  1 never executed
        -:  277:	{
    #####:  278:	  _M_token = _S_token_dup_count;
    #####:  279:	  _M_value.assign(1, __c);
    #####:  280:	  while (_M_current != _M_end
    $$$$$:  280-block  0
    $$$$$:  280-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  280-block  2
    #####:  281:		 && _M_ctype.is(_CtypeT::digit, *_M_current))
    $$$$$:  281-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  281-block  1
    #####:  282:	    _M_value += *_M_current++;
    #####:  283:	}
    $$$$$:  283-block  0
    #####:  284:      else if (__c == ',')
    $$$$$:  284-block  0
branch  0 never executed
branch  1 never executed
    #####:  285:	_M_token = _S_token_comma;
    $$$$$:  285-block  0
        -:  286:      // basic use \}.
    #####:  287:      else if (_M_is_basic())
    $$$$$:  287-block  0
branch  0 never executed
branch  1 never executed
        -:  288:	{
    #####:  289:	  if (__c == '\\' && _M_current != _M_end && *_M_current == '}')
    $$$$$:  289-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  289-block  1
    $$$$$:  289-block  2
    $$$$$:  289-block  3
    $$$$$:  289-block  4
        -:  290:	    {
    #####:  291:	      _M_state = _S_state_normal;
    #####:  292:	      _M_token = _S_token_interval_end;
    #####:  293:	      ++_M_current;
    #####:  294:	    }
    $$$$$:  294-block  0
        -:  295:	  else
    #####:  296:	    __throw_regex_error(regex_constants::error_badbrace);
    $$$$$:  296-block  0
    #####:  297:	}
    $$$$$:  297-block  0
    #####:  298:      else if (__c == '}')
    $$$$$:  298-block  0
branch  0 never executed
branch  1 never executed
        -:  299:	{
    #####:  300:	  _M_state = _S_state_normal;
    #####:  301:	  _M_token = _S_token_interval_end;
    #####:  302:	}
    $$$$$:  302-block  0
        -:  303:      else
    #####:  304:	__throw_regex_error(regex_constants::error_badbrace);
    $$$$$:  304-block  0
    #####:  305:    }
    $$$$$:  305-block  0
        -:  306:
        -:  307:  template<typename _CharT>
        -:  308:    void
        -:  309:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE18_M_eat_escape_ecmaEv called 0 returned 0% blocks executed 0%
    #####:  310:    _M_eat_escape_ecma()
        -:  311:    {
    #####:  312:      if (_M_current == _M_end)
    $$$$$:  312-block  0
branch  0 never executed
branch  1 never executed
    #####:  313:	__throw_regex_error(regex_constants::error_escape);
    $$$$$:  313-block  0
        -:  314:
    #####:  315:      auto __c = *_M_current++;
    #####:  316:      auto __pos = _M_find_escape(_M_ctype.narrow(__c, '\0'));
        -:  317:
    #####:  318:      if (__pos != nullptr && (__c != 'b' || _M_state == _S_state_in_bracket))
    $$$$$:  318-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  318-block  1
branch  2 never executed
branch  3 never executed
    $$$$$:  318-block  2
branch  4 never executed
branch  5 never executed
        -:  319:	{
    #####:  320:	  _M_token = _S_token_ord_char;
    #####:  321:	  _M_value.assign(1, *__pos);
    #####:  322:	}
    $$$$$:  322-block  0
    #####:  323:      else if (__c == 'b')
    $$$$$:  323-block  0
branch  0 never executed
branch  1 never executed
        -:  324:	{
    #####:  325:	  _M_token = _S_token_word_bound;
    #####:  326:	  _M_value.assign(1, 'p');
    #####:  327:	}
    $$$$$:  327-block  0
    #####:  328:      else if (__c == 'B')
    $$$$$:  328-block  0
branch  0 never executed
branch  1 never executed
        -:  329:	{
    #####:  330:	  _M_token = _S_token_word_bound;
    #####:  331:	  _M_value.assign(1, 'n');
    #####:  332:	}
    $$$$$:  332-block  0
        -:  333:      // N3376 28.13
    #####:  334:      else if (__c == 'd'
    $$$$$:  334-block  0
branch  0 never executed
branch  1 never executed
    #####:  335:	       || __c == 'D'
    $$$$$:  335-block  0
branch  0 never executed
branch  1 never executed
    #####:  336:	       || __c == 's'
    $$$$$:  336-block  0
branch  0 never executed
branch  1 never executed
    #####:  337:	       || __c == 'S'
    $$$$$:  337-block  0
branch  0 never executed
branch  1 never executed
    #####:  338:	       || __c == 'w'
    $$$$$:  338-block  0
branch  0 never executed
branch  1 never executed
    #####:  339:	       || __c == 'W')
    $$$$$:  339-block  0
branch  0 never executed
branch  1 never executed
        -:  340:	{
    #####:  341:	  _M_token = _S_token_quoted_class;
    #####:  342:	  _M_value.assign(1, __c);
    #####:  343:	}
    $$$$$:  343-block  0
    #####:  344:      else if (__c == 'c')
    $$$$$:  344-block  0
branch  0 never executed
branch  1 never executed
        -:  345:	{
    #####:  346:	  if (_M_current == _M_end)
    $$$$$:  346-block  0
branch  0 never executed
branch  1 never executed
    #####:  347:	    __throw_regex_error(regex_constants::error_escape,
    $$$$$:  347-block  0
        -:  348:				"invalid '\\cX' control character in "
        -:  349:				"regular expression");
    #####:  350:	  _M_token = _S_token_ord_char;
    #####:  351:	  _M_value.assign(1, *_M_current++);
    #####:  352:	}
    $$$$$:  352-block  0
    #####:  353:      else if (__c == 'x' || __c == 'u')
    $$$$$:  353-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  353-block  1
branch  2 never executed
branch  3 never executed
        -:  354:	{
    #####:  355:	  _M_value.clear();
    #####:  356:	  const int __n = __c == 'x' ? 2 : 4;
    #####:  357:	  for (int __i = 0; __i < __n; __i++)
    $$$$$:  357-block  0
    $$$$$:  357-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  357-block  2
        -:  358:	    {
    #####:  359:	      if (_M_current == _M_end
    $$$$$:  359-block  0
    $$$$$:  359-block  1
    #####:  360:		  || !_M_ctype.is(_CtypeT::xdigit, *_M_current))
    $$$$$:  360-block  0
branch  0 never executed
branch  1 never executed
    #####:  361:		__throw_regex_error(regex_constants::error_escape,
    $$$$$:  361-block  0
    #####:  362:				    __n == 2
        -:  363:				    ? "Invalid '\\xNN' control character in "
        -:  364:				      "regular expression"
        -:  365:				    : "Invalid '\\uNNNN' control character in "
        -:  366:				      "regular expression");
    #####:  367:	      _M_value += *_M_current++;
    #####:  368:	    }
    $$$$$:  368-block  0
    #####:  369:	  _M_token = _S_token_hex_num;
    #####:  370:	}
    $$$$$:  370-block  0
        -:  371:      // ECMAScript recognizes multi-digit back-references.
    #####:  372:      else if (_M_ctype.is(_CtypeT::digit, __c))
    $$$$$:  372-block  0
branch  0 never executed
branch  1 never executed
        -:  373:	{
    #####:  374:	  _M_value.assign(1, __c);
    #####:  375:	  while (_M_current != _M_end
    $$$$$:  375-block  0
    $$$$$:  375-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  375-block  2
    #####:  376:		 && _M_ctype.is(_CtypeT::digit, *_M_current))
    $$$$$:  376-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  376-block  1
    #####:  377:	    _M_value += *_M_current++;
    #####:  378:	  _M_token = _S_token_backref;
    #####:  379:	}
    $$$$$:  379-block  0
        -:  380:      else
        -:  381:	{
    #####:  382:	  _M_token = _S_token_ord_char;
    #####:  383:	  _M_value.assign(1, __c);
    $$$$$:  383-block  0
        -:  384:	}
    #####:  385:    }
    $$$$$:  385-block  0
        -:  386:
        -:  387:  // Differences between styles:
        -:  388:  // 1) Extended doesn't support backref, but basic does.
        -:  389:  template<typename _CharT>
        -:  390:    void
        -:  391:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE19_M_eat_escape_posixEv called 0 returned 0% blocks executed 0%
    #####:  392:    _M_eat_escape_posix()
        -:  393:    {
    #####:  394:      if (_M_current == _M_end)
    $$$$$:  394-block  0
branch  0 never executed
branch  1 never executed
    #####:  395:	__throw_regex_error(regex_constants::error_escape);
    $$$$$:  395-block  0
        -:  396:
    #####:  397:      auto __c = *_M_current;
    #####:  398:      auto __pos = __builtin_strchr(_M_spec_char, _M_ctype.narrow(__c, '\0'));
        -:  399:
    #####:  400:      if (__pos != nullptr && *__pos != '\0')
    $$$$$:  400-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  400-block  1
branch  2 never executed
branch  3 never executed
        -:  401:	{
    #####:  402:	  _M_token = _S_token_ord_char;
    #####:  403:	  _M_value.assign(1, __c);
    #####:  404:	}
    $$$$$:  404-block  0
        -:  405:      // We MUST judge awk before handling backrefs. There's no backref in awk.
    #####:  406:      else if (_M_is_awk())
    $$$$$:  406-block  0
branch  0 never executed
branch  1 never executed
        -:  407:	{
    #####:  408:	  _M_eat_escape_awk();
    #####:  409:	  return;
    $$$$$:  409-block  0
        -:  410:	}
    #####:  411:      else if (_M_is_basic() && _M_ctype.is(_CtypeT::digit, __c) && __c != '0')
    $$$$$:  411-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  411-block  1
    $$$$$:  411-block  2
    $$$$$:  411-block  3
    $$$$$:  411-block  4
        -:  412:	{
    #####:  413:	  _M_token = _S_token_backref;
    #####:  414:	  _M_value.assign(1, __c);
    #####:  415:	}
    $$$$$:  415-block  0
        -:  416:      else
        -:  417:	{
        -:  418:#ifdef __STRICT_ANSI__
        -:  419:	  // POSIX says it is undefined to escape ordinary characters
    #####:  420:	  __throw_regex_error(regex_constants::error_escape);
    $$$$$:  420-block  0
        -:  421:#else
        -:  422:	  _M_token = _S_token_ord_char;
        -:  423:	  _M_value.assign(1, __c);
        -:  424:#endif
        -:  425:	}
    #####:  426:      ++_M_current;
    #####:  427:    }
    $$$$$:  427-block  0
    $$$$$:  427-block  1
        -:  428:
        -:  429:  template<typename _CharT>
        -:  430:    void
        -:  431:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE17_M_eat_escape_awkEv called 0 returned 0% blocks executed 0%
    #####:  432:    _M_eat_escape_awk()
        -:  433:    {
    #####:  434:      auto __c = *_M_current++;
    #####:  435:      auto __pos = _M_find_escape(_M_ctype.narrow(__c, '\0'));
        -:  436:
    #####:  437:      if (__pos != nullptr)
    $$$$$:  437-block  0
branch  0 never executed
branch  1 never executed
        -:  438:	{
    #####:  439:	  _M_token = _S_token_ord_char;
    #####:  440:	  _M_value.assign(1, *__pos);
    #####:  441:	}
    $$$$$:  441-block  0
        -:  442:      // \ddd for oct representation
    #####:  443:      else if (_M_ctype.is(_CtypeT::digit, __c)
    $$$$$:  443-block  0
    $$$$$:  443-block  1
    #####:  444:	       && __c != '8'
    $$$$$:  444-block  0
branch  0 never executed
branch  1 never executed
    #####:  445:	       && __c != '9')
    $$$$$:  445-block  0
    $$$$$:  445-block  1
        -:  446:	{
    #####:  447:	  _M_value.assign(1,  __c);
    #####:  448:	  for (int __i = 0;
    $$$$$:  448-block  0
    $$$$$:  448-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  448-block  2
    #####:  449:	       __i < 2
    #####:  450:	       && _M_current != _M_end
    $$$$$:  450-block  0
branch  0 never executed
branch  1 never executed
    #####:  451:	       && _M_ctype.is(_CtypeT::digit, *_M_current)
    $$$$$:  451-block  0
branch  0 never executed
branch  1 never executed
    #####:  452:	       && *_M_current != '8'
    $$$$$:  452-block  0
branch  0 never executed
branch  1 never executed
    #####:  453:	       && *_M_current != '9';
    $$$$$:  453-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  453-block  1
    #####:  454:	       __i++)
    #####:  455:	    _M_value += *_M_current++;
    $$$$$:  455-block  0
    #####:  456:	  _M_token = _S_token_oct_num;
    #####:  457:	  return;
    $$$$$:  457-block  0
        -:  458:	}
        -:  459:      else
    #####:  460:	__throw_regex_error(regex_constants::error_escape);
    $$$$$:  460-block  0
    #####:  461:    }
    $$$$$:  461-block  0
        -:  462:
        -:  463:  // Eats a character class or throws an exception.
        -:  464:  // __ch could be ':', '.' or '=', _M_current is the char after ']' when
        -:  465:  // returning.
        -:  466:  template<typename _CharT>
        -:  467:    void
        -:  468:    _Scanner<_CharT>::
function _ZNSt8__detail8_ScannerIcE12_M_eat_classEc called 0 returned 0% blocks executed 0%
    #####:  469:    _M_eat_class(char __ch)
        -:  470:    {
    #####:  471:      for (_M_value.clear(); _M_current != _M_end && *_M_current != __ch;)
    $$$$$:  471-block  0
    $$$$$:  471-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  471-block  2
    $$$$$:  471-block  3
branch  2 never executed
branch  3 never executed
    $$$$$:  471-block  4
    #####:  472:	_M_value += *_M_current++;
    #####:  473:      if (_M_current == _M_end
    $$$$$:  473-block  0
    $$$$$:  473-block  1
    #####:  474:	  || *_M_current++ != __ch
    $$$$$:  474-block  0
branch  0 never executed
branch  1 never executed
    #####:  475:	  || _M_current == _M_end // skip __ch
    $$$$$:  475-block  0
    $$$$$:  475-block  1
    #####:  476:	  || *_M_current++ != ']') // skip ']'
    $$$$$:  476-block  0
    $$$$$:  476-block  1
        -:  477:	{
    #####:  478:	  __throw_regex_error(__ch == ':' ? regex_constants::error_ctype
    $$$$$:  478-block  0
        -:  479:					  : regex_constants::error_collate);
        -:  480:	}
    #####:  481:    }
    $$$$$:  481-block  0
        -:  482:
        -:  483:#ifdef _GLIBCXX_DEBUG
        -:  484:  template<typename _CharT>
        -:  485:    std::ostream&
        -:  486:    _Scanner<_CharT>::
        -:  487:    _M_print(std::ostream& ostr)
        -:  488:    {
        -:  489:      switch (_M_token)
        -:  490:      {
        -:  491:      case _S_token_anychar:
        -:  492:	ostr << "any-character\n";
        -:  493:	break;
        -:  494:      case _S_token_backref:
        -:  495:	ostr << "backref\n";
        -:  496:	break;
        -:  497:      case _S_token_bracket_begin:
        -:  498:	ostr << "bracket-begin\n";
        -:  499:	break;
        -:  500:      case _S_token_bracket_neg_begin:
        -:  501:	ostr << "bracket-neg-begin\n";
        -:  502:	break;
        -:  503:      case _S_token_bracket_end:
        -:  504:	ostr << "bracket-end\n";
        -:  505:	break;
        -:  506:      case _S_token_char_class_name:
        -:  507:	ostr << "char-class-name \"" << _M_value << "\"\n";
        -:  508:	break;
        -:  509:      case _S_token_closure0:
        -:  510:	ostr << "closure0\n";
        -:  511:	break;
        -:  512:      case _S_token_closure1:
        -:  513:	ostr << "closure1\n";
        -:  514:	break;
        -:  515:      case _S_token_collsymbol:
        -:  516:	ostr << "collsymbol \"" << _M_value << "\"\n";
        -:  517:	break;
        -:  518:      case _S_token_comma:
        -:  519:	ostr << "comma\n";
        -:  520:	break;
        -:  521:      case _S_token_dup_count:
        -:  522:	ostr << "dup count: " << _M_value << "\n";
        -:  523:	break;
        -:  524:      case _S_token_eof:
        -:  525:	ostr << "EOF\n";
        -:  526:	break;
        -:  527:      case _S_token_equiv_class_name:
        -:  528:	ostr << "equiv-class-name \"" << _M_value << "\"\n";
        -:  529:	break;
        -:  530:      case _S_token_interval_begin:
        -:  531:	ostr << "interval begin\n";
        -:  532:	break;
        -:  533:      case _S_token_interval_end:
        -:  534:	ostr << "interval end\n";
        -:  535:	break;
        -:  536:      case _S_token_line_begin:
        -:  537:	ostr << "line begin\n";
        -:  538:	break;
        -:  539:      case _S_token_line_end:
        -:  540:	ostr << "line end\n";
        -:  541:	break;
        -:  542:      case _S_token_opt:
        -:  543:	ostr << "opt\n";
        -:  544:	break;
        -:  545:      case _S_token_or:
        -:  546:	ostr << "or\n";
        -:  547:	break;
        -:  548:      case _S_token_ord_char:
        -:  549:	ostr << "ordinary character: \"" << _M_value << "\"\n";
        -:  550:	break;
        -:  551:      case _S_token_subexpr_begin:
        -:  552:	ostr << "subexpr begin\n";
        -:  553:	break;
        -:  554:      case _S_token_subexpr_no_group_begin:
        -:  555:	ostr << "no grouping subexpr begin\n";
        -:  556:	break;
        -:  557:      case _S_token_subexpr_lookahead_begin:
        -:  558:	ostr << "lookahead subexpr begin\n";
        -:  559:	break;
        -:  560:      case _S_token_subexpr_end:
        -:  561:	ostr << "subexpr end\n";
        -:  562:	break;
        -:  563:      case _S_token_unknown:
        -:  564:	ostr << "-- unknown token --\n";
        -:  565:	break;
        -:  566:      case _S_token_oct_num:
        -:  567:	ostr << "oct number " << _M_value << "\n";
        -:  568:	break;
        -:  569:      case _S_token_hex_num:
        -:  570:	ostr << "hex number " << _M_value << "\n";
        -:  571:	break;
        -:  572:      case _S_token_quoted_class:
        -:  573:	ostr << "quoted class " << "\\" << _M_value << "\n";
        -:  574:	break;
        -:  575:      default:
        -:  576:	_GLIBCXX_DEBUG_ASSERT(false);
        -:  577:      }
        -:  578:      return ostr;
        -:  579:    }
        -:  580:#endif
        -:  581:
        -:  582:} // namespace __detail
        -:  583:_GLIBCXX_END_NAMESPACE_VERSION
        -:  584:} // namespace
