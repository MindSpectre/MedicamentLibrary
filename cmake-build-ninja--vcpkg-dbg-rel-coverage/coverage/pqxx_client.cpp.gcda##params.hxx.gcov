        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/pqxx/params.hxx
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Helpers for prepared statements and parameterised statements.
        -:    2: *
        -:    3: * See @ref connection and @ref transaction_base for more.
        -:    4: *
        -:    5: * Copyright (c) 2000-2024, Jeroen T. Vermeulen.
        -:    6: *
        -:    7: * See COPYING for copyright license.  If you did not receive a file called
        -:    8: * COPYING with this source code, please notify the distributor of this
        -:    9: * mistake, or contact the author.
        -:   10: */
        -:   11:#ifndef PQXX_H_PARAMS
        -:   12:#define PQXX_H_PARAMS
        -:   13:
        -:   14:#if !defined(PQXX_HEADER_PRE)
        -:   15:#  error "Include libpqxx headers as <pqxx/header>, not <pqxx/header.hxx>."
        -:   16:#endif
        -:   17:
        -:   18:#include <array>
        -:   19:
        -:   20:#include "pqxx/internal/concat.hxx"
        -:   21:#include "pqxx/internal/statement_parameters.hxx"
        -:   22:#include "pqxx/types.hxx"
        -:   23:
        -:   24:
        -:   25:namespace pqxx
        -:   26:{
        -:   27:/// Build a parameter list for a parameterised or prepared statement.
        -:   28:/** When calling a parameterised statement or a prepared statement, in some
        -:   29: * cases you can pass parameters into the statement directly in the invocation,
        -:   30: * as additional arguments to e.g. `exec_prepared` or `exec_params`.  But not
        -:   31: * all functions accept that, plus, sometimes you want to build the lists at
        -:   32: * run time.
        -:   33: *
        -:   34: * In those situations, you can create a `params` and append your parameters
        -:   35: * into that, one by one.  Then you pass the `params` to  the function that
        -:   36: * executes your SQL statement.
        -:   37: *
        -:   38: * Combinations also work: if you have a `params` containing a string
        -:   39: * parameter, and you call `exec_params` with an `int` argument followed by
        -:   40: * your `params`, you'll be passing the `int` as the first parameter and
        -:   41: * the string as the second.  You can even insert a `params` in a `params`,
        -:   42: * or pass two `params` objects to a statement.  In the end all the embedded
        -:   43: * parameters show up in their natural order.
        -:   44: */
function _ZN4pqxx6paramsD2Ev called 300228 returned 100% blocks executed 100%
function _ZN4pqxx6paramsC2ERKS0_ called 100081 returned 100% blocks executed 100%
        -:   45:class PQXX_LIBEXPORT params
        -:   46:{
        -:   47:public:
function _ZN4pqxx6paramsC2Ev called 100081 returned 100% blocks executed 100%
   100081:   48:  params() = default;
   100081:   48-block  0
        -:   49:
        -:   50:  /// Pre-populate a `params` with `args`.  Feel free to add more later.
function _ZN4pqxx6paramsC2IJRS0_EEEDpOT_ called 100066 returned 100% blocks executed 60%
   100066:   51:  template<typename... Args> constexpr params(Args &&...args)
        -:   52:  {
   100066:   53:    reserve(sizeof...(args));
   100066:   53-block  0
branch  0 taken 100066
branch  1 taken 0
   100066:   54:    append_pack(std::forward<Args>(args)...);
   100066:   54-block  0
branch  0 taken 100066
branch  1 taken 0
   100066:   55:  }
   100066:   55-block  0
    $$$$$:   55-block  1
    $$$$$:   55-block  2
        -:   56:
        -:   57:  /// Pre-allocate room for at least `n` parameters.
        -:   58:  /** This is not needed, but it may improve efficiency.
        -:   59:   *
        -:   60:   * Reserve space if you're going to add parameters individually, and you've
        -:   61:   * got some idea of how many there are going to be.  It may save some
        -:   62:   * memory re-allocations.
        -:   63:   */
        -:   64:  void reserve(std::size_t n) &;
        -:   65:
        -:   66:  // C++20: constexpr.
        -:   67:  /// Get the number of parameters currently in this `params`.
        -:   68:  [[nodiscard]] auto size() const noexcept { return m_params.size(); }
        -:   69:
        -:   70:  // C++20: Use the vector's ssize() directly and go noexcept+constexpr.
        -:   71:  /// Get the number of parameters (signed).
        -:   72:  /** Unlike `size()`, this is not yet `noexcept`.  That's because C++17's
        -:   73:   * `std::vector` does not have a `ssize()` member function.  These member
        -:   74:   * functions are `noexcept`, but `std::size()` and `std::ssize()` are
        -:   75:   * not.
        -:   76:   */
        -:   77:  [[nodiscard]] auto ssize() const { return pqxx::internal::ssize(m_params); }
        -:   78:
        -:   79:  /// Append a null value.
        -:   80:  void append() &;
        -:   81:
        -:   82:  /// Append a non-null zview parameter.
        -:   83:  /** The underlying data must stay valid for as long as the `params`
        -:   84:   * remains active.
        -:   85:   */
        -:   86:  void append(zview) &;
        -:   87:
        -:   88:  /// Append a non-null string parameter.
        -:   89:  /** Copies the underlying data into internal storage.  For best efficiency,
        -:   90:   * use the @ref zview variant if you can, or `std::move()`
        -:   91:   */
        -:   92:  void append(std::string const &) &;
        -:   93:
        -:   94:  /// Append a non-null string parameter.
        -:   95:  void append(std::string &&) &;
        -:   96:
        -:   97:  /// Append a non-null binary parameter.
        -:   98:  /** The underlying data must stay valid for as long as the `params`
        -:   99:   * remains active.
        -:  100:   */
        -:  101:  void append(bytes_view) &;
        -:  102:
        -:  103:  /// Append a non-null binary parameter.
        -:  104:  /** Copies the underlying data into internal storage.  For best efficiency,
        -:  105:   * use the `pqxx::bytes_view` variant if you can, or `std::move()`.
        -:  106:   */
        -:  107:  void append(bytes const &) &;
        -:  108:
        -:  109:#if defined(PQXX_HAVE_CONCEPTS)
        -:  110:  /// Append a non-null binary parameter.
        -:  111:  /** The `data` object must stay in place and unchanged, for as long as the
        -:  112:   * `params` remains active.
        -:  113:   */
        -:  114:  template<binary DATA> void append(DATA const &data) &
        -:  115:  {
        -:  116:    append(bytes_view{std::data(data), std::size(data)});
        -:  117:  }
        -:  118:#endif // PQXX_HAVE_CONCEPTS
        -:  119:
        -:  120:  /// Append a non-null binary parameter.
        -:  121:  void append(bytes &&) &;
        -:  122:
        -:  123:  /// @deprecated Append binarystring parameter.
        -:  124:  /** The binarystring must stay valid for as long as the `params` remains
        -:  125:   * active.
        -:  126:   */
        -:  127:  void append(binarystring const &value) &;
        -:  128:
        -:  129:  /// Append all parameters from value.
        -:  130:  template<typename IT, typename ACCESSOR>
        -:  131:  void append(pqxx::internal::dynamic_params<IT, ACCESSOR> const &value) &
        -:  132:  {
        -:  133:    for (auto &param : value) append(value.access(param));
        -:  134:  }
        -:  135:
        -:  136:  void append(params const &value) &;
        -:  137:
        -:  138:  void append(params &&value) &;
        -:  139:
        -:  140:  /// Append a non-null parameter, converting it to its string
        -:  141:  /// representation.
        -:  142:  template<typename TYPE> void append(TYPE const &value) &
        -:  143:  {
        -:  144:    // TODO: Pool storage for multiple string conversions in one buffer?
        -:  145:    if constexpr (nullness<strip_t<TYPE>>::always_null)
        -:  146:    {
        -:  147:      ignore_unused(value);
        -:  148:      m_params.emplace_back();
        -:  149:    }
        -:  150:    else if (is_null(value))
        -:  151:    {
        -:  152:      m_params.emplace_back();
        -:  153:    }
        -:  154:    else
        -:  155:    {
        -:  156:      m_params.emplace_back(entry{to_string(value)});
        -:  157:    }
        -:  158:  }
        -:  159:
        -:  160:  /// Append all elements of `range` as parameters.
        -:  161:  template<PQXX_RANGE_ARG RANGE> void append_multi(RANGE const &range) &
        -:  162:  {
        -:  163:#if defined(PQXX_HAVE_CONCEPTS)
        -:  164:    if constexpr (std::ranges::sized_range<RANGE>)
        -:  165:      reserve(std::size(*this) + std::size(range));
        -:  166:#endif
        -:  167:    for (auto &value : range) append(value);
        -:  168:  }
        -:  169:
        -:  170:  /// For internal use: Generate a `params` object for use in calls.
        -:  171:  /** The params object encapsulates the pointers which we will need to pass
        -:  172:   * to libpq when calling a parameterised or prepared statement.
        -:  173:   *
        -:  174:   * The pointers in the params will refer to storage owned by either the
        -:  175:   * params object, or the caller.  This is not a problem because a
        -:  176:   * `c_params` object is guaranteed to live only while the call is going on.
        -:  177:   * As soon as we climb back out of that call tree, we're done with that
        -:  178:   * data.
        -:  179:   */
        -:  180:  pqxx::internal::c_params make_c_params() const;
        -:  181:
        -:  182:private:
        -:  183:  /// Recursively append a pack of params.
        -:  184:  template<typename Arg, typename... More>
function _ZN4pqxx6params11append_packIRS0_JEEEvOT_DpOT0_ called 100066 returned 100% blocks executed 100%
   100066:  185:  void append_pack(Arg &&arg, More &&...args)
        -:  186:  {
   100066:  187:    this->append(std::forward<Arg>(arg));
        -:  188:    // Recurse for remaining args.
   100066:  189:    append_pack(std::forward<More>(args)...);
   100066:  190:  }
   100066:  190-block  0
        -:  191:
        -:  192:  /// Terminating case: append an empty parameter pack.  It's not hard BTW.
function _ZN4pqxx6params11append_packEv called 100066 returned 100% blocks executed 100%
   100066:  193:  constexpr void append_pack() noexcept {}
   100066:  193-block  0
        -:  194:
        -:  195:  // The way we store a parameter depends on whether it's binary or text
        -:  196:  // (most types are text), and whether we're responsible for storing the
        -:  197:  // contents.
        -:  198:  using entry =
        -:  199:    std::variant<std::nullptr_t, zview, std::string, bytes_view, bytes>;
        -:  200:  std::vector<entry> m_params;
        -:  201:
        -:  202:  static constexpr std::string_view s_overflow{
        -:  203:    "Statement parameter length overflow."sv};
        -:  204:};
        -:  205:
        -:  206:
        -:  207:/// Generate parameter placeholders for use in an SQL statement.
        -:  208:/** When you want to pass parameters to a prepared statement or a parameterised
        -:  209: * statement, you insert placeholders into the SQL.  During invocation, the
        -:  210: * database replaces those with the respective parameter values you passed.
        -:  211: *
        -:  212: * The placeholders look like `$1` (for the first parameter value), `$2` (for
        -:  213: * the second), and so on.  You can just write those directly in your
        -:  214: * statement.  But for those rare cases where it becomes difficult to track
        -:  215: * which number a placeholder should have, you can use a `placeholders` object
        -:  216: * to count and generate them in order.
        -:  217: */
        -:  218:template<typename COUNTER = unsigned int> class placeholders
        -:  219:{
        -:  220:public:
        -:  221:  /// Maximum number of parameters we support.
        -:  222:  static inline constexpr unsigned int max_params{
        -:  223:    (std::numeric_limits<COUNTER>::max)()};
        -:  224:
        -:  225:  placeholders()
        -:  226:  {
        -:  227:    static constexpr auto initial{"$1\0"sv};
        -:  228:    initial.copy(std::data(m_buf), std::size(initial));
        -:  229:  }
        -:  230:
        -:  231:  /// Read an ephemeral version of the current placeholder text.
        -:  232:  /** @warning Changing the current placeholder number will overwrite this.
        -:  233:   * Use the view immediately, or lose it.
        -:  234:   */
        -:  235:  constexpr zview view() const & noexcept
        -:  236:  {
        -:  237:    return zview{std::data(m_buf), m_len};
        -:  238:  }
        -:  239:
        -:  240:  /// Read the current placeholder text, as a `std::string`.
        -:  241:  /** This will be slightly slower than converting to a `zview`.  With most
        -:  242:   * C++ implementations however, until you get into ridiculous numbers of
        -:  243:   * parameters, the string will benefit from the Short String Optimization, or
        -:  244:   * SSO.
        -:  245:   */
        -:  246:  std::string get() const { return std::string(std::data(m_buf), m_len); }
        -:  247:
        -:  248:  /// Move on to the next parameter.
        -:  249:  void next() &
        -:  250:  {
        -:  251:    if (m_current >= max_params)
        -:  252:      throw range_error{pqxx::internal::concat(
        -:  253:        "Too many parameters in one statement: limit is ", max_params, ".")};
        -:  254:    PQXX_ASSUME(m_current > 0);
        -:  255:    ++m_current;
        -:  256:    if (m_current % 10 == 0)
        -:  257:    {
        -:  258:      // Carry the 1.  Don't get too clever for this relatively rare
        -:  259:      // case, just rewrite the entire number.  Leave the $ in place
        -:  260:      // though.
        -:  261:      char *const data{std::data(m_buf)};
        -:  262:      char *const end{string_traits<COUNTER>::into_buf(
        -:  263:        data + 1, data + std::size(m_buf), m_current)};
        -:  264:      // (Subtract because we don't include the trailing zero.)
        -:  265:      m_len = check_cast<COUNTER>(end - data, "placeholders counter") - 1;
        -:  266:    }
        -:  267:    else
        -:  268:    {
        -:  269:      PQXX_LIKELY
        -:  270:      // Shortcut for the common case: just increment that last digit.
        -:  271:      ++m_buf[m_len - 1];
        -:  272:    }
        -:  273:  }
        -:  274:
        -:  275:  /// Return the current placeholder number.  The initial placeholder is 1.
        -:  276:  COUNTER count() const noexcept { return m_current; }
        -:  277:
        -:  278:private:
        -:  279:  /// Current placeholder number.  Starts at 1.
        -:  280:  COUNTER m_current = 1;
        -:  281:
        -:  282:  /// Length of the current placeholder string, not including trailing zero.
        -:  283:  COUNTER m_len = 2;
        -:  284:
        -:  285:  /// Text buffer where we render the placeholders, with a trailing zero.
        -:  286:  /** We keep reusing this for every subsequent placeholder, just because we
        -:  287:   * don't like string allocations.
        -:  288:   *
        -:  289:   * Maximum length is the maximum base-10 digits that COUNTER can fully
        -:  290:   * represent, plus 1 more for the extra digit that it can only partially
        -:  291:   * fill up, plus room for the dollar sign and the trailing zero.
        -:  292:   */
        -:  293:  std::array<char, std::numeric_limits<COUNTER>::digits10 + 3> m_buf;
        -:  294:};
        -:  295:} // namespace pqxx
        -:  296:
        -:  297:
        -:  298:/// @deprecated The new @ref params class replaces all of this.
        -:  299:namespace pqxx::prepare
        -:  300:{
        -:  301:/// Pass a number of statement parameters only known at runtime.
        -:  302:/** @deprecated Use @ref params instead.
        -:  303: *
        -:  304: * When you call any of the `exec_params` functions, the number of arguments
        -:  305: * is normally known at compile time.  This helper function supports the case
        -:  306: * where it is not.
        -:  307: *
        -:  308: * Use this function to pass a variable number of parameters, based on a
        -:  309: * sequence ranging from `begin` to `end` exclusively.
        -:  310: *
        -:  311: * The technique combines with the regular static parameters.  You can use it
        -:  312: * to insert dynamic parameter lists in any place, or places, among the call's
        -:  313: * parameters.  You can even insert multiple dynamic sequences.
        -:  314: *
        -:  315: * @param begin A pointer or iterator for iterating parameters.
        -:  316: * @param end A pointer or iterator for iterating parameters.
        -:  317: * @return An object representing the parameters.
        -:  318: */
        -:  319:template<typename IT>
        -:  320:[[deprecated("Use the params class instead.")]] constexpr inline auto
        -:  321:make_dynamic_params(IT begin, IT end)
        -:  322:{
        -:  323:  return pqxx::internal::dynamic_params(begin, end);
        -:  324:}
        -:  325:
        -:  326:
        -:  327:/// Pass a number of statement parameters only known at runtime.
        -:  328:/** @deprecated Use @ref params instead.
        -:  329: *
        -:  330: * When you call any of the `exec_params` functions, the number of arguments
        -:  331: * is normally known at compile time.  This helper function supports the case
        -:  332: * where it is not.
        -:  333: *
        -:  334: * Use this function to pass a variable number of parameters, based on a
        -:  335: * container of parameter values.
        -:  336: *
        -:  337: * The technique combines with the regular static parameters.  You can use it
        -:  338: * to insert dynamic parameter lists in any place, or places, among the call's
        -:  339: * parameters.  You can even insert multiple dynamic containers.
        -:  340: *
        -:  341: * @param container A container of parameter values.
        -:  342: * @return An object representing the parameters.
        -:  343: */
        -:  344:template<typename C>
        -:  345:[[deprecated("Use the params class instead.")]] constexpr inline auto
        -:  346:make_dynamic_params(C const &container)
        -:  347:{
        -:  348:  using IT = typename C::const_iterator;
        -:  349:#include "pqxx/internal/ignore-deprecated-pre.hxx"
        -:  350:  return pqxx::internal::dynamic_params<IT>{container};
        -:  351:#include "pqxx/internal/ignore-deprecated-post.hxx"
        -:  352:}
        -:  353:
        -:  354:
        -:  355:/// Pass a number of statement parameters only known at runtime.
        -:  356:/** @deprecated Use @ref params instead.
        -:  357: *
        -:  358: * When you call any of the `exec_params` functions, the number of arguments
        -:  359: * is normally known at compile time.  This helper function supports the case
        -:  360: * where it is not.
        -:  361: *
        -:  362: * Use this function to pass a variable number of parameters, based on a
        -:  363: * container of parameter values.
        -:  364: *
        -:  365: * The technique combines with the regular static parameters.  You can use it
        -:  366: * to insert dynamic parameter lists in any place, or places, among the call's
        -:  367: * parameters.  You can even insert multiple dynamic containers.
        -:  368: *
        -:  369: * @param container A container of parameter values.
        -:  370: * @param accessor For each parameter `p`, pass `accessor(p)`.
        -:  371: * @return An object representing the parameters.
        -:  372: */
        -:  373:template<typename C, typename ACCESSOR>
        -:  374:[[deprecated("Use the params class instead.")]] constexpr inline auto
        -:  375:make_dynamic_params(C &container, ACCESSOR accessor)
        -:  376:{
        -:  377:  using IT = decltype(std::begin(container));
        -:  378:#include "pqxx/internal/ignore-deprecated-pre.hxx"
        -:  379:  return pqxx::internal::dynamic_params<IT, ACCESSOR>{container, accessor};
        -:  380:#include "pqxx/internal/ignore-deprecated-post.hxx"
        -:  381:}
        -:  382:} // namespace pqxx::prepare
        -:  383:#endif
