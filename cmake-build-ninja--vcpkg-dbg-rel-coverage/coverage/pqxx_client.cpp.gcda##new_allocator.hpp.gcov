        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/boost/container/new_allocator.hpp
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3:// (C) Copyright Ion Gaztanaga 2014-2015. Distributed under the Boost
        -:    4:// Software License, Version 1.0. (See accompanying file
        -:    5:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    6://
        -:    7:// See http://www.boost.org/libs/container for documentation.
        -:    8://
        -:    9://////////////////////////////////////////////////////////////////////////////
        -:   10:
        -:   11:#ifndef BOOST_CONTAINER_NEW_ALLOCATOR_HPP
        -:   12:#define BOOST_CONTAINER_NEW_ALLOCATOR_HPP
        -:   13:
        -:   14:#ifndef BOOST_CONFIG_HPP
        -:   15:#  include <boost/config.hpp>
        -:   16:#endif
        -:   17:
        -:   18:#if defined(BOOST_HAS_PRAGMA_ONCE)
        -:   19:#  pragma once
        -:   20:#endif
        -:   21:
        -:   22:#include <boost/container/detail/config_begin.hpp>
        -:   23:#include <boost/container/detail/workaround.hpp>
        -:   24:#include <boost/container/throw_exception.hpp>
        -:   25:#include <cstddef>
        -:   26:
        -:   27://!\file
        -:   28:
        -:   29:namespace boost {
        -:   30:namespace container {
        -:   31:
        -:   32:/// @cond
        -:   33:
        -:   34:template<bool Value>
        -:   35:struct new_allocator_bool
        -:   36:{  static const bool value = Value;  };
        -:   37:
        -:   38:template<class T>
        -:   39:class new_allocator;
        -:   40:
        -:   41:/// @endcond
        -:   42:
        -:   43://! Specialization of new_allocator for void types
        -:   44:template<>
        -:   45:class new_allocator<void>
        -:   46:{
        -:   47:   public:
        -:   48:   typedef void                                 value_type;
        -:   49:   typedef void *                               pointer;
        -:   50:   typedef const void*                          const_pointer;
        -:   51:   //!A integral constant of type bool with value true
        -:   52:   typedef BOOST_CONTAINER_IMPDEF(new_allocator_bool<true>) propagate_on_container_move_assignment;
        -:   53:   //!A integral constant of type bool with value true
        -:   54:   typedef BOOST_CONTAINER_IMPDEF(new_allocator_bool<true>) is_always_equal;
        -:   55:   // reference-to-void members are impossible
        -:   56:
        -:   57:   //!Obtains an new_allocator that allocates
        -:   58:   //!objects of type T2
        -:   59:   template<class T2>
        -:   60:   struct rebind
        -:   61:   {
        -:   62:      typedef new_allocator< T2> other;
        -:   63:   };
        -:   64:
        -:   65:   //!Default constructor
        -:   66:   //!Never throws
        -:   67:   new_allocator() BOOST_NOEXCEPT_OR_NOTHROW
        -:   68:   {}
        -:   69:
        -:   70:   //!Constructor from other new_allocator.
        -:   71:   //!Never throws
        -:   72:   new_allocator(const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:   73:   {}
        -:   74:
        -:   75:   //!Copy assignment operator from other new_allocator.
        -:   76:   //!Never throws
        -:   77:   new_allocator& operator=(const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:   78:   {
        -:   79:       return *this;
        -:   80:   }
        -:   81:
        -:   82:   //!Constructor from related new_allocator.
        -:   83:   //!Never throws
        -:   84:   template<class T2>
        -:   85:   new_allocator(const new_allocator<T2> &) BOOST_NOEXCEPT_OR_NOTHROW
        -:   86:   {}
        -:   87:
        -:   88:   //!Swaps two allocators, does nothing
        -:   89:   //!because this new_allocator is stateless
        -:   90:   friend void swap(new_allocator &, new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:   91:   {}
        -:   92:
        -:   93:   //!An new_allocator always compares to true, as memory allocated with one
        -:   94:   //!instance can be deallocated by another instance
        -:   95:   friend bool operator==(const new_allocator &, const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:   96:   {  return true;   }
        -:   97:
        -:   98:   //!An new_allocator always compares to false, as memory allocated with one
        -:   99:   //!instance can be deallocated by another instance
        -:  100:   friend bool operator!=(const new_allocator &, const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  101:   {  return false;   }
        -:  102:};
        -:  103:
        -:  104:
        -:  105://! This class is a reduced STL-compatible allocator that allocates memory using operator new
        -:  106:template<class T>
        -:  107:class new_allocator
        -:  108:{
        -:  109:   public:
        -:  110:   typedef T                                    value_type;
        -:  111:   typedef T *                                  pointer;
        -:  112:   typedef const T *                            const_pointer;
        -:  113:   typedef T &                                  reference;
        -:  114:   typedef const T &                            const_reference;
        -:  115:   typedef std::size_t                          size_type;
        -:  116:   typedef std::ptrdiff_t                       difference_type;
        -:  117:   //!A integral constant of type bool with value true
        -:  118:   typedef BOOST_CONTAINER_IMPDEF(new_allocator_bool<true>) propagate_on_container_move_assignment;
        -:  119:   //!A integral constant of type bool with value true
        -:  120:   typedef BOOST_CONTAINER_IMPDEF(new_allocator_bool<true>) is_always_equal;
        -:  121:
        -:  122:   //!Obtains an new_allocator that allocates
        -:  123:   //!objects of type T2
        -:  124:   template<class T2>
        -:  125:   struct rebind
        -:  126:   {
        -:  127:      typedef new_allocator<T2> other;
        -:  128:   };
        -:  129:
        -:  130:   //!Default constructor
        -:  131:   //!Never throws
function _ZN5boost9container13new_allocatorINS0_3dtl4pairIjNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEC2Ev called 20 returned 100% blocks executed 100%
function _ZN5boost9container13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorISt10shared_ptrIN8drug_lib6common8database9FieldBaseEESaISG_EEEEEC2Ev called 40 returned 100% blocks executed 100%
       60:  132:   inline new_allocator() BOOST_NOEXCEPT_OR_NOTHROW
       60:  133:   {}
       20:  133-block  0
       40:  133-block  1
        -:  134:
        -:  135:   //!Constructor from other new_allocator.
        -:  136:   //!Never throws
        -:  137:   inline new_allocator(const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  138:   {}
        -:  139:
        -:  140:   //!Copy assignment operator from other new_allocator.
        -:  141:   //!Never throws
        -:  142:   inline new_allocator& operator=(const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  143:   {  return *this;  }
        -:  144:
        -:  145:   //!Constructor from related new_allocator.
        -:  146:   //!Never throws
        -:  147:   template<class T2>
        -:  148:   inline new_allocator(const new_allocator<T2> &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  149:   {}
        -:  150:
        -:  151:   //!Allocates memory for an array of count elements.
        -:  152:   //!Throws bad_alloc if there is no enough memory
function _ZN5boost9container13new_allocatorINS0_3dtl4pairIjNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEE8allocateEm called 140 returned 100% blocks executed 66%
function _ZN5boost9container13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorISt10shared_ptrIN8drug_lib6common8database9FieldBaseEESaISG_EEEEE8allocateEm called 40 returned 100% blocks executed 66%
      180:  153:   pointer allocate(size_type count)
        -:  154:   {
      180:  155:      const std::size_t max_count = std::size_t(-1)/(2*sizeof(T));
      180:  156:      if(BOOST_UNLIKELY(count > max_count))
      140:  156-block  0
branch  0 taken 140
branch  1 taken 0
       40:  156-block  1
branch  2 taken 40
branch  3 taken 0
    #####:  157:         throw_bad_alloc();
    $$$$$:  157-block  0
    $$$$$:  157-block  1
      180:  158:      return static_cast<T*>(::operator new(count*sizeof(T)));
      140:  158-block  0
       40:  158-block  1
        -:  159:   }
        -:  160:
        -:  161:   //!Deallocates previously allocated memory.
        -:  162:   //!Never throws
function _ZN5boost9container13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorISt10shared_ptrIN8drug_lib6common8database9FieldBaseEESaISG_EEEEE10deallocateEPSJ_m called 0 returned 0% blocks executed 0%
function _ZN5boost9container13new_allocatorINS0_3dtl4pairIjNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEE10deallocateEPSA_m called 0 returned 0% blocks executed 0%
    #####:  163:   void deallocate(pointer ptr, size_type n) BOOST_NOEXCEPT_OR_NOTHROW
        -:  164:   {
        -:  165:      (void)n;
        -:  166:      # if __cpp_sized_deallocation
    #####:  167:      ::operator delete((void*)ptr, n * sizeof(T));
        -:  168:      #else
        -:  169:      ::operator delete((void*)ptr);
        -:  170:      # endif
    #####:  171:   }
    $$$$$:  171-block  0
    $$$$$:  171-block  1
        -:  172:
        -:  173:   //!Returns the maximum number of elements that could be allocated.
        -:  174:   //!Never throws
function _ZNK5boost9container13new_allocatorINS0_3dtl4pairIjNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEE8max_sizeEv called 280 returned 100% blocks executed 100%
function _ZNK5boost9container13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorISt10shared_ptrIN8drug_lib6common8database9FieldBaseEESaISG_EEEEE8max_sizeEv called 80 returned 100% blocks executed 100%
      360:  175:   inline size_type max_size() const BOOST_NOEXCEPT_OR_NOTHROW
      360:  176:   {  return std::size_t(-1)/(2*sizeof(T));   }
      280:  176-block  0
       80:  176-block  1
        -:  177:
        -:  178:   //!Swaps two allocators, does nothing
        -:  179:   //!because this new_allocator is stateless
        -:  180:   inline friend void swap(new_allocator &, new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  181:   {}
        -:  182:
        -:  183:   //!An new_allocator always compares to true, as memory allocated with one
        -:  184:   //!instance can be deallocated by another instance
        -:  185:   inline friend bool operator==(const new_allocator &, const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  186:   {  return true;   }
        -:  187:
        -:  188:   //!An new_allocator always compares to false, as memory allocated with one
        -:  189:   //!instance can be deallocated by another instance
        -:  190:   inline friend bool operator!=(const new_allocator &, const new_allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  191:   {  return false;   }
        -:  192:};
        -:  193:
        -:  194:}  //namespace container {
        -:  195:}  //namespace boost {
        -:  196:
        -:  197:#include <boost/container/detail/config_end.hpp>
        -:  198:
        -:  199:#endif   //BOOST_CONTAINER_NEW_ALLOCATOR_HPP
