        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/boost/container/detail/copy_move_algo.hpp
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Patient_Base.dir/patient/test_patient_base.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Patient_Base.dir/patient/test_patient_base.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3:// (C) Copyright Ion Gaztanaga 2005-2013. Distributed under the Boost
        -:    4:// Software License, Version 1.0. (See accompanying file
        -:    5:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    6://
        -:    7:// See http://www.boost.org/libs/container for documentation.
        -:    8://
        -:    9://////////////////////////////////////////////////////////////////////////////
        -:   10:#ifndef BOOST_CONTAINER_DETAIL_COPY_MOVE_ALGO_HPP
        -:   11:#define BOOST_CONTAINER_DETAIL_COPY_MOVE_ALGO_HPP
        -:   12:
        -:   13:#ifndef BOOST_CONFIG_HPP
        -:   14:#  include <boost/config.hpp>
        -:   15:#endif
        -:   16:
        -:   17:#if defined(BOOST_HAS_PRAGMA_ONCE)
        -:   18:#  pragma once
        -:   19:#endif
        -:   20:
        -:   21:// container
        -:   22:#include <boost/container/allocator_traits.hpp>
        -:   23:// container/detail
        -:   24:#include <boost/container/detail/iterator.hpp>
        -:   25:#include <boost/move/detail/iterator_to_raw_pointer.hpp>
        -:   26:#include <boost/container/detail/mpl.hpp>
        -:   27:#include <boost/container/detail/type_traits.hpp>
        -:   28:#include <boost/container/detail/construct_in_place.hpp>
        -:   29:#include <boost/container/detail/destroyers.hpp>
        -:   30:
        -:   31:// move
        -:   32:#include <boost/move/adl_move_swap.hpp>
        -:   33:#include <boost/move/iterator.hpp>
        -:   34:#include <boost/move/utility_core.hpp>
        -:   35:#include <boost/move/traits.hpp>
        -:   36:// other
        -:   37:#include <boost/assert.hpp>
        -:   38:// std
        -:   39:#include <cstring> //for memmove/memcpy
        -:   40:
        -:   41:#if defined(BOOST_GCC) && (BOOST_GCC >= 40600)
        -:   42:#pragma GCC diagnostic push
        -:   43://pair memcpy optimizations rightfully detected by GCC
        -:   44:#  if defined(BOOST_GCC) && (BOOST_GCC >= 80000)
        -:   45:#     pragma GCC diagnostic ignored "-Wclass-memaccess"
        -:   46:#  endif
        -:   47://GCC 8 seems a bit confused about array access error with static_vector
        -:   48://when out of bound exceptions are being thrown.
        -:   49:#  if defined(BOOST_GCC) && ((BOOST_GCC >= 80000) && (BOOST_GCC < 80200))
        -:   50:#     pragma GCC diagnostic ignored "-Wstringop-overflow"
        -:   51:#  endif
        -:   52://GCC 12 seems a bit confused about array access error with small_vector
        -:   53:#  if defined(BOOST_GCC) && ((BOOST_GCC >= 120000) && (BOOST_GCC < 130000))
        -:   54:#     pragma GCC diagnostic ignored "-Wstringop-overread"
        -:   55:#     pragma GCC diagnostic ignored "-Wstringop-overflow"
        -:   56:#  endif
        -:   57:#  pragma GCC diagnostic ignored "-Warray-bounds"
        -:   58:#endif
        -:   59:
        -:   60:namespace boost {
        -:   61:namespace container {
        -:   62:namespace dtl {
        -:   63:
        -:   64:template<class I>
        -:   65:struct are_elements_contiguous
        -:   66:{
        -:   67:   static const bool value = false;
        -:   68:};
        -:   69:
        -:   70://///////////////////////
        -:   71://    raw pointers
        -:   72://///////////////////////
        -:   73:
        -:   74:template<class T>
        -:   75:struct are_elements_contiguous<T*>
        -:   76:{
        -:   77:   static const bool value = true;
        -:   78:};
        -:   79:
        -:   80://///////////////////////
        -:   81://    move iterators
        -:   82://///////////////////////
        -:   83:
        -:   84:template<class It>
        -:   85:struct are_elements_contiguous< ::boost::move_iterator<It> >
        -:   86:   : are_elements_contiguous<It>
        -:   87:{};
        -:   88:
        -:   89:}  //namespace dtl {
        -:   90:
        -:   91://///////////////////////
        -:   92://    predeclarations
        -:   93://///////////////////////
        -:   94:
        -:   95:template <class Pointer, bool IsConst>
        -:   96:class vec_iterator;
        -:   97:
        -:   98:}  //namespace container {
        -:   99:
        -:  100:namespace interprocess {
        -:  101:
        -:  102:template <class PointedType, class DifferenceType, class OffsetType, std::size_t OffsetAlignment>
        -:  103:class offset_ptr;
        -:  104:
        -:  105:}  //namespace interprocess {
        -:  106:
        -:  107:namespace container {
        -:  108:
        -:  109:namespace dtl {
        -:  110:
        -:  111://///////////////////////
        -:  112://vector_[const_]iterator
        -:  113://///////////////////////
        -:  114:
        -:  115:template <class Pointer, bool IsConst>
        -:  116:struct are_elements_contiguous<boost::container::vec_iterator<Pointer, IsConst> >
        -:  117:{
        -:  118:   static const bool value = true;
        -:  119:};
        -:  120:
        -:  121:
        -:  122://///////////////////////
        -:  123://    offset_ptr
        -:  124://///////////////////////
        -:  125:
        -:  126:template <class PointedType, class DifferenceType, class OffsetType, std::size_t OffsetAlignment>
        -:  127:struct are_elements_contiguous< ::boost::interprocess::offset_ptr<PointedType, DifferenceType, OffsetType, OffsetAlignment> >
        -:  128:{
        -:  129:   static const bool value = true;
        -:  130:};
        -:  131:
        -:  132:template <typename I, typename O>
        -:  133:struct are_contiguous_and_same
        -:  134:   : boost::move_detail::and_
        -:  135:      < are_elements_contiguous<I>
        -:  136:      , are_elements_contiguous<O>
        -:  137:      , is_same< typename remove_const< typename ::boost::container::iter_value<I>::type >::type
        -:  138:               , typename ::boost::container::iterator_traits<O>::value_type
        -:  139:               >
        -:  140:      >
        -:  141:{};
        -:  142:
        -:  143:template <typename I, typename O>
        -:  144:struct is_memtransfer_copy_assignable
        -:  145:   : boost::move_detail::and_
        -:  146:      < are_contiguous_and_same<I, O>
        -:  147:      , dtl::is_trivially_copy_assignable< typename ::boost::container::iter_value<I>::type >
        -:  148:      >
        -:  149:{};
        -:  150:
        -:  151:template <typename I, typename O>
        -:  152:struct is_memtransfer_copy_constructible
        -:  153:   : boost::move_detail::and_
        -:  154:      < are_contiguous_and_same<I, O>
        -:  155:      , dtl::is_trivially_copy_constructible< typename ::boost::container::iter_value<I>::type >
        -:  156:      >
        -:  157:{};
        -:  158:
        -:  159:template <typename I, typename O, typename R>
        -:  160:struct enable_if_memtransfer_copy_constructible
        -:  161:   : enable_if<dtl::is_memtransfer_copy_constructible<I, O>, R>
        -:  162:{};
        -:  163:
        -:  164:template <typename I, typename O, typename R>
        -:  165:struct disable_if_memtransfer_copy_constructible
        -:  166:   : disable_if<dtl::is_memtransfer_copy_constructible<I, O>, R>
        -:  167:{};
        -:  168:
        -:  169:template <typename I, typename O, typename R>
        -:  170:struct enable_if_memtransfer_copy_assignable
        -:  171:   : enable_if<dtl::is_memtransfer_copy_assignable<I, O>, R>
        -:  172:{};
        -:  173:
        -:  174:template <typename I, typename O, typename R>
        -:  175:struct disable_if_memtransfer_copy_assignable
        -:  176:   : disable_if<dtl::is_memtransfer_copy_assignable<I, O>, R>
        -:  177:{};
        -:  178:
        -:  179:template <class T>
        -:  180:struct has_single_value
        -:  181:{
        -:  182:private:
        -:  183:   struct two { char array_[2]; };
        -:  184:   template<bool Arg> struct wrapper;
        -:  185:   template <class U> static two test(int, ...);
        -:  186:   template <class U> static char test(int, const wrapper<U::single_value>*);
        -:  187:public:
        -:  188:   static const bool value = sizeof(test<T>(0, 0)) == 1;
        -:  189:   void dummy() {}
        -:  190:};
        -:  191:
        -:  192:template<class InsertionProxy, bool = has_single_value<InsertionProxy>::value>
        -:  193:struct is_single_value_proxy_impl
        -:  194:{
        -:  195:   static const bool value = InsertionProxy::single_value;
        -:  196:};
        -:  197:
        -:  198:template<class InsertionProxy>
        -:  199:struct is_single_value_proxy_impl<InsertionProxy, false>
        -:  200:{
        -:  201:   static const bool value = false;
        -:  202:};
        -:  203:
        -:  204:template<class InsertionProxy>
        -:  205:struct is_single_value_proxy
        -:  206:   : is_single_value_proxy_impl<InsertionProxy>
        -:  207:{};
        -:  208:
        -:  209:template <typename P, typename R = void>
        -:  210:struct enable_if_single_value_proxy
        -:  211:   : enable_if<is_single_value_proxy<P>, R>
        -:  212:{};
        -:  213:
        -:  214:template <typename P, typename R = void>
        -:  215:struct disable_if_single_value_proxy
        -:  216:   : disable_if<is_single_value_proxy<P>, R>
        -:  217:{};
        -:  218:
        -:  219:template
        -:  220:   <typename I, // I models InputIterator
        -:  221:    typename F> // F models ForwardIterator
        -:  222:inline F memmove(I f, I l, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  223:{
        -:  224:   typedef typename boost::container::iter_value<I>::type      value_type;
        -:  225:   typedef typename boost::container::iterator_traits<F>::difference_type r_difference_type;
        -:  226:   value_type *const dest_raw = boost::movelib::iterator_to_raw_pointer(r);
        -:  227:   const value_type *const beg_raw = boost::movelib::iterator_to_raw_pointer(f);
        -:  228:   const value_type *const end_raw = boost::movelib::iterator_to_raw_pointer(l);
        -:  229:   if(BOOST_LIKELY(beg_raw != end_raw && dest_raw && beg_raw)){
        -:  230:      const std::size_t n = std::size_t(end_raw - beg_raw)   ;
        -:  231:      std::memmove(dest_raw, beg_raw, sizeof(value_type)*n);
        -:  232:      r += static_cast<r_difference_type>(n);
        -:  233:   }
        -:  234:   return r;
        -:  235:}
        -:  236:
        -:  237:template
        -:  238:   <typename I, // I models InputIterator
        -:  239:    typename F> // F models ForwardIterator
        -:  240:inline F memmove_n(I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  241:{
        -:  242:   typedef typename boost::container::iter_value<I>::type value_type;
        -:  243:   typedef typename boost::container::iterator_traits<F>::difference_type r_difference_type;
        -:  244:   if(BOOST_LIKELY(n != 0)){
        -:  245:      void *dst = boost::movelib::iterator_to_raw_pointer(r);
        -:  246:      const void *src = boost::movelib::iterator_to_raw_pointer(f);
        -:  247:      if (dst && src)
        -:  248:         std::memmove(dst, src, sizeof(value_type)*n);
        -:  249:      r += static_cast<r_difference_type>(n);
        -:  250:   }
        -:  251:
        -:  252:   return r;
        -:  253:}
        -:  254:
        -:  255:template
        -:  256:   <typename I, // I models InputIterator
        -:  257:    typename F> // F models ForwardIterator
        -:  258:inline I memmove_n_source(I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  259:{
        -:  260:   if(BOOST_LIKELY(n != 0)){
        -:  261:      typedef typename boost::container::iter_value<I>::type value_type;
        -:  262:      typedef typename boost::container::iterator_traits<I>::difference_type i_difference_type;
        -:  263:      void *dst = boost::movelib::iterator_to_raw_pointer(r);
        -:  264:      const void *src = boost::movelib::iterator_to_raw_pointer(f);
        -:  265:      if (dst && src)
        -:  266:         std::memmove(dst, src, sizeof(value_type)*n);
        -:  267:      f += static_cast<i_difference_type>(n);
        -:  268:   }
        -:  269:   return f;
        -:  270:}
        -:  271:
        -:  272:template
        -:  273:   <typename I, // I models InputIterator
        -:  274:    typename F> // F models ForwardIterator
        -:  275:inline I memmove_n_source_dest(I f, std::size_t n, F &r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  276:{
        -:  277:   typedef typename boost::container::iter_value<I>::type value_type;
        -:  278:   typedef typename boost::container::iterator_traits<F>::difference_type i_difference_type;
        -:  279:   typedef typename boost::container::iterator_traits<F>::difference_type f_difference_type;
        -:  280:
        -:  281:   if(BOOST_LIKELY(n != 0)){
        -:  282:      void *dst = boost::movelib::iterator_to_raw_pointer(r);
        -:  283:      const void *src = boost::movelib::iterator_to_raw_pointer(f);
        -:  284:      if (dst && src)
        -:  285:         std::memmove(dst, src, sizeof(value_type)*n);
        -:  286:      f += i_difference_type(n);
        -:  287:      r += f_difference_type(n);
        -:  288:   }
        -:  289:   return f;
        -:  290:}
        -:  291:
        -:  292:template <typename O>
        -:  293:struct is_memzero_initializable
        -:  294:{
        -:  295:   typedef typename ::boost::container::iterator_traits<O>::value_type value_type;
        -:  296:   static const bool value = are_elements_contiguous<O>::value &&
        -:  297:      (  dtl::is_integral<value_type>::value || dtl::is_enum<value_type>::value
        -:  298:      #if defined(BOOST_CONTAINER_MEMZEROED_POINTER_IS_NULL)
        -:  299:      || dtl::is_pointer<value_type>::value
        -:  300:      #endif
        -:  301:      #if defined(BOOST_CONTAINER_MEMZEROED_FLOATING_POINT_IS_ZERO)
        -:  302:      || dtl::is_floating_point<value_type>::value
        -:  303:      #endif
        -:  304:      );
        -:  305:};
        -:  306:
        -:  307:template <typename O, typename R>
        -:  308:struct enable_if_memzero_initializable
        -:  309:   : enable_if_c<dtl::is_memzero_initializable<O>::value, R>
        -:  310:{};
        -:  311:
        -:  312:template <typename O, typename R>
        -:  313:struct disable_if_memzero_initializable
        -:  314:   : enable_if_c<!dtl::is_memzero_initializable<O>::value, R>
        -:  315:{};
        -:  316:
        -:  317:template <typename I, typename R>
        -:  318:struct enable_if_trivially_destructible
        -:  319:   : enable_if_c < dtl::is_trivially_destructible
        -:  320:                  <typename boost::container::iter_value<I>::type>::value
        -:  321:               , R>
        -:  322:{};
        -:  323:
        -:  324:template <typename I, typename R>
        -:  325:struct disable_if_trivially_destructible
        -:  326:   : enable_if_c <!dtl::is_trivially_destructible
        -:  327:                  <typename boost::container::iter_value<I>::type>::value
        -:  328:               , R>
        -:  329:{};
        -:  330:
        -:  331:}  //namespace dtl {
        -:  332:
        -:  333://////////////////////////////////////////////////////////////////////////////
        -:  334://
        -:  335://                               uninitialized_move_alloc
        -:  336://
        -:  337://////////////////////////////////////////////////////////////////////////////
        -:  338:
        -:  339:
        -:  340://! <b>Effects</b>:
        -:  341://!   \code
        -:  342://!   for (; f != l; ++r, ++f)
        -:  343://!      allocator_traits::construct(a, &*r, boost::move(*f));
        -:  344://!   \endcode
        -:  345://!
        -:  346://! <b>Returns</b>: r
        -:  347:template
        -:  348:   <typename Allocator,
        -:  349:    typename I, // I models InputIterator
        -:  350:    typename F> // F models ForwardIterator
        -:  351:inline typename dtl::disable_if_memtransfer_copy_constructible<I, F, F>::type
function _ZN5boost9container24uninitialized_move_allocINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEPSG_SI_EENS3_41disable_if_memtransfer_copy_constructibleIT0_T1_SL_E4typeERT_SK_SK_SL_ called 0 returned 0% blocks executed 0%
    #####:  352:   uninitialized_move_alloc(Allocator &a, I f, I l, F r)
        -:  353:{
    #####:  354:   F back = r;
        -:  355:   BOOST_CONTAINER_TRY{
    #####:  356:      while (f != l) {
    $$$$$:  356-block  0
    $$$$$:  356-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  356-block  2
    #####:  357:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r), boost::move(*f));
    $$$$$:  357-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  357-block  1
branch  2 never executed
branch  3 never executed
    #####:  358:         ++f; ++r;
        -:  359:      }
    #####:  360:   }
    $$$$$:  360-block  0
        -:  361:   BOOST_CONTAINER_CATCH(...){
    #####:  362:      for (; back != r; ++back){
    $$$$$:  362-block  0
    $$$$$:  362-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  362-block  2
    #####:  363:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
    $$$$$:  363-block  0
branch  0 never executed
branch  1 never executed
    #####:  364:      }
    $$$$$:  364-block  0
    #####:  365:      BOOST_CONTAINER_RETHROW;
    $$$$$:  365-block  0
branch  0 never executed
branch  1 never executed
    #####:  366:   }
    $$$$$:  366-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  366-block  1
    $$$$$:  366-block  2
    $$$$$:  366-block  3
        -:  367:   BOOST_CONTAINER_CATCH_END
    #####:  368:   return r;
    $$$$$:  368-block  0
    #####:  369:}
    $$$$$:  369-block  0
        -:  370:
        -:  371:template
        -:  372:   <typename Allocator,
        -:  373:    typename I, // I models InputIterator
        -:  374:    typename F> // F models ForwardIterator
        -:  375:inline typename dtl::enable_if_memtransfer_copy_constructible<I, F, F>::type
        -:  376:   uninitialized_move_alloc(Allocator &, I f, I l, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  377:{  return dtl::memmove(f, l, r); }
        -:  378:
        -:  379://////////////////////////////////////////////////////////////////////////////
        -:  380://
        -:  381://                               uninitialized_move_alloc_n
        -:  382://
        -:  383://////////////////////////////////////////////////////////////////////////////
        -:  384:
        -:  385://! <b>Effects</b>:
        -:  386://!   \code
        -:  387://!   for (; n--; ++r, ++f)
        -:  388://!      allocator_traits::construct(a, &*r, boost::move(*f));
        -:  389://!   \endcode
        -:  390://!
        -:  391://! <b>Returns</b>: r
        -:  392:template
        -:  393:   <typename Allocator,
        -:  394:    typename I, // I models InputIterator
        -:  395:    typename F> // F models ForwardIterator
        -:  396:inline typename dtl::disable_if_memtransfer_copy_constructible<I, F, F>::type
        -:  397:   uninitialized_move_alloc_n(Allocator &a, I f, std::size_t n, F r)
        -:  398:{
        -:  399:   F back = r;
        -:  400:   BOOST_CONTAINER_TRY{
        -:  401:      while (n) {
        -:  402:         --n;
        -:  403:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r), boost::move(*f));
        -:  404:         ++f; ++r;
        -:  405:      }
        -:  406:   }
        -:  407:   BOOST_CONTAINER_CATCH(...){
        -:  408:      for (; back != r; ++back){
        -:  409:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  410:      }
        -:  411:      BOOST_CONTAINER_RETHROW;
        -:  412:   }
        -:  413:   BOOST_CONTAINER_CATCH_END
        -:  414:   return r;
        -:  415:}
        -:  416:
        -:  417:template
        -:  418:   <typename Allocator,
        -:  419:    typename I, // I models InputIterator
        -:  420:    typename F> // F models ForwardIterator
        -:  421:inline typename dtl::enable_if_memtransfer_copy_constructible<I, F, F>::type
        -:  422:   uninitialized_move_alloc_n(Allocator &, I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  423:{  return dtl::memmove_n(f, n, r); }
        -:  424:
        -:  425://////////////////////////////////////////////////////////////////////////////
        -:  426://
        -:  427://                               uninitialized_move_alloc_n_source
        -:  428://
        -:  429://////////////////////////////////////////////////////////////////////////////
        -:  430:
        -:  431://! <b>Effects</b>:
        -:  432://!   \code
        -:  433://!   for (; n--; ++r, ++f)
        -:  434://!      allocator_traits::construct(a, &*r, boost::move(*f));
        -:  435://!   \endcode
        -:  436://!
        -:  437://! <b>Returns</b>: f (after incremented)
        -:  438:template
        -:  439:   <typename Allocator,
        -:  440:    typename I, // I models InputIterator
        -:  441:    typename F> // F models ForwardIterator
        -:  442:inline typename dtl::disable_if_memtransfer_copy_constructible<I, F, I>::type
        -:  443:   uninitialized_move_alloc_n_source(Allocator &a, I f, std::size_t n, F r)
        -:  444:{
        -:  445:   F back = r;
        -:  446:   BOOST_CONTAINER_TRY{
        -:  447:      while (n) {
        -:  448:         --n;
        -:  449:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r), boost::move(*f));
        -:  450:         ++f; ++r;
        -:  451:      }
        -:  452:   }
        -:  453:   BOOST_CONTAINER_CATCH(...){
        -:  454:      for (; back != r; ++back){
        -:  455:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  456:      }
        -:  457:      BOOST_CONTAINER_RETHROW;
        -:  458:   }
        -:  459:   BOOST_CONTAINER_CATCH_END
        -:  460:   return f;
        -:  461:}
        -:  462:
        -:  463:template
        -:  464:   <typename Allocator,
        -:  465:    typename I, // I models InputIterator
        -:  466:    typename F> // F models ForwardIterator
        -:  467:inline typename dtl::enable_if_memtransfer_copy_constructible<I, F, I>::type
        -:  468:   uninitialized_move_alloc_n_source(Allocator &, I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  469:{  return dtl::memmove_n_source(f, n, r); }
        -:  470:
        -:  471://////////////////////////////////////////////////////////////////////////////
        -:  472://
        -:  473://                               uninitialized_copy_alloc
        -:  474://
        -:  475://////////////////////////////////////////////////////////////////////////////
        -:  476:
        -:  477://! <b>Effects</b>:
        -:  478://!   \code
        -:  479://!   for (; f != l; ++r, ++f)
        -:  480://!      allocator_traits::construct(a, &*r, *f);
        -:  481://!   \endcode
        -:  482://!
        -:  483://! <b>Returns</b>: r
        -:  484:template
        -:  485:   <typename Allocator,
        -:  486:    typename I, // I models InputIterator
        -:  487:    typename F> // F models ForwardIterator
        -:  488:inline typename dtl::disable_if_memtransfer_copy_constructible<I, F, F>::type
        -:  489:   uninitialized_copy_alloc(Allocator &a, I f, I l, F r)
        -:  490:{
        -:  491:   F back = r;
        -:  492:   BOOST_CONTAINER_TRY{
        -:  493:      while (f != l) {
        -:  494:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r), *f);
        -:  495:         ++f; ++r;
        -:  496:      }
        -:  497:   }
        -:  498:   BOOST_CONTAINER_CATCH(...){
        -:  499:      for (; back != r; ++back){
        -:  500:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  501:      }
        -:  502:      BOOST_CONTAINER_RETHROW;
        -:  503:   }
        -:  504:   BOOST_CONTAINER_CATCH_END
        -:  505:   return r;
        -:  506:}
        -:  507:
        -:  508:template
        -:  509:   <typename Allocator,
        -:  510:    typename I, // I models InputIterator
        -:  511:    typename F> // F models ForwardIterator
        -:  512:inline typename dtl::enable_if_memtransfer_copy_constructible<I, F, F>::type
        -:  513:   uninitialized_copy_alloc(Allocator &, I f, I l, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  514:{  return dtl::memmove(f, l, r); }
        -:  515:
        -:  516://////////////////////////////////////////////////////////////////////////////
        -:  517://
        -:  518://                               uninitialized_copy_alloc_n
        -:  519://
        -:  520://////////////////////////////////////////////////////////////////////////////
        -:  521:
        -:  522://! <b>Effects</b>:
        -:  523://!   \code
        -:  524://!   for (; n--; ++r, ++f)
        -:  525://!      allocator_traits::construct(a, &*r, *f);
        -:  526://!   \endcode
        -:  527://!
        -:  528://! <b>Returns</b>: r
        -:  529:template
        -:  530:   <typename Allocator,
        -:  531:    typename I, // I models InputIterator
        -:  532:    typename F> // F models ForwardIterator
        -:  533:inline typename dtl::disable_if_memtransfer_copy_constructible<I, F, F>::type
        -:  534:   uninitialized_copy_alloc_n(Allocator &a, I f, std::size_t n, F r)
        -:  535:{
        -:  536:   F back = r;
        -:  537:   BOOST_CONTAINER_TRY{
        -:  538:      while (n) {
        -:  539:         --n;
        -:  540:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r), *f);
        -:  541:         ++f; ++r;
        -:  542:      }
        -:  543:   }
        -:  544:   BOOST_CONTAINER_CATCH(...){
        -:  545:      for (; back != r; ++back){
        -:  546:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  547:      }
        -:  548:      BOOST_CONTAINER_RETHROW;
        -:  549:   }
        -:  550:   BOOST_CONTAINER_CATCH_END
        -:  551:   return r;
        -:  552:}
        -:  553:
        -:  554:template
        -:  555:   <typename Allocator,
        -:  556:    typename I, // I models InputIterator
        -:  557:    typename F> // F models ForwardIterator
        -:  558:inline typename dtl::enable_if_memtransfer_copy_constructible<I, F, F>::type
        -:  559:   uninitialized_copy_alloc_n(Allocator &, I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  560:{  return dtl::memmove_n(f, n, r); }
        -:  561:
        -:  562://////////////////////////////////////////////////////////////////////////////
        -:  563://
        -:  564://                               uninitialized_copy_alloc_n_source
        -:  565://
        -:  566://////////////////////////////////////////////////////////////////////////////
        -:  567:
        -:  568://! <b>Effects</b>:
        -:  569://!   \code
        -:  570://!   for (; n--; ++r, ++f)
        -:  571://!      allocator_traits::construct(a, &*r, *f);
        -:  572://!   \endcode
        -:  573://!
        -:  574://! <b>Returns</b>: f (after incremented)
        -:  575:template
        -:  576:   <typename Allocator,
        -:  577:    typename I, // I models InputIterator
        -:  578:    typename F> // F models ForwardIterator
        -:  579:inline typename dtl::disable_if_memtransfer_copy_constructible<I, F, I>::type
        -:  580:   uninitialized_copy_alloc_n_source(Allocator &a, I f, std::size_t n, F r)
        -:  581:{
        -:  582:   F back = r;
        -:  583:   BOOST_CONTAINER_TRY{
        -:  584:      while (n) {
        -:  585:         boost::container::construct_in_place(a, boost::movelib::iterator_to_raw_pointer(r), f);
        -:  586:         ++f; ++r; --n;
        -:  587:      }
        -:  588:   }
        -:  589:   BOOST_CONTAINER_CATCH(...){
        -:  590:      for (; back != r; ++back){
        -:  591:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  592:      }
        -:  593:      BOOST_CONTAINER_RETHROW;
        -:  594:   }
        -:  595:   BOOST_CONTAINER_CATCH_END
        -:  596:   return f;
        -:  597:}
        -:  598:
        -:  599:template
        -:  600:   <typename Allocator,
        -:  601:    typename I, // I models InputIterator
        -:  602:    typename F> // F models ForwardIterator
        -:  603:inline typename dtl::enable_if_memtransfer_copy_constructible<I, F, I>::type
        -:  604:   uninitialized_copy_alloc_n_source(Allocator &, I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  605:{  return dtl::memmove_n_source(f, n, r); }
        -:  606:
        -:  607://////////////////////////////////////////////////////////////////////////////
        -:  608://
        -:  609://                               uninitialized_value_init_alloc_n
        -:  610://
        -:  611://////////////////////////////////////////////////////////////////////////////
        -:  612:
        -:  613://! <b>Effects</b>:
        -:  614://!   \code
        -:  615://!   for (; n--; ++r, ++f)
        -:  616://!      allocator_traits::construct(a, &*r);
        -:  617://!   \endcode
        -:  618://!
        -:  619://! <b>Returns</b>: r
        -:  620:template
        -:  621:   <typename Allocator,
        -:  622:    typename F> // F models ForwardIterator
        -:  623:inline typename dtl::disable_if_memzero_initializable<F, F>::type
        -:  624:   uninitialized_value_init_alloc_n(Allocator &a, std::size_t n, F r)
        -:  625:{
        -:  626:   F back = r;
        -:  627:   BOOST_CONTAINER_TRY{
        -:  628:      while (n) {
        -:  629:         --n;
        -:  630:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r));
        -:  631:         ++r;
        -:  632:      }
        -:  633:   }
        -:  634:   BOOST_CONTAINER_CATCH(...){
        -:  635:      for (; back != r; ++back){
        -:  636:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  637:      }
        -:  638:      BOOST_CONTAINER_RETHROW;
        -:  639:   }
        -:  640:   BOOST_CONTAINER_CATCH_END
        -:  641:   return r;
        -:  642:}
        -:  643:
        -:  644:template
        -:  645:   <typename Allocator,
        -:  646:    typename F> // F models ForwardIterator
        -:  647:inline typename dtl::enable_if_memzero_initializable<F, F>::type
        -:  648:   uninitialized_value_init_alloc_n(Allocator &, std::size_t n, F r)
        -:  649:{
        -:  650:   typedef typename boost::container::iterator_traits<F>::value_type value_type;
        -:  651:   typedef typename boost::container::iterator_traits<F>::difference_type r_difference_type;
        -:  652:
        -:  653:   if (BOOST_LIKELY(n != 0)){
        -:  654:      std::memset((void*)boost::movelib::iterator_to_raw_pointer(r), 0, sizeof(value_type)*n);
        -:  655:      r += static_cast<r_difference_type>(n);
        -:  656:   }
        -:  657:   return r;
        -:  658:}
        -:  659:
        -:  660://////////////////////////////////////////////////////////////////////////////
        -:  661://
        -:  662://                               uninitialized_default_init_alloc_n
        -:  663://
        -:  664://////////////////////////////////////////////////////////////////////////////
        -:  665:
        -:  666://! <b>Effects</b>:
        -:  667://!   \code
        -:  668://!   for (; n--; ++r, ++f)
        -:  669://!      allocator_traits::construct(a, &*r);
        -:  670://!   \endcode
        -:  671://!
        -:  672://! <b>Returns</b>: r
        -:  673:template
        -:  674:   <typename Allocator,
        -:  675:    typename F> // F models ForwardIterator
        -:  676:inline F uninitialized_default_init_alloc_n(Allocator &a, std::size_t n, F r)
        -:  677:{
        -:  678:   F back = r;
        -:  679:   BOOST_CONTAINER_TRY{
        -:  680:      while (n) {
        -:  681:         --n;
        -:  682:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r), default_init);
        -:  683:         ++r;
        -:  684:      }
        -:  685:   }
        -:  686:   BOOST_CONTAINER_CATCH(...){
        -:  687:      for (; back != r; ++back){
        -:  688:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  689:      }
        -:  690:      BOOST_CONTAINER_RETHROW;
        -:  691:   }
        -:  692:   BOOST_CONTAINER_CATCH_END
        -:  693:   return r;
        -:  694:}
        -:  695:
        -:  696://////////////////////////////////////////////////////////////////////////////
        -:  697://
        -:  698://                               uninitialized_fill_alloc
        -:  699://
        -:  700://////////////////////////////////////////////////////////////////////////////
        -:  701:
        -:  702://! <b>Effects</b>:
        -:  703://!   \code
        -:  704://!   for (; f != l; ++r, ++f)
        -:  705://!      allocator_traits::construct(a, &*r, *f);
        -:  706://!   \endcode
        -:  707://!
        -:  708://! <b>Returns</b>: r
        -:  709:template
        -:  710:   <typename Allocator,
        -:  711:    typename F, // F models ForwardIterator
        -:  712:    typename T>
        -:  713:inline void uninitialized_fill_alloc(Allocator &a, F f, F l, const T &t)
        -:  714:{
        -:  715:   F back = f;
        -:  716:   BOOST_CONTAINER_TRY{
        -:  717:      while (f != l) {
        -:  718:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(f), t);
        -:  719:         ++f;
        -:  720:      }
        -:  721:   }
        -:  722:   BOOST_CONTAINER_CATCH(...){
        -:  723:      for (; back != l; ++back){
        -:  724:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  725:      }
        -:  726:      BOOST_CONTAINER_RETHROW;
        -:  727:   }
        -:  728:   BOOST_CONTAINER_CATCH_END
        -:  729:}
        -:  730:
        -:  731:
        -:  732://////////////////////////////////////////////////////////////////////////////
        -:  733://
        -:  734://                               uninitialized_fill_alloc_n
        -:  735://
        -:  736://////////////////////////////////////////////////////////////////////////////
        -:  737:
        -:  738://! <b>Effects</b>:
        -:  739://!   \code
        -:  740://!   for (; n--; ++r, ++f)
        -:  741://!      allocator_traits::construct(a, &*r, v);
        -:  742://!   \endcode
        -:  743://!
        -:  744://! <b>Returns</b>: r
        -:  745:template
        -:  746:   <typename Allocator,
        -:  747:    typename T,
        -:  748:    typename F> // F models ForwardIterator
        -:  749:inline F uninitialized_fill_alloc_n(Allocator &a, const T &v, std::size_t n, F r)
        -:  750:{
        -:  751:   F back = r;
        -:  752:   BOOST_CONTAINER_TRY{
        -:  753:      while (n) {
        -:  754:         --n;
        -:  755:         allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(r), v);
        -:  756:         ++r;
        -:  757:      }
        -:  758:   }
        -:  759:   BOOST_CONTAINER_CATCH(...){
        -:  760:      for (; back != r; ++back){
        -:  761:         allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(back));
        -:  762:      }
        -:  763:      BOOST_CONTAINER_RETHROW;
        -:  764:   }
        -:  765:   BOOST_CONTAINER_CATCH_END
        -:  766:   return r;
        -:  767:}
        -:  768:
        -:  769://////////////////////////////////////////////////////////////////////////////
        -:  770://
        -:  771://                               copy
        -:  772://
        -:  773://////////////////////////////////////////////////////////////////////////////
        -:  774:
        -:  775:template
        -:  776:<typename I,   // I models InputIterator
        -:  777:typename F>    // F models ForwardIterator
        -:  778:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  779:   copy(I f, I l, F r)
        -:  780:{
        -:  781:   while (f != l) {
        -:  782:      *r = *f;
        -:  783:      ++f; ++r;
        -:  784:   }
        -:  785:   return r;
        -:  786:}
        -:  787:
        -:  788:template
        -:  789:<typename I,   // I models InputIterator
        -:  790:typename F>    // F models ForwardIterator
        -:  791:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  792:   copy(I f, I l, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  793:{  return dtl::memmove(f, l, r); }
        -:  794:
        -:  795://////////////////////////////////////////////////////////////////////////////
        -:  796://
        -:  797://                               copy_n
        -:  798://
        -:  799://////////////////////////////////////////////////////////////////////////////
        -:  800:
        -:  801:template
        -:  802:<typename I,   // I models InputIterator
        -:  803:typename U,   // U models unsigned integral constant
        -:  804:typename F>   // F models ForwardIterator
        -:  805:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  806:   copy_n(I f, U n, F r)
        -:  807:{
        -:  808:   while (n) {
        -:  809:      --n;
        -:  810:      *r = *f;
        -:  811:      ++f; ++r;
        -:  812:   }
        -:  813:   return r;
        -:  814:}
        -:  815:
        -:  816:template
        -:  817:<typename I,   // I models InputIterator
        -:  818:typename U,   // U models unsigned integral constant
        -:  819:typename F>   // F models ForwardIterator
        -:  820:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  821:   copy_n(I f, U n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  822:{  return dtl::memmove_n(f, n, r); }
        -:  823:
        -:  824://////////////////////////////////////////////////////////////////////////////
        -:  825://
        -:  826://                            copy_n_source
        -:  827://
        -:  828://////////////////////////////////////////////////////////////////////////////
        -:  829:
        -:  830:template
        -:  831:<typename I,   // I models InputIterator
        -:  832:typename U,   // U models unsigned integral constant
        -:  833:typename F>   // F models ForwardIterator
        -:  834:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, I>::type
        -:  835:   copy_n_source(I f, U n, F r)
        -:  836:{
        -:  837:   while (n) {
        -:  838:      --n;
        -:  839:      boost::container::assign_in_place(r, f);
        -:  840:      ++f; ++r;
        -:  841:   }
        -:  842:   return f;
        -:  843:}
        -:  844:
        -:  845:template
        -:  846:<typename I,   // I models InputIterator
        -:  847:typename F>   // F models ForwardIterator
        -:  848:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, I>::type
        -:  849:   copy_n_source(I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  850:{  return dtl::memmove_n_source(f, n, r); }
        -:  851:
        -:  852://////////////////////////////////////////////////////////////////////////////
        -:  853://
        -:  854://                            copy_n_source_dest
        -:  855://
        -:  856://////////////////////////////////////////////////////////////////////////////
        -:  857:
        -:  858:template
        -:  859:<typename I,   // I models InputIterator
        -:  860:typename F>   // F models ForwardIterator
        -:  861:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, I>::type
        -:  862:   copy_n_source_dest(I f, std::size_t n, F &r)
        -:  863:{
        -:  864:   while (n) {
        -:  865:      --n;
        -:  866:      *r = *f;
        -:  867:      ++f; ++r;
        -:  868:   }
        -:  869:   return f;
        -:  870:}
        -:  871:
        -:  872:template
        -:  873:<typename I,   // I models InputIterator
        -:  874:typename F>   // F models ForwardIterator
        -:  875:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, I>::type
        -:  876:   copy_n_source_dest(I f, std::size_t n, F &r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  877:{  return dtl::memmove_n_source_dest(f, n, r);  }
        -:  878:
        -:  879://////////////////////////////////////////////////////////////////////////////
        -:  880://
        -:  881://                         move
        -:  882://
        -:  883://////////////////////////////////////////////////////////////////////////////
        -:  884:
        -:  885:template
        -:  886:<typename I,   // I models InputIterator
        -:  887:typename F>   // F models ForwardIterator
        -:  888:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  889:   move(I f, I l, F r)
        -:  890:{
        -:  891:   while (f != l) {
        -:  892:      *r = ::boost::move(*f);
        -:  893:      ++f; ++r;
        -:  894:   }
        -:  895:   return r;
        -:  896:}
        -:  897:
        -:  898:template
        -:  899:<typename I,   // I models InputIterator
        -:  900:typename F>   // F models ForwardIterator
        -:  901:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  902:   move(I f, I l, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  903:{  return dtl::memmove(f, l, r); }
        -:  904:
        -:  905://////////////////////////////////////////////////////////////////////////////
        -:  906://
        -:  907://                         move_n
        -:  908://
        -:  909://////////////////////////////////////////////////////////////////////////////
        -:  910:
        -:  911:template
        -:  912:<typename I,   // I models InputIterator
        -:  913:typename U,   // U models unsigned integral constant
        -:  914:typename F>   // F models ForwardIterator
        -:  915:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  916:   move_n(I f, U n, F r)
        -:  917:{
        -:  918:   while (n) {
        -:  919:      --n;
        -:  920:      *r = ::boost::move(*f);
        -:  921:      ++f; ++r;
        -:  922:   }
        -:  923:   return r;
        -:  924:}
        -:  925:
        -:  926:template
        -:  927:<typename I,   // I models InputIterator
        -:  928:typename U,   // U models unsigned integral constant
        -:  929:typename F>   // F models ForwardIterator
        -:  930:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  931:   move_n(I f, U n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  932:{  return dtl::memmove_n(f, n, r); }
        -:  933:
        -:  934:
        -:  935://////////////////////////////////////////////////////////////////////////////
        -:  936://
        -:  937://                         move_backward
        -:  938://
        -:  939://////////////////////////////////////////////////////////////////////////////
        -:  940:
        -:  941:template
        -:  942:<typename I,   // I models BidirectionalIterator
        -:  943:typename F>    // F models ForwardIterator
        -:  944:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, F>::type
function _ZN5boost9container13move_backwardIPNS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEESG_EENS2_38disable_if_memtransfer_copy_assignableIT_T0_SJ_E4typeESI_SI_SJ_ called 0 returned 0% blocks executed 0%
    #####:  945:   move_backward(I f, I l, F r)
        -:  946:{
    #####:  947:   while (f != l) {
    $$$$$:  947-block  0
    $$$$$:  947-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  947-block  2
    #####:  948:      --l; --r;
    #####:  949:      *r = ::boost::move(*l);
        -:  950:   }
    #####:  951:   return r;
    $$$$$:  951-block  0
        -:  952:}
        -:  953:
        -:  954:template
        -:  955:<typename I,   // I models InputIterator
        -:  956:typename F>   // F models ForwardIterator
        -:  957:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, F>::type
        -:  958:   move_backward(I f, I l, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  959:{
        -:  960:   typedef typename boost::container::iter_value<I>::type value_type;
        -:  961:   const std::size_t n = boost::container::iterator_udistance(f, l);
        -:  962:   if (BOOST_LIKELY(n != 0)){
        -:  963:      r -= n;
        -:  964:      std::memmove((boost::movelib::iterator_to_raw_pointer)(r), (boost::movelib::iterator_to_raw_pointer)(f), sizeof(value_type)*n);
        -:  965:   }
        -:  966:   return r;
        -:  967:}
        -:  968:
        -:  969://////////////////////////////////////////////////////////////////////////////
        -:  970://
        -:  971://                         move_n_source_dest
        -:  972://
        -:  973://////////////////////////////////////////////////////////////////////////////
        -:  974:
        -:  975:template
        -:  976:<typename I    // I models InputIterator
        -:  977:,typename U    // U models unsigned integral constant
        -:  978:,typename F>   // F models ForwardIterator
        -:  979:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, I>::type
        -:  980:   move_n_source_dest(I f, U n, F &r)
        -:  981:{
        -:  982:   while (n) {
        -:  983:      --n;
        -:  984:      *r = ::boost::move(*f);
        -:  985:      ++f; ++r;
        -:  986:   }
        -:  987:   return f;
        -:  988:}
        -:  989:
        -:  990:template
        -:  991:<typename I    // I models InputIterator
        -:  992:,typename F>   // F models ForwardIterator
        -:  993:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, I>::type
        -:  994:   move_n_source_dest(I f, std::size_t n, F &r) BOOST_NOEXCEPT_OR_NOTHROW
        -:  995:{  return dtl::memmove_n_source_dest(f, n, r); }
        -:  996:
        -:  997://////////////////////////////////////////////////////////////////////////////
        -:  998://
        -:  999://                         move_n_source
        -: 1000://
        -: 1001://////////////////////////////////////////////////////////////////////////////
        -: 1002:
        -: 1003:template
        -: 1004:<typename I    // I models InputIterator
        -: 1005:,typename U    // U models unsigned integral constant
        -: 1006:,typename F>   // F models ForwardIterator
        -: 1007:inline typename dtl::disable_if_memtransfer_copy_assignable<I, F, I>::type
        -: 1008:   move_n_source(I f, U n, F r)
        -: 1009:{
        -: 1010:   while (n) {
        -: 1011:      --n;
        -: 1012:      *r = ::boost::move(*f);
        -: 1013:      ++f; ++r;
        -: 1014:   }
        -: 1015:   return f;
        -: 1016:}
        -: 1017:
        -: 1018:template
        -: 1019:<typename I    // I models InputIterator
        -: 1020:,typename F>   // F models ForwardIterator
        -: 1021:inline typename dtl::enable_if_memtransfer_copy_assignable<I, F, I>::type
        -: 1022:   move_n_source(I f, std::size_t n, F r) BOOST_NOEXCEPT_OR_NOTHROW
        -: 1023:{  return dtl::memmove_n_source(f, n, r); }
        -: 1024:
        -: 1025:template<typename F>   // F models ForwardIterator
        -: 1026:inline F move_forward_overlapping(F f, F l, F r)
        -: 1027:{
        -: 1028:   return (f != r) ? (move)(f, l, r) : l;
        -: 1029:}
        -: 1030:
        -: 1031:template<typename B>   // B models BidirIterator
        -: 1032:inline B move_backward_overlapping(B f, B l, B rl)
        -: 1033:{
        -: 1034:   return (l != rl) ? (move_backward)(f, l, rl) : f;
        -: 1035:}
        -: 1036:
        -: 1037:
        -: 1038://////////////////////////////////////////////////////////////////////////////
        -: 1039://
        -: 1040://                               destroy_alloc_n
        -: 1041://
        -: 1042://////////////////////////////////////////////////////////////////////////////
        -: 1043:
        -: 1044:template
        -: 1045:   <typename Allocator
        -: 1046:   ,typename I   // I models InputIterator
        -: 1047:   ,typename U>  // U models unsigned integral constant
        -: 1048:inline typename dtl::disable_if_trivially_destructible<I, void>::type
function _ZN5boost9container15destroy_alloc_nINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEPSG_mEENS3_33disable_if_trivially_destructibleIT0_vE4typeERT_SK_T1_ called 5 returned 100% blocks executed 75%
        5: 1049:   destroy_alloc_n(Allocator &a, I f, U n)
        -: 1050:{
        5: 1051:   while(n){
        5: 1051-block  0
        5: 1051-block  1
branch  0 taken 0
branch  1 taken 5
    $$$$$: 1051-block  2
    #####: 1052:      --n;
    #####: 1053:      allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(f));
    #####: 1054:      ++f;
        -: 1055:   }
        5: 1056:}
        5: 1056-block  0
        -: 1057:
        -: 1058:template
        -: 1059:   <typename Allocator
        -: 1060:   ,typename I   // I models InputIterator
        -: 1061:   ,typename U>  // U models unsigned integral constant
        -: 1062:inline typename dtl::enable_if_trivially_destructible<I, void>::type
        -: 1063:   destroy_alloc_n(Allocator &, I, U)
        -: 1064:{}
        -: 1065:
        -: 1066://////////////////////////////////////////////////////////////////////////////
        -: 1067://
        -: 1068://                               destroy_alloc
        -: 1069://
        -: 1070://////////////////////////////////////////////////////////////////////////////
        -: 1071:
        -: 1072:template
        -: 1073:   <typename Allocator
        -: 1074:   ,typename I>   // I models InputIterator
        -: 1075:inline typename dtl::disable_if_trivially_destructible<I, void>::type
        -: 1076:   destroy_alloc(Allocator &a, I f, I l)
        -: 1077:{
        -: 1078:   while(f != l){
        -: 1079:      allocator_traits<Allocator>::destroy(a, boost::movelib::iterator_to_raw_pointer(f));
        -: 1080:      ++f;
        -: 1081:   }
        -: 1082:}
        -: 1083:
        -: 1084:template
        -: 1085:   <typename Allocator
        -: 1086:   ,typename I >  // I models InputIterator
        -: 1087:inline typename dtl::enable_if_trivially_destructible<I, void>::type
        -: 1088:   destroy_alloc(Allocator &, I, I)
        -: 1089:{}
        -: 1090:
        -: 1091://////////////////////////////////////////////////////////////////////////////
        -: 1092://
        -: 1093://                         deep_swap_alloc_n
        -: 1094://
        -: 1095://////////////////////////////////////////////////////////////////////////////
        -: 1096:
        -: 1097:template
        -: 1098:   <std::size_t MaxTmpBytes
        -: 1099:   ,typename Allocator
        -: 1100:   ,typename F // F models ForwardIterator
        -: 1101:   ,typename G // G models ForwardIterator
        -: 1102:   >
        -: 1103:inline typename dtl::disable_if_memtransfer_copy_assignable<F, G, void>::type
        -: 1104:   deep_swap_alloc_n( Allocator &a, F short_range_f, std::size_t  n_i, G large_range_f, std::size_t n_j)
        -: 1105:{
        -: 1106:   std::size_t n = 0;
        -: 1107:   for (; n != n_i ; ++short_range_f, ++large_range_f, ++n){
        -: 1108:      boost::adl_move_swap(*short_range_f, *large_range_f);
        -: 1109:   }
        -: 1110:   boost::container::uninitialized_move_alloc_n(a, large_range_f, std::size_t(n_j - n_i), short_range_f);  // may throw
        -: 1111:   boost::container::destroy_alloc_n(a, large_range_f, std::size_t(n_j - n_i));
        -: 1112:}
        -: 1113:
        -: 1114:static const std::size_t DeepSwapAllocNMaxStorage = std::size_t(1) << std::size_t(11); //2K bytes
        -: 1115:
        -: 1116:template
        -: 1117:   <std::size_t MaxTmpBytes
        -: 1118:   ,typename Allocator
        -: 1119:   ,typename F // F models ForwardIterator
        -: 1120:   ,typename G // G models ForwardIterator
        -: 1121:   >
        -: 1122:inline typename dtl::enable_if_c
        -: 1123:   < dtl::is_memtransfer_copy_assignable<F, G>::value && (MaxTmpBytes <= DeepSwapAllocNMaxStorage) && false
        -: 1124:   , void>::type
        -: 1125:   deep_swap_alloc_n( Allocator &a, F short_range_f, std::size_t n_i, G large_range_f, std::size_t n_j)
        -: 1126:{
        -: 1127:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -: 1128:   typedef typename dtl::aligned_storage
        -: 1129:      <MaxTmpBytes, dtl::alignment_of<value_type>::value>::type storage_type;
        -: 1130:   storage_type storage;
        -: 1131:
        -: 1132:   const std::size_t n_i_bytes = sizeof(value_type)*n_i;
        -: 1133:   void *const large_ptr = static_cast<void*>(boost::movelib::iterator_to_raw_pointer(large_range_f));
        -: 1134:   void *const short_ptr = static_cast<void*>(boost::movelib::iterator_to_raw_pointer(short_range_f));
        -: 1135:   void *const stora_ptr = static_cast<void*>(boost::movelib::iterator_to_raw_pointer(storage.data));
        -: 1136:   std::memcpy(stora_ptr, large_ptr, n_i_bytes);
        -: 1137:   std::memcpy(large_ptr, short_ptr, n_i_bytes);
        -: 1138:   std::memcpy(short_ptr, stora_ptr, n_i_bytes);
        -: 1139:   boost::container::iterator_uadvance(large_range_f, n_i);
        -: 1140:   boost::container::iterator_uadvance(short_range_f, n_i);
        -: 1141:   boost::container::uninitialized_move_alloc_n(a, large_range_f, std::size_t(n_j - n_i), short_range_f);  // may throw
        -: 1142:   boost::container::destroy_alloc_n(a, large_range_f, std::size_t(n_j - n_i));
        -: 1143:}
        -: 1144:
        -: 1145:template
        -: 1146:   <std::size_t MaxTmpBytes
        -: 1147:   ,typename Allocator
        -: 1148:   ,typename F // F models ForwardIterator
        -: 1149:   ,typename G // G models ForwardIterator
        -: 1150:   >
        -: 1151:inline typename dtl::enable_if_c
        -: 1152:   < dtl::is_memtransfer_copy_assignable<F, G>::value && true//(MaxTmpBytes > DeepSwapAllocNMaxStorage)
        -: 1153:   , void>::type
        -: 1154:   deep_swap_alloc_n( Allocator &a, F short_range_f, std::size_t n_i, G large_range_f, std::size_t n_j)
        -: 1155:{
        -: 1156:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -: 1157:   typedef typename dtl::aligned_storage
        -: 1158:      <DeepSwapAllocNMaxStorage, dtl::alignment_of<value_type>::value>::type storage_type;
        -: 1159:   storage_type storage;
        -: 1160:   const std::size_t sizeof_storage = sizeof(storage);
        -: 1161:
        -: 1162:   std::size_t n_i_bytes = sizeof(value_type)*n_i;
        -: 1163:   char *large_ptr = static_cast<char*>(static_cast<void*>(boost::movelib::iterator_to_raw_pointer(large_range_f)));
        -: 1164:   char *short_ptr = static_cast<char*>(static_cast<void*>(boost::movelib::iterator_to_raw_pointer(short_range_f)));
        -: 1165:   char *stora_ptr = static_cast<char*>(static_cast<void*>(storage.data));
        -: 1166:
        -: 1167:   std::size_t szt_times = n_i_bytes/sizeof_storage;
        -: 1168:   const std::size_t szt_rem = n_i_bytes%sizeof_storage;
        -: 1169:
        -: 1170:   //Loop unrolling using Duff's device, as it seems it helps on some architectures
        -: 1171:   const std::size_t Unroll = 4;
        -: 1172:   std::size_t n = (szt_times + (Unroll-1))/Unroll;
        -: 1173:   const std::size_t branch_number = (szt_times == 0)*Unroll + (szt_times % Unroll);
        -: 1174:   switch(branch_number){
        -: 1175:      case 4:
        -: 1176:         break;
        -: 1177:      case 0: do{
        -: 1178:         std::memcpy(stora_ptr, large_ptr, sizeof_storage);
        -: 1179:         std::memcpy(large_ptr, short_ptr, sizeof_storage);
        -: 1180:         std::memcpy(short_ptr, stora_ptr, sizeof_storage);
        -: 1181:         large_ptr += sizeof_storage;
        -: 1182:         short_ptr += sizeof_storage;
        -: 1183:         BOOST_FALLTHROUGH;
        -: 1184:      case 3:
        -: 1185:         std::memcpy(stora_ptr, large_ptr, sizeof_storage);
        -: 1186:         std::memcpy(large_ptr, short_ptr, sizeof_storage);
        -: 1187:         std::memcpy(short_ptr, stora_ptr, sizeof_storage);
        -: 1188:         large_ptr += sizeof_storage;
        -: 1189:         short_ptr += sizeof_storage;
        -: 1190:         BOOST_FALLTHROUGH;
        -: 1191:      case 2:
        -: 1192:         std::memcpy(stora_ptr, large_ptr, sizeof_storage);
        -: 1193:         std::memcpy(large_ptr, short_ptr, sizeof_storage);
        -: 1194:         std::memcpy(short_ptr, stora_ptr, sizeof_storage);
        -: 1195:         large_ptr += sizeof_storage;
        -: 1196:         short_ptr += sizeof_storage;
        -: 1197:         BOOST_FALLTHROUGH;
        -: 1198:      case 1:
        -: 1199:         std::memcpy(stora_ptr, large_ptr, sizeof_storage);
        -: 1200:         std::memcpy(large_ptr, short_ptr, sizeof_storage);
        -: 1201:         std::memcpy(short_ptr, stora_ptr, sizeof_storage);
        -: 1202:         large_ptr += sizeof_storage;
        -: 1203:         short_ptr += sizeof_storage;
        -: 1204:         } while(--n);
        -: 1205:   }
        -: 1206:   std::memcpy(stora_ptr, large_ptr, szt_rem);
        -: 1207:   std::memcpy(large_ptr, short_ptr, szt_rem);
        -: 1208:   std::memcpy(short_ptr, stora_ptr, szt_rem);
        -: 1209:   boost::container::iterator_uadvance(large_range_f, n_i);
        -: 1210:   boost::container::iterator_uadvance(short_range_f, n_i);
        -: 1211:   boost::container::uninitialized_move_alloc_n(a, large_range_f, std::size_t(n_j - n_i), short_range_f);  // may throw
        -: 1212:   boost::container::destroy_alloc_n(a, large_range_f, std::size_t(n_j - n_i));
        -: 1213:}
        -: 1214:
        -: 1215:
        -: 1216://////////////////////////////////////////////////////////////////////////////
        -: 1217://
        -: 1218://                         copy_assign_range_alloc_n
        -: 1219://
        -: 1220://////////////////////////////////////////////////////////////////////////////
        -: 1221:
        -: 1222:template
        -: 1223:   <typename Allocator
        -: 1224:   ,typename I // F models InputIterator
        -: 1225:   ,typename O // G models OutputIterator
        -: 1226:   >
        -: 1227:void copy_assign_range_alloc_n( Allocator &a, I inp_start, std::size_t n_i, O out_start, std::size_t n_o )
        -: 1228:{
        -: 1229:   if (n_o < n_i){
        -: 1230:      inp_start = boost::container::copy_n_source_dest(inp_start, n_o, out_start);     // may throw
        -: 1231:      boost::container::uninitialized_copy_alloc_n(a, inp_start, std::size_t(n_i - n_o), out_start);// may throw
        -: 1232:   }
        -: 1233:   else{
        -: 1234:      out_start = boost::container::copy_n(inp_start, n_i, out_start);  // may throw
        -: 1235:      boost::container::destroy_alloc_n(a, out_start, std::size_t(n_o - n_i));
        -: 1236:   }
        -: 1237:}
        -: 1238:
        -: 1239://////////////////////////////////////////////////////////////////////////////
        -: 1240://
        -: 1241://                         move_assign_range_alloc_n
        -: 1242://
        -: 1243://////////////////////////////////////////////////////////////////////////////
        -: 1244:
        -: 1245:template
        -: 1246:   <typename Allocator
        -: 1247:   ,typename I // F models InputIterator
        -: 1248:   ,typename O // G models OutputIterator
        -: 1249:   >
        -: 1250:void move_assign_range_alloc_n( Allocator &a, I inp_start, std::size_t n_i, O out_start, std::size_t n_o )
        -: 1251:{
        -: 1252:   if (n_o < n_i){
        -: 1253:      inp_start = boost::container::move_n_source_dest(inp_start, n_o, out_start);  // may throw
        -: 1254:      boost::container::uninitialized_move_alloc_n(a, inp_start, std::size_t(n_i - n_o), out_start);  // may throw
        -: 1255:   }
        -: 1256:   else{
        -: 1257:      out_start = boost::container::move_n(inp_start, n_i, out_start);  // may throw
        -: 1258:      boost::container::destroy_alloc_n(a, out_start, std::size_t(n_o - n_i));
        -: 1259:   }
        -: 1260:}
        -: 1261:
        -: 1262:template<class Allocator>
        -: 1263:struct array_destructor
        -: 1264:{
        -: 1265:   typedef typename ::boost::container::allocator_traits<Allocator>::value_type value_type;
        -: 1266:   typedef typename dtl::if_c
        -: 1267:      <dtl::is_trivially_destructible<value_type>::value
        -: 1268:      ,dtl::null_scoped_destructor_range<Allocator>
        -: 1269:      ,dtl::scoped_destructor_range<Allocator>
        -: 1270:      >::type type;
        -: 1271:};
        -: 1272:
        -: 1273:template<class Allocator>
        -: 1274:struct value_destructor
        -: 1275:{
        -: 1276:   typedef typename ::boost::container::allocator_traits<Allocator>::value_type value_type;
        -: 1277:   typedef typename dtl::if_c
        -: 1278:      <dtl::is_trivially_destructible<value_type>::value
        -: 1279:      , dtl::null_scoped_destructor<Allocator>
        -: 1280:      , dtl::scoped_destructor<Allocator>
        -: 1281:      >::type type;
        -: 1282:};
        -: 1283:
        -: 1284:template
        -: 1285:   <typename Allocator
        -: 1286:   ,typename F // F models ForwardIterator
        -: 1287:   ,typename O // G models OutputIterator
        -: 1288:   ,typename InsertionProxy
        -: 1289:   >
function _ZN5boost9container35uninitialized_move_and_insert_allocINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEPSG_SI_NS3_20insert_emplace_proxyISH_JSG_EEEEEvRT_T0_SN_SN_T1_mT2_ called 0 returned 0% blocks executed 0%
    #####: 1290:void uninitialized_move_and_insert_alloc
        -: 1291:   ( Allocator &a
        -: 1292:   , F first
        -: 1293:   , F pos
        -: 1294:   , F last
        -: 1295:   , O d_first
        -: 1296:   , std::size_t n
        -: 1297:   , InsertionProxy insertion_proxy)
        -: 1298:{
        -: 1299:   typedef typename array_destructor<Allocator>::type array_destructor_t;
        -: 1300:
        -: 1301:   //Anti-exception rollbacks
    #####: 1302:   array_destructor_t new_values_destroyer(d_first, d_first, a);
        -: 1303:
        -: 1304:   //Initialize with [begin(), pos) old buffer
        -: 1305:   //the start of the new buffer
    #####: 1306:   O d_last = ::boost::container::uninitialized_move_alloc(a, first, pos, d_first);
    $$$$$: 1306-block  0
branch  0 never executed
branch  1 never executed
    #####: 1307:   new_values_destroyer.set_end(d_last);
    $$$$$: 1307-block  0
branch  0 never executed
branch  1 never executed
        -: 1308:   //Initialize new objects, starting from previous point
    #####: 1309:   insertion_proxy.uninitialized_copy_n_and_update(a, d_last, n);
    $$$$$: 1309-block  0
branch  0 never executed
branch  1 never executed
    #####: 1310:   d_last += n;
    #####: 1311:   new_values_destroyer.set_end(d_last);
    $$$$$: 1311-block  0
branch  0 never executed
branch  1 never executed
        -: 1312:   //Initialize from the rest of the old buffer,
        -: 1313:   //starting from previous point
    #####: 1314:   (void) ::boost::container::uninitialized_move_alloc(a, pos, last, d_last);
    $$$$$: 1314-block  0
branch  0 never executed
branch  1 never executed
        -: 1315:   //All construction successful, disable rollbacks
    #####: 1316:   new_values_destroyer.release();
    $$$$$: 1316-block  0
branch  0 never executed
branch  1 never executed
    #####: 1317:}
    $$$$$: 1317-block  0
    $$$$$: 1317-block  1
    $$$$$: 1317-block  2
        -: 1318:
        -: 1319:
        -: 1320:
        -: 1321:
        -: 1322:template
        -: 1323:   <typename Allocator
        -: 1324:   ,typename F // F models ForwardIterator
        -: 1325:   ,typename InsertionProxy
        -: 1326:   >
        -: 1327:typename dtl::enable_if_c<dtl::is_single_value_proxy<InsertionProxy>::value, void>::type
        -: 1328:   expand_backward_and_insert_nonempty_middle_alloc
        -: 1329:   ( Allocator &a
        -: 1330:   , F const first
        -: 1331:   , F const pos
        -: 1332:   , std::size_t const
        -: 1333:   , InsertionProxy insertion_proxy)
        -: 1334:{
        -: 1335:   BOOST_ASSERT(first != pos);
        -: 1336: 
        -: 1337:   typedef typename value_destructor<Allocator>::type value_destructor_t;
        -: 1338:   F aux = first;   --aux;
        -: 1339:   allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(aux), boost::move(*first));
        -: 1340:   value_destructor_t on_exception(a, boost::movelib::iterator_to_raw_pointer(aux));
        -: 1341:   //Copy previous to last objects to the initialized end
        -: 1342:   aux = first; ++aux;
        -: 1343:   aux = boost::container::move(aux, pos, first);
        -: 1344:   //Insert new objects in the pos
        -: 1345:   insertion_proxy.copy_n_and_update(a, aux, 1u);
        -: 1346:   on_exception.release();
        -: 1347:}
        -: 1348:
        -: 1349:template
        -: 1350:   <typename Allocator
        -: 1351:   ,typename F // F models ForwardIterator
        -: 1352:   ,typename InsertionProxy
        -: 1353:   >
        -: 1354:typename dtl::disable_if_c<dtl::is_single_value_proxy<InsertionProxy>::value, void>::type
        -: 1355:   expand_backward_and_insert_nonempty_middle_alloc
        -: 1356:   ( Allocator &a
        -: 1357:   , F first
        -: 1358:   , F pos
        -: 1359:   , std::size_t const n
        -: 1360:   , InsertionProxy insertion_proxy)
        -: 1361:{
        -: 1362:   BOOST_ASSERT(first != pos);
        -: 1363:   BOOST_ASSERT(n != 0);
        -: 1364:
        -: 1365:   typedef typename array_destructor<Allocator>::type array_destructor_t;
        -: 1366:   const std::size_t elems_before = iterator_udistance(first, pos);
        -: 1367:   if(elems_before >= n){
        -: 1368:      //New elements can be just copied.
        -: 1369:      //Move to uninitialized memory last objects
        -: 1370:      F const first_less_n = first - n;
        -: 1371:      F nxt = ::boost::container::uninitialized_move_alloc_n_source(a, first, n, first_less_n);
        -: 1372:      array_destructor_t on_exception(first_less_n, first, a);
        -: 1373:      //Copy previous to last objects to the initialized end
        -: 1374:      nxt = boost::container::move(nxt, pos, first);
        -: 1375:      //Insert new objects in the pos
        -: 1376:      insertion_proxy.copy_n_and_update(a, nxt, n);
        -: 1377:      on_exception.release();
        -: 1378:   }
        -: 1379:   else {
        -: 1380:      //The new elements don't fit in the [pos, end()) range.
        -: 1381:      //Copy old [pos, end()) elements to the uninitialized memory (a gap is created)
        -: 1382:      F aux = ::boost::container::uninitialized_move_alloc(a, first, pos, first - n);
        -: 1383:      array_destructor_t on_exception(first -n, aux, a);
        -: 1384:      //Copy to the beginning of the unallocated zone the last new elements (the gap is closed).
        -: 1385:      insertion_proxy.uninitialized_copy_n_and_update(a, aux, std::size_t(n - elems_before));
        -: 1386:      insertion_proxy.copy_n_and_update(a, first, elems_before);
        -: 1387:      on_exception.release();
        -: 1388:   }
        -: 1389:}
        -: 1390:
        -: 1391:
        -: 1392:template
        -: 1393:   <typename Allocator
        -: 1394:   ,typename F // F models ForwardIterator
        -: 1395:   ,typename InsertionProxy
        -: 1396:   >
        -: 1397:typename dtl::enable_if_c<dtl::is_single_value_proxy<InsertionProxy>::value, void>::type
        -: 1398:   expand_forward_and_insert_nonempty_middle_alloc
        -: 1399:   ( Allocator &a
        -: 1400:   , F pos
        -: 1401:   , F last
        -: 1402:   , std::size_t const
        -: 1403:   , InsertionProxy insertion_proxy)
        -: 1404:{
        -: 1405:   BOOST_ASSERT(last != pos);
        -: 1406: 
        -: 1407:   typedef typename value_destructor<Allocator>::type value_destructor_t;
        -: 1408:   F last_m_n = last;   --last_m_n;
        -: 1409:   allocator_traits<Allocator>::construct(a, boost::movelib::iterator_to_raw_pointer(last), boost::move(*last_m_n));
        -: 1410:   value_destructor_t on_exception(a, boost::movelib::iterator_to_raw_pointer(last));
        -: 1411:   //Copy previous to last objects to the initialized end
        -: 1412:   boost::container::move_backward(pos, last_m_n, last);
        -: 1413:   //Insert new objects in the pos
        -: 1414:   insertion_proxy.copy_n_and_update(a, pos, 1);
        -: 1415:   on_exception.release();
        -: 1416:}
        -: 1417:
        -: 1418:template
        -: 1419:   <typename Allocator
        -: 1420:   ,typename F // F models ForwardIterator
        -: 1421:   ,typename InsertionProxy
        -: 1422:   >
        -: 1423:typename dtl::disable_if_c<dtl::is_single_value_proxy<InsertionProxy>::value, void>::type
        -: 1424:   expand_forward_and_insert_nonempty_middle_alloc
        -: 1425:   ( Allocator &a
        -: 1426:   , F pos
        -: 1427:   , F last
        -: 1428:   , std::size_t const n
        -: 1429:   , InsertionProxy insertion_proxy)
        -: 1430:{
        -: 1431:   BOOST_ASSERT(last != pos);
        -: 1432:   BOOST_ASSERT(n != 0);
        -: 1433:
        -: 1434:   typedef typename array_destructor<Allocator>::type array_destructor_t;
        -: 1435:   const std::size_t elems_after = iterator_udistance(pos, last);
        -: 1436:   if(elems_after >= n){
        -: 1437:      //New elements can be just copied.
        -: 1438:      //Move to uninitialized memory last objects
        -: 1439:      F const last_m_n = last - n;
        -: 1440:      F const nxt = ::boost::container::uninitialized_move_alloc_n(a, last_m_n, n, last);
        -: 1441:      array_destructor_t on_exception(last, nxt, a);
        -: 1442:      //Copy previous to last objects to the initialized end
        -: 1443:      boost::container::move_backward(pos, last_m_n, last);
        -: 1444:      //Insert new objects in the pos
        -: 1445:      insertion_proxy.copy_n_and_update(a, pos, n);
        -: 1446:      on_exception.release();
        -: 1447:   }
        -: 1448:   else {
        -: 1449:      //The new elements don't fit in the [pos, end()) range.
        -: 1450:      //Copy old [pos, end()) elements to the uninitialized memory (a gap is created)
        -: 1451:      F new_last = ::boost::container::uninitialized_move_alloc(a, pos, last, pos + n);
        -: 1452:      array_destructor_t on_exception(pos + n, new_last, a);
        -: 1453:      //Copy first new elements in pos (gap is still there)
        -: 1454:      insertion_proxy.copy_n_and_update(a, pos, elems_after);
        -: 1455:      //Copy to the beginning of the unallocated zone the last new elements (the gap is closed).
        -: 1456:      insertion_proxy.uninitialized_copy_n_and_update(a, last, std::size_t(n - elems_after));
        -: 1457:      on_exception.release();
        -: 1458:   }
        -: 1459:}
        -: 1460:
        -: 1461:template
        -: 1462:<typename Allocator
        -: 1463:   , typename F // F models ForwardIterator
        -: 1464:   , typename InsertionProxy
        -: 1465:>
        -: 1466:inline void expand_forward_and_insert_alloc
        -: 1467:   ( Allocator& a
        -: 1468:   , F pos
        -: 1469:   , F last
        -: 1470:   , std::size_t const n
        -: 1471:   , InsertionProxy insertion_proxy)
        -: 1472:{
        -: 1473:   if (last == pos) {
        -: 1474:      insertion_proxy.uninitialized_copy_n_and_update(a, last, n);
        -: 1475:   }
        -: 1476:   else{
        -: 1477:      const bool single_value = dtl::is_single_value_proxy<InsertionProxy>::value;
        -: 1478:      BOOST_IF_CONSTEXPR(!single_value){
        -: 1479:         if (BOOST_UNLIKELY(!n)) {
        -: 1480:            return;
        -: 1481:         }
        -: 1482:      }
        -: 1483:      expand_forward_and_insert_nonempty_middle_alloc(a, pos, last, n, insertion_proxy);
        -: 1484:   }
        -: 1485:}
        -: 1486:
        -: 1487:template <class B, class InsertionProxy, class Allocator>
        -: 1488:void expand_backward_forward_and_insert_alloc_move_backward
        -: 1489:( B const old_start
        -: 1490:, std::size_t const old_size
        -: 1491:, B const new_start
        -: 1492:, B const pos
        -: 1493:, std::size_t const n
        -: 1494:, InsertionProxy insertion_proxy
        -: 1495:, Allocator& a)
        -: 1496:{
        -: 1497:   typedef std::size_t size_type;
        -: 1498:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -: 1499:   static const bool trivial_dctr_after_move = has_trivial_destructor_after_move<value_type>::value;
        -: 1500:   static const bool trivial_dctr = dtl::is_trivially_destructible<value_type>::value;
        -: 1501:
        -: 1502:   typedef typename dtl::if_c
        -: 1503:      <trivial_dctr
        -: 1504:      , dtl::null_scoped_destructor_n<Allocator, B>
        -: 1505:      , dtl::scoped_destructor_n<Allocator, B>
        -: 1506:      >::type   array_destructor_t;
        -: 1507:
        -: 1508:   //n can be zero to just expand capacity
        -: 1509:   B old_finish = make_iterator_uadvance(old_start, old_size);
        -: 1510:
        -: 1511:   //We can have 8 possibilities:
        -: 1512:   const size_type elemsbefore = static_cast<size_type>(iterator_udistance(old_start, pos));
        -: 1513:   const size_type raw_before  = static_cast<size_type>(iterator_udistance(new_start, old_start));
        -: 1514:   const size_type before_plus_new = size_type(elemsbefore + n);
        -: 1515:
        -: 1516:   //Check if raw_before is big enough to hold the beginning of old data + new data
        -: 1517:   if (raw_before >= before_plus_new) {
        -: 1518:      //If anything goes wrong, this object will destroy
        -: 1519:      //all the old objects to fulfill previous vector state
        -: 1520:      array_destructor_t old_values_destroyer(old_start, a, old_size);
        -: 1521:      // _________________________________________________________
        -: 1522:      //|            raw_mem                | old_begin | old_end |  //Old situation
        -: 1523:      //| __________________________________|___________|_________|
        -: 1524:      // _________________________________________________________
        -: 1525:      //| old_begin |    new   |  raw_mem   | old_begin | old_end |  //First step
        -: 1526:      //|___________|__________|____________|___________|_________|
        -: 1527:
        -: 1528:      //Copy first old values before pos, after that the new objects
        -: 1529:      B const new_elem_pos = ::boost::container::uninitialized_move_alloc(a, old_start, pos, new_start);
        -: 1530:      array_destructor_t new_values_destroyer(new_start, a, elemsbefore);
        -: 1531:      insertion_proxy.uninitialized_copy_n_and_update(a, new_elem_pos, n);
        -: 1532:      new_values_destroyer.set_size(before_plus_new);
        -: 1533:      const size_type new_size = size_type(old_size + n);
        -: 1534:      //Check if raw_before is so big that even copying the old data + new data
        -: 1535:      //there is a gap between the new data and the old data
        -: 1536:      if (raw_before >= new_size) {
        -: 1537:         // _______________________________________________________
        -: 1538:         //|            raw_mem              | old_begin | old_end | //Old situation
        -: 1539:         //|_________________________________|___________|_________|
        -: 1540:         // _______________________________________________________
        -: 1541:         //| old_begin |   new  |  raw_mem   | old_begin | old_end | //First step
        -: 1542:         //|___________|________|____________|___________|_________|
        -: 1543:         // _______________________________________________________
        -: 1544:         //| old_begin |   new  | old_end |       raw_mem          | //New situation
        -: 1545:         //|___________|________|_________|________________________|
        -: 1546:         //
        -: 1547:         //Now initialize the rest of memory with the last old values
        -: 1548:         if (before_plus_new != new_size) { //Special case to avoid operations in back insertion
        -: 1549:            B new_start_end(make_iterator_uadvance(new_start, before_plus_new));
        -: 1550:            ::boost::container::uninitialized_move_alloc(a, pos, old_finish, new_start_end);
        -: 1551:         }
        -: 1552:         //All new elements correctly constructed, avoid new element destruction
        -: 1553:         new_values_destroyer.release();
        -: 1554:         //Old values destroyed automatically with "old_values_destroyer"
        -: 1555:         //when "old_values_destroyer" goes out of scope unless the have trivial
        -: 1556:         //destructor after move.
        -: 1557:         if(trivial_dctr_after_move)
        -: 1558:            old_values_destroyer.release();
        -: 1559:      }
        -: 1560:      //raw_before is so big that divides old_end
        -: 1561:      else {
        -: 1562:         // _________________________________________________
        -: 1563:         //|               raw           | old_beg | old_end | //Old situation
        -: 1564:         //|_____________________________|_________|_________|
        -: 1565:         // _________________________________________________
        -: 1566:         //| old_begin |    new   |  raw | old_beg | old_end | //First step
        -: 1567:         //|___________|__________|______|_________|_________|
        -: 1568:         // _________________________________________________
        -: 1569:         //| old_begin |    new   | old_end |  raw_mem       | //New situation
        -: 1570:         //|___________|__________|_________|________________|
        -: 1571:
        -: 1572:         //Now initialize the rest of memory with the last old values
        -: 1573:         //All new elements correctly constructed, avoid new element destruction
        -: 1574:         BOOST_IF_CONSTEXPR(!trivial_dctr) {
        -: 1575:            //Now initialize the rest of raw_before memory with the
        -: 1576:            //first of elements after new values
        -: 1577:            const size_type raw_gap = raw_before - before_plus_new;
        -: 1578:            B new_start_plus(make_iterator_uadvance(new_start, before_plus_new));
        -: 1579:            ::boost::container::uninitialized_move_alloc_n(a, pos, raw_gap, new_start_plus);
        -: 1580:            new_values_destroyer.release();
        -: 1581:            old_values_destroyer.increment_size_backwards(raw_before);
        -: 1582:            //Now move remaining last objects in the old buffer begin
        -: 1583:            B remaining_pos(make_iterator_uadvance(pos, raw_gap));
        -: 1584:            remaining_pos = ::boost::container::move_forward_overlapping(remaining_pos, old_finish, old_start);
        -: 1585:            (void)remaining_pos;
        -: 1586:            //Once moved, avoid calling the destructors if trivial after move
        -: 1587:            if(!trivial_dctr_after_move) {
        -: 1588:               boost::container::destroy_alloc(a, remaining_pos, old_finish);
        -: 1589:            }
        -: 1590:         }
        -: 1591:         else { //If trivial destructor, we can uninitialized copy + copy in a single uninitialized copy
        -: 1592:            ::boost::container::uninitialized_move_alloc_n
        -: 1593:               (a, pos, static_cast<size_type>(old_finish - pos), make_iterator_uadvance(new_start, before_plus_new));
        -: 1594:         }
        -: 1595:         old_values_destroyer.release();
        -: 1596:      }
        -: 1597:   }
        -: 1598:   else {
        -: 1599:      //If anything goes wrong, this object will destroy
        -: 1600:      //all the old objects to fulfill previous vector state
        -: 1601:      array_destructor_t old_values_destroyer(old_start, a, old_size);
        -: 1602:
        -: 1603:      //Check if we have to do the insertion in two phases
        -: 1604:      //since maybe raw_before is not big enough and
        -: 1605:      //the buffer was expanded both sides
        -: 1606:      // _________________________________________________
        -: 1607:      //| raw_mem | old_begin + old_end |  raw_mem        | //Old situation
        -: 1608:      //|_________|_____________________|_________________|
        -: 1609:      // _________________________________________________
        -: 1610:      //|     old_begin + new + old_end     |  raw_mem    | //New situation with do_after
        -: 1611:      //|___________________________________|_____________|
        -: 1612:      // _________________________________________________
        -: 1613:      //| old_begin + new + old_end  |  raw_mem           | //New without do_after
        -: 1614:      //|____________________________|____________________|
        -: 1615:      //
        -: 1616:      const bool do_after = n > raw_before;
        -: 1617:
        -: 1618:      //Now we can have two situations: the raw_mem of the
        -: 1619:      //beginning divides the old_begin, or the new elements:
        -: 1620:      if (raw_before <= elemsbefore) {
        -: 1621:         //The raw memory divides the old_begin group:
        -: 1622:         //
        -: 1623:         //If we need two phase construction (do_after)
        -: 1624:         //new group is divided in new = new_beg + new_end groups
        -: 1625:         //In this phase only new_beg will be inserted
        -: 1626:         //
        -: 1627:         // _________________________________________________
        -: 1628:         //| raw_mem | old_begin | old_end |  raw_mem        | //Old situation
        -: 1629:         //|_________|___________|_________|_________________|
        -: 1630:         // _________________________________________________
        -: 1631:         //| old_begin | new_beg | old_end |  raw_mem        | //New situation with do_after(1),
        -: 1632:         //|___________|_________|_________|_________________| //not definitive, pending operations
        -: 1633:         // _________________________________________________
        -: 1634:         //| old_begin | new | old_end |  raw_mem            | //New situation without do_after,
        -: 1635:         //|___________|_____|_________|_____________________| //definitive.
        -: 1636:         //
        -: 1637:         //Copy the first part of old_begin to raw_mem
        -: 1638:         ::boost::container::uninitialized_move_alloc_n(a, old_start, raw_before, new_start);
        -: 1639:         //The buffer is all constructed until old_end,
        -: 1640:         //so program trailing destruction and assign final size
        -: 1641:         //if !do_after, raw_before+n otherwise.
        -: 1642:         size_type new_1st_range;
        -: 1643:         old_values_destroyer.increment_size_backwards(raw_before);
        -: 1644:         new_1st_range = do_after ? raw_before : n;
        -: 1645:
        -: 1646:         //Now copy the second part of old_begin overwriting itself
        -: 1647:         B const old_next(make_iterator_uadvance(old_start, raw_before));
        -: 1648:         B const next = ::boost::container::move(old_next, pos, old_start);
        -: 1649:         //Now copy the new_beg elements
        -: 1650:         insertion_proxy.copy_n_and_update(a, next, new_1st_range);
        -: 1651:
        -: 1652:         //If there is no after work and the last old part needs to be moved to front, do it
        -: 1653:         if (!do_after) {
        -: 1654:            //Now displace old_end elements and destroy trailing
        -: 1655:            B const new_first(make_iterator_uadvance(next, new_1st_range));
        -: 1656:            B const p = ::boost::container::move_forward_overlapping(pos, old_finish, new_first);
        -: 1657:            (void)p;
        -: 1658:            if(!trivial_dctr_after_move)
        -: 1659:               boost::container::destroy_alloc(a, p, old_finish);
        -: 1660:         }
        -: 1661:      }
        -: 1662:      else {
        -: 1663:         //If we have to expand both sides,
        -: 1664:         //we will play if the first new values so
        -: 1665:         //calculate the upper bound of new values
        -: 1666:
        -: 1667:         //The raw memory divides the new elements
        -: 1668:         //
        -: 1669:         //If we need two phase construction (do_after)
        -: 1670:         //new group is divided in new = new_beg + new_end groups
        -: 1671:         //In this phase only new_beg will be inserted
        -: 1672:         //
        -: 1673:         // ____________________________________________________
        -: 1674:         //|   raw_mem     | old_begin | old_end |  raw_mem     | //Old situation
        -: 1675:         //|_______________|___________|_________|______________|
        -: 1676:         // ____________________________________________________
        -: 1677:         //| old_begin |    new_beg    | old_end |  raw_mem     | //New situation with do_after(),
        -: 1678:         //|___________|_______________|_________|______________| //not definitive, pending operations
        -: 1679:         // ____________________________________________________
        -: 1680:         //| old_begin | new | old_end |  raw_mem               | //New situation without do_after,
        -: 1681:         //|___________|_____|_________|________________________| //definitive
        -: 1682:         //
        -: 1683:         //First copy whole old_begin and part of new to raw_mem
        -: 1684:         B const new_pos = ::boost::container::uninitialized_move_alloc(a, old_start, pos, new_start);
        -: 1685:         array_destructor_t new_values_destroyer(new_start, a, elemsbefore);
        -: 1686:         const size_type mid_n = size_type(raw_before - elemsbefore);
        -: 1687:         insertion_proxy.uninitialized_copy_n_and_update(a, new_pos, mid_n);
        -: 1688:         new_values_destroyer.release();
        -: 1689:         //The buffer is all constructed until old_end
        -: 1690:         old_values_destroyer.increment_size_backwards(raw_before);
        -: 1691:
        -: 1692:         if (do_after) {
        -: 1693:            //Copy new_beg part
        -: 1694:            insertion_proxy.copy_n_and_update(a, old_start, elemsbefore);
        -: 1695:         }
        -: 1696:         else {
        -: 1697:            //Copy all new elements
        -: 1698:            const size_type rest_new = size_type(n - mid_n);
        -: 1699:            insertion_proxy.copy_n_and_update(a, old_start, rest_new);
        -: 1700:
        -: 1701:            B move_start(make_iterator_uadvance(old_start, rest_new));
        -: 1702:
        -: 1703:            //Displace old_end, but make sure data has to be moved
        -: 1704:            B const move_end = ::boost::container::move_forward_overlapping(pos, old_finish, move_start);
        -: 1705:            (void)move_end;   //To avoid warnings of unused initialization for move_end in case
        -: 1706:                              //trivial_dctr_after_move is true
        -: 1707:            //Destroy remaining moved elements from old_end except if they
        -: 1708:            //have trivial destructor after being moved
        -: 1709:            if(!trivial_dctr_after_move) {
        -: 1710:               boost::container::destroy_alloc(a, move_end, old_finish);
        -: 1711:            }
        -: 1712:         }
        -: 1713:      }
        -: 1714:
        -: 1715:      //This is only executed if two phase construction is needed
        -: 1716:      if (do_after) {
        -: 1717:         //The raw memory divides the new elements
        -: 1718:         // ______________________________________________________
        -: 1719:         //|   raw_mem    | old_begin |  old_end   |  raw_mem     |  //Old situation
        -: 1720:         //|______________|___________|____________|______________|
        -: 1721:         // _______________________________________________________
        -: 1722:         //| old_begin   +   new_beg  | new_end |old_end | rawmem |  //New situation with do_after(1)
        -: 1723:         //|__________________________|_________|________|________|
        -: 1724:         // ______________________________________________________
        -: 1725:         //| old_begin      +       new            | old_end |raw |  //New situation with do_after(2)
        -: 1726:         //|_______________________________________|_________|____|
        -: 1727:         const size_type n_after = size_type(n - raw_before);
        -: 1728:         const size_type elemsafter = size_type(old_size - elemsbefore);
        -: 1729:
        -: 1730:         //We can have two situations:
        -: 1731:         if (elemsafter >= n_after) {
        -: 1732:            //The raw_mem from end will divide displaced old_end
        -: 1733:            //
        -: 1734:            //Old situation:
        -: 1735:            // ______________________________________________________
        -: 1736:            //|   raw_mem    | old_begin |  old_end   |  raw_mem     |
        -: 1737:            //|______________|___________|____________|______________|
        -: 1738:            //
        -: 1739:            //New situation with do_after(1):
        -: 1740:            // _______________________________________________________
        -: 1741:            //| old_begin   +   new_beg  | new_end |old_end | raw_mem |
        -: 1742:            //|__________________________|_________|________|_________|
        -: 1743:            //
        -: 1744:            //First copy the part of old_end raw_mem
        -: 1745:            B finish_n = make_iterator_advance(old_finish, -std::ptrdiff_t(n_after));
        -: 1746:            ::boost::container::uninitialized_move_alloc(a, finish_n, old_finish, old_finish);
        -: 1747:            old_values_destroyer.increment_size(n_after);
        -: 1748:            //Displace the rest of old_end to the new position
        -: 1749:            boost::container::move_backward_overlapping(pos, finish_n, old_finish);
        -: 1750:            //Now overwrite with new_end
        -: 1751:            //The new_end part is [first + (n - n_after), last)
        -: 1752:            insertion_proxy.copy_n_and_update(a, pos, n_after);
        -: 1753:         }
        -: 1754:         else {
        -: 1755:            //The raw_mem from end will divide new_end part
        -: 1756:            // _____________________________________________________________
        -: 1757:            //|   raw_mem    | old_begin |  old_end   |  raw_mem            | //Old situation
        -: 1758:            //|______________|___________|____________|_____________________|
        -: 1759:            // _____________________________________________________________
        -: 1760:            //| old_begin   +   new_beg  |     new_end   |old_end | raw_mem | //New situation with do_after(2)
        -: 1761:            //|__________________________|_______________|________|_________|
        -: 1762:
        -: 1763:            //First initialize data in raw memory
        -: 1764:            const size_type mid_last_dist = size_type(n_after - elemsafter);
        -: 1765:
        -: 1766:            //Copy to the old_end part to the uninitialized zone leaving a gap.
        -: 1767:            B const mid_last(make_iterator_uadvance(old_finish, mid_last_dist));
        -: 1768:            ::boost::container::uninitialized_move_alloc(a, pos, old_finish, mid_last);
        -: 1769:
        -: 1770:            array_destructor_t old_end_destroyer(mid_last, a, iterator_udistance(pos, old_finish));
        -: 1771:
        -: 1772:            //Copy the first part to the already constructed old_end zone
        -: 1773:            insertion_proxy.copy_n_and_update(a, pos, elemsafter);
        -: 1774:            //Copy the rest to the uninitialized zone filling the gap
        -: 1775:            insertion_proxy.uninitialized_copy_n_and_update(a, old_finish, mid_last_dist);
        -: 1776:            old_end_destroyer.release();
        -: 1777:         }
        -: 1778:      }
        -: 1779:      old_values_destroyer.release();
        -: 1780:   }
        -: 1781:}
        -: 1782:
        -: 1783:template
        -: 1784:<typename Allocator
        -: 1785:   , typename B // B models BidirIterator
        -: 1786:   , typename InsertionProxy
        -: 1787:>
        -: 1788:inline void expand_backward_forward_and_insert_alloc_move_forward
        -: 1789:   ( B const old_start
        -: 1790:   , std::size_t const old_size
        -: 1791:   , B const new_start
        -: 1792:   , B const pos
        -: 1793:   , std::size_t const n
        -: 1794:   , InsertionProxy insertion_proxy
        -: 1795:   , Allocator& a)
        -: 1796:{
        -: 1797:   typedef std::size_t size_type;
        -: 1798:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -: 1799:   static const bool trivial_dctr_after_move = has_trivial_destructor_after_move<value_type>::value;
        -: 1800:   static const bool trivial_dctr = dtl::is_trivially_destructible<value_type>::value;
        -: 1801:
        -: 1802:   typedef typename dtl::if_c
        -: 1803:      <trivial_dctr
        -: 1804:      , dtl::null_scoped_destructor_n<Allocator, B>
        -: 1805:      , dtl::scoped_destructor_n<Allocator, B>
        -: 1806:      >::type   array_destructor_t;
        -: 1807:
        -: 1808:   //n can be zero to just expand capacity
        -: 1809:
        -: 1810:   B const old_finish = make_iterator_uadvance(old_start, old_size);
        -: 1811:   const size_type new_size = size_type(old_size + n);
        -: 1812:   B const new_finish = make_iterator_uadvance(new_start, new_size);
        -: 1813:
        -: 1814:   //We can have 8 possibilities:
        -: 1815:
        -: 1816:   const size_type elemsafter = static_cast<size_type>(iterator_udistance(pos, old_finish));
        -: 1817:   const size_type raw_after = static_cast<size_type>(iterator_udistance(old_finish, new_finish));
        -: 1818:
        -: 1819:   const size_type after_plus_new = size_type(elemsafter + n);
        -: 1820:
        -: 1821:   //Check if raw_before is big enough to hold the new data + the end of old data
        -: 1822:   if (raw_after >= after_plus_new) {
        -: 1823:      //If anything goes wrong, this object will destroy
        -: 1824:      //all the old objects to fulfill previous vector state
        -: 1825:      array_destructor_t old_values_destroyer(old_start, a, old_size);
        -: 1826:      //______________________ __________________________________
        -: 1827:      //| old_begin | old_end |            raw_mem                  //Old situation
        -: 1828:      //|___________|_________|__________________________________
        -: 1829:      // _____________________ _________________________________
        -: 1830:      //| old_begin | old_end |  raw_mem |    new   |  old_end  |  //First step
        -: 1831:      //|___________|_________|__________|__________|___________|
        -: 1832:
        -: 1833:      //Copy first new objects, after that old values after pos
        -: 1834:      B new_elem_pos = new_finish - after_plus_new;
        -: 1835:      insertion_proxy.uninitialized_copy_n_and_update(a, new_elem_pos, n);
        -: 1836:      array_destructor_t new_values_destroyer(new_elem_pos, a, n);
        -: 1837:      ::boost::container::uninitialized_move_alloc(a, pos, old_finish, new_elem_pos+n);
        -: 1838:      new_values_destroyer.set_size(after_plus_new);
        -: 1839:
        -: 1840:      //Check if raw_before is so big that even copying the old data + new data
        -: 1841:      //there is a gap between the new data and the old data
        -: 1842:      if (raw_after >= new_size) {
        -: 1843:         //______________________ __________________________________
        -: 1844:         //| old_begin | old_end |            raw_mem                  //Old situation
        -: 1845:         //|___________|_________|__________________________________
        -: 1846:         // _____________________ _________________________________
        -: 1847:         //| old_begin | old_end |    raw_mem   |   new  | old_end |  //First step
        -: 1848:         //|___________|_________|______________|________|_________|
        -: 1849:         // _____________________V_________________________________
        -: 1850:         //|       raw_mem          | old_begin |   new  | old_end | //New situation
        -: 1851:         //|________________________|___________|________|_________|
        -: 1852:         //
        -: 1853:         //Now initialize the rest of memory with the last old values
        -: 1854:         ::boost::container::uninitialized_move_alloc(a, old_start, pos, new_start);
        -: 1855:         //All new elements correctly constructed, avoid new element destruction
        -: 1856:         new_values_destroyer.release();
        -: 1857:         //Old values destroyed automatically with "old_values_destroyer"
        -: 1858:         //when "old_values_destroyer" goes out of scope unless the have trivial
        -: 1859:         //destructor after move.
        -: 1860:         if(trivial_dctr_after_move)
        -: 1861:            old_values_destroyer.release();
        -: 1862:      }
        -: 1863:      //raw_before is so big that divides old_end
        -: 1864:      else {
        -: 1865:         //______________________ ____________________________
        -: 1866:         //| old_begin | old_end |          raw_mem             //Old situation
        -: 1867:         //|___________|_________|____________________________
        -: 1868:         // _____________________ ____________________________
        -: 1869:         //| old_begin | old_end | raw_mem |   new  | old_end | //First step
        -: 1870:         //|___________|_________|_________|________|_________|
        -: 1871:         // _________________________________________________
        -: 1872:         //|       raw_mem     | old_begin |   new  | old_end | //New situation
        -: 1873:         //|___________________|___________|________|_________|
        -: 1874:
        -: 1875:         //Now initialize the rest of raw_before memory with the
        -: 1876:         //last elements before new values
        -: 1877:         const size_type raw_gap = raw_after - after_plus_new;
        -: 1878:         B const pre_pos_raw = pos - raw_gap;
        -: 1879:         ::boost::container::uninitialized_move_alloc_n(a, pre_pos_raw, raw_gap, old_finish);
        -: 1880:         new_values_destroyer.release();
        -: 1881:         old_values_destroyer.increment_size(raw_after);
        -: 1882:         //Now move remaining last objects in the old buffer begin
        -: 1883:         BOOST_ASSERT(old_start != old_finish);
        -: 1884:         boost::container::move_backward_overlapping(old_start, pre_pos_raw, old_finish);
        -: 1885:         old_values_destroyer.release();
        -: 1886:         if (!trivial_dctr_after_move) {
        -: 1887:            boost::container::destroy_alloc(a, old_start, new_start);
        -: 1888:         }
        -: 1889:      }
        -: 1890:   }
        -: 1891:   else{
        -: 1892:      //If anything goes wrong, this object will destroy
        -: 1893:      //all the old objects to fulfill previous vector state
        -: 1894:      array_destructor_t old_values_destroyer(old_start, a, old_size);
        -: 1895:
        -: 1896:      //Now we can have two situations: the raw_mem of the
        -: 1897:      //end divides the new elements or the old_end
        -: 1898:      if (raw_after > elemsafter) {
        -: 1899:         //The raw memory divides the new elements
        -: 1900:         //__________________________________
        -: 1901:         //| old_begin | old_end |    raw    |  //Old situation
        -: 1902:         //|___________|_________|___________|
        -: 1903:         // _____ ___________________________
        -: 1904:         //| raw | old_begin | new | old_end |  //New situation
        -: 1905:         //|_____|___________|_____|_________|
        -: 1906:
        -: 1907:         //First copy whole old_end and part of new to raw_mem
        -: 1908:         B p = new_finish - elemsafter;
        -: 1909:         ::boost::container::uninitialized_move_alloc(a, pos, old_finish, p);
        -: 1910:         array_destructor_t new_values_destroyer(p, a, elemsafter);
        -: 1911:         //Copy all new elements
        -: 1912:         const size_type mid_n = size_type(raw_after - elemsafter);
        -: 1913:         const size_type rest_new = size_type(n - mid_n);
        -: 1914:         B new_rng_start = old_finish - rest_new;
        -: 1915:         insertion_proxy.copy_n_and_update(a, new_rng_start, rest_new);
        -: 1916:         insertion_proxy.uninitialized_copy_n_and_update(a, old_finish, mid_n);
        -: 1917:         new_values_destroyer.release();
        -: 1918:         old_values_destroyer.increment_size_backwards(raw_after);
        -: 1919:         //Displace old_end, but make sure data has to be moved
        -: 1920:         p = ::boost::container::move_backward_overlapping(old_start, pos, new_rng_start);
        -: 1921:
        -: 1922:         //Destroy remaining moved elements from old_begin except if they
        -: 1923:         //have trivial destructor after being moved
        -: 1924:         old_values_destroyer.release();
        -: 1925:         if (!trivial_dctr_after_move) {
        -: 1926:            boost::container::destroy_alloc(a, old_start, p);
        -: 1927:         }
        -: 1928:      }
        -: 1929:      else {
        -: 1930:         //The raw memory divides the old_end group:
        -: 1931:         //________________________________________
        -: 1932:         //| old_begin |    old_end    |      raw  |  //Old situation
        -: 1933:         //|___________|_______________|___________|
        -: 1934:         // _____ __________________________________
        -: 1935:         //| raw | old_begin | new |    old_end    |  //New situation
        -: 1936:         //|_____|___________|_____|_______________|
        -: 1937:         //
        -: 1938:         //Copy the last part of old_end to raw_mem
        -: 1939:         const B old_end_pivot = old_finish - raw_after;
        -: 1940:         ::boost::container::uninitialized_move_alloc_n(a, old_end_pivot, raw_after, old_finish);
        -: 1941:         //The buffer is all constructed
        -: 1942:         old_values_destroyer.increment_size_backwards(raw_after);
        -: 1943:
        -: 1944:         //Now copy the first part of old_end overwriting itself
        -: 1945:         B const new_end_pos = ::boost::container::move_backward_overlapping(pos, old_end_pivot, old_finish);
        -: 1946:         B const new_beg_pos = new_end_pos - n;
        -: 1947:
        -: 1948:         //Now copy the new_beg elements
        -: 1949:         insertion_proxy.copy_n_and_update(a, new_beg_pos, n);
        -: 1950:         B const p = ::boost::container::move_backward_overlapping(old_start, pos, new_beg_pos);
        -: 1951:         old_values_destroyer.release();
        -: 1952:
        -: 1953:         if (!trivial_dctr_after_move) {
        -: 1954:            (void)p;
        -: 1955:            boost::container::destroy_alloc(a, old_start, p);
        -: 1956:         }
        -: 1957:      }
        -: 1958:   }
        -: 1959:}
        -: 1960:
        -: 1961:template <class R, class InsertionProxy, class Allocator>
        -: 1962:void expand_backward_forward_and_insert_alloc
        -: 1963:   ( R const old_start
        -: 1964:   , std::size_t const old_size
        -: 1965:   , R const new_start
        -: 1966:   , R const pos
        -: 1967:   , std::size_t const n
        -: 1968:   , InsertionProxy insertion_proxy
        -: 1969:   , Allocator& a)
        -: 1970:{
        -: 1971:   if(new_start < old_start){
        -: 1972:      expand_backward_forward_and_insert_alloc_move_backward(old_start, old_size, new_start, pos, n, insertion_proxy, a);
        -: 1973:   }
        -: 1974:   else{
        -: 1975:      expand_backward_forward_and_insert_alloc_move_forward(old_start, old_size, new_start, pos, n, insertion_proxy, a);
        -: 1976:   }
        -: 1977:}
        -: 1978:
        -: 1979:}  //namespace container {
        -: 1980:}  //namespace boost {
        -: 1981:
        -: 1982://#pragma GCC diagnostic ignored "-Wclass-memaccess"
        -: 1983:#if defined(BOOST_GCC) && (BOOST_GCC >= 40600)
        -: 1984:#pragma GCC diagnostic pop
        -: 1985:#endif
        -: 1986:
        -: 1987:#endif   //#ifndef BOOST_CONTAINER_DETAIL_COPY_MOVE_ALGO_HPP
