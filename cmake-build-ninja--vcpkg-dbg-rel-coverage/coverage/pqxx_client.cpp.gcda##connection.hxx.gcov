        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/pqxx/connection.hxx
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Definition of the connection class.
        -:    2: *
        -:    3: * pqxx::connection encapsulates a connection to a database.
        -:    4: *
        -:    5: * DO NOT INCLUDE THIS FILE DIRECTLY; include pqxx/connection instead.
        -:    6: *
        -:    7: * Copyright (c) 2000-2024, Jeroen T. Vermeulen.
        -:    8: *
        -:    9: * See COPYING for copyright license.  If you did not receive a file called
        -:   10: * COPYING with this source code, please notify the distributor of this
        -:   11: * mistake, or contact the author.
        -:   12: */
        -:   13:#ifndef PQXX_H_CONNECTION
        -:   14:#define PQXX_H_CONNECTION
        -:   15:
        -:   16:#if !defined(PQXX_HEADER_PRE)
        -:   17:#  error "Include libpqxx headers as <pqxx/header>, not <pqxx/header.hxx>."
        -:   18:#endif
        -:   19:
        -:   20:#include <cstddef>
        -:   21:#include <ctime>
        -:   22:#include <initializer_list>
        -:   23:#include <list>
        -:   24:#include <map>
        -:   25:#include <memory>
        -:   26:#include <string_view>
        -:   27:#include <tuple>
        -:   28:
        -:   29:// Double-check in order to suppress an overzealous Visual C++ warning (#418).
        -:   30:#if defined(PQXX_HAVE_CONCEPTS) && __has_include(<ranges>)
        -:   31:#  include <ranges>
        -:   32:#endif
        -:   33:
        -:   34:#include "pqxx/errorhandler.hxx"
        -:   35:#include "pqxx/except.hxx"
        -:   36:#include "pqxx/internal/concat.hxx"
        -:   37:#include "pqxx/params.hxx"
        -:   38:#include "pqxx/separated_list.hxx"
        -:   39:#include "pqxx/strconv.hxx"
        -:   40:#include "pqxx/types.hxx"
        -:   41:#include "pqxx/util.hxx"
        -:   42:#include "pqxx/zview.hxx"
        -:   43:
        -:   44:
        -:   45:/**
        -:   46: * @addtogroup connections
        -:   47: *
        -:   48: * Use of the libpqxx library starts here.
        -:   49: *
        -:   50: * Everything that can be done with a database through libpqxx must go through
        -:   51: * a @ref pqxx::connection object.  It connects to a database when you create
        -:   52: * it, and it terminates that communication during destruction.
        -:   53: *
        -:   54: * Many things come together in this class.  Handling of error and warning
        -:   55: * messages, for example, is defined by @ref pqxx::errorhandler objects in the
        -:   56: * context of a connection.  Prepared statements are also defined here.  For
        -:   57: * actually executing SQL on it, however, you'll also need a transaction
        -:   58: * object which operates "on top of" the connection.  (See @ref transactions
        -:   59: * for more about these.)
        -:   60: *
        -:   61: * When you connect to a database, you pass a connection string containing any
        -:   62: * parameters and options, such as the server address and the database name.
        -:   63: *
        -:   64: * These are identical to the ones in libpq, the C language binding upon which
        -:   65: * libpqxx itself is built:
        -:   66: *
        -:   67: * https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING
        -:   68: *
        -:   69: * There are also environment variables you can set to provide defaults, again
        -:   70: * as defined by libpq:
        -:   71: *
        -:   72: * https://www.postgresql.org/docs/current/libpq-envars.html
        -:   73: *
        -:   74: * You can also create a database connection _asynchronously_ using an
        -:   75: * intermediate @ref pqxx::connecting object.
        -:   76: */
        -:   77:
        -:   78:namespace pqxx::internal
        -:   79:{
        -:   80:class sql_cursor;
        -:   81:
        -:   82:#if defined(PQXX_HAVE_CONCEPTS)
        -:   83:/// Concept: T is a range of pairs of zero-terminated strings.
        -:   84:template<typename T>
        -:   85:concept ZKey_ZValues = std::ranges::input_range<T> and requires(T t) {
        -:   86:  { std::cbegin(t) };
        -:   87:  { std::get<0>(*std::cbegin(t)) } -> ZString;
        -:   88:  { std::get<1>(*std::cbegin(t)) } -> ZString;
        -:   89:} and std::tuple_size_v<typename std::ranges::iterator_t<T>::value_type> == 2;
        -:   90:#endif // PQXX_HAVE_CONCEPTS
        -:   91:
        -:   92:
        -:   93:/// Control OpenSSL/crypto library initialisation.
        -:   94:/** This is an internal helper.  Unless you're working on libpqxx itself, use
        -:   95: * @ref pqxx::skip_init_ssl instead.
        -:   96: *
        -:   97: * @param flags a bitmask of `1 << flag` for each of the `skip_init` flags.
        -:   98: *
        -:   99: * Ignores the `skip_init::nothing` flag.
        -:  100: */
        -:  101:void PQXX_COLD PQXX_LIBEXPORT skip_init_ssl(int skips) noexcept;
        -:  102:} // namespace pqxx::internal
        -:  103:
        -:  104:
        -:  105:namespace pqxx::internal::gate
        -:  106:{
        -:  107:class connection_dbtransaction;
        -:  108:class connection_errorhandler;
        -:  109:class connection_largeobject;
        -:  110:class connection_notification_receiver;
        -:  111:class connection_pipeline;
        -:  112:class connection_sql_cursor;
        -:  113:struct connection_stream_from;
        -:  114:class connection_stream_to;
        -:  115:class connection_transaction;
        -:  116:class const_connection_largeobject;
        -:  117:} // namespace pqxx::internal::gate
        -:  118:
        -:  119:
        -:  120:namespace pqxx
        -:  121:{
        -:  122:/// Flags for skipping initialisation of SSL-related libraries.
        -:  123:/** When a running process makes its first SSL connection to a database through
        -:  124: * libpqxx, libpq automatically initialises the OpenSSL and libcrypto
        -:  125: * libraries.  But there are scenarios in which you may want to suppress that.
        -:  126: *
        -:  127: * This enum is a way to express this.  Pass values of this enum to
        -:  128: * @ref pqxx::skip_init_ssl as template arguments.
        -:  129: */
        -:  130:enum skip_init : int
        -:  131:{
        -:  132:  /// A do-nothing flag that does not affect anything.
        -:  133:  nothing,
        -:  134:
        -:  135:  /// Skip initialisation of OpenSSL library.
        -:  136:  openssl,
        -:  137:
        -:  138:  /// Skip initialisation of libcrypto.
        -:  139:  crypto,
        -:  140:};
        -:  141:
        -:  142:
        -:  143:/// Control initialisation of OpenSSL and libcrypto libraries.
        -:  144:/** By default, libpq initialises the openssl and libcrypto libraries when your
        -:  145: * process first opens an SSL connection to a database.  But this may not be
        -:  146: * what you want: perhaps your application (or some other library it uses)
        -:  147: * already initialises one or both of these libraries.
        -:  148: *
        -:  149: * Call this function to stop libpq from initialising one or the other of
        -:  150: * these. Pass as arguments each of the `skip_init` flags for which of the
        -:  151: * libraries whose initialisation you want to prevent.
        -:  152: *
        -:  153: * @warning Each call to this function _overwrites_ the effects of any previous
        -:  154: * call.  So if you make one call to skip OpenSSL initialisation, and then
        -:  155: * another to skip libcrypto initialisation, the first call will do nothing.
        -:  156: *
        -:  157: * Examples:
        -:  158: * * To let libpq initialise libcrypto but not OpenSSL:
        -:  159: *   `skip_init_ssl<pqxx::skip_init::openssl>();`
        -:  160: * * To let libpq know that it should not initialise either:
        -:  161: *   ```cxx
        -:  162: *   skip_init_ssl<pqxx::skip_init::openssl, pqxx::skip_init::crypto>();
        -:  163: *   ```
        -:  164: * * To say explicitly that you want libpq to initialise both:
        -:  165: *   `skip_init_ssl<pqxx::skip_init::nothing>();`
        -:  166: */
        -:  167:template<skip_init... SKIP> inline void skip_init_ssl() noexcept
        -:  168:{
        -:  169:  // (Normalise skip flags to one per.)
        -:  170:  pqxx::internal::skip_init_ssl(((1 << SKIP) | ...));
        -:  171:}
        -:  172:
        -:  173:
        -:  174:/// Representation of a PostgreSQL table path.
        -:  175:/** A "table path" consists of a table name, optionally prefixed by a schema
        -:  176: * name, which in turn is optionally prefixed by a database name.
        -:  177: *
        -:  178: * A minimal example of a table path would be `{mytable}`.  But a table path
        -:  179: * may also take the forms `{myschema,mytable}` or
        -:  180: * `{mydb,myschema,mytable}`.
        -:  181: */
        -:  182:using table_path = std::initializer_list<std::string_view>;
        -:  183:
        -:  184:
        -:  185:/// Error verbosity levels.
        -:  186:enum class error_verbosity : int
        -:  187:{
        -:  188:  // These values must match those in libpq's PGVerbosity enum.
        -:  189:  terse = 0,
        -:  190:  normal = 1,
        -:  191:  verbose = 2
        -:  192:};
        -:  193:
        -:  194:
        -:  195:/// Connection to a database.
        -:  196:/** This is the first class to look at when you wish to work with a database
        -:  197: * through libpqxx.  As per RAII principles, the connection opens during
        -:  198: * construction, and closes upon destruction.  If the connection attempt fails,
        -:  199: * you will not get a @ref connection object; the constructor will fail with a
        -:  200: * @ref pqxx::broken_connection exception.
        -:  201: *
        -:  202: * When creating a connection, you can pass a connection URI or a postgres
        -:  203: * connection string, to specify the database server's address, a login
        -:  204: * username, and so on.  If you don't, the connection will try to obtain them
        -:  205: * from certain environment variables.  If those are not set either, the
        -:  206: * default is to try and connect to the local system's port 5432.
        -:  207: *
        -:  208: * Find more about connection strings here:
        -:  209: *
        -:  210: * https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING
        -:  211: *
        -:  212: * The variables are documented here:
        -:  213: *
        -:  214: * https://www.postgresql.org/docs/current/libpq-envars.html
        -:  215: *
        -:  216: * To query or manipulate the database once connected, use one of the
        -:  217: * transaction classes (see pqxx/transaction_base.hxx) and perhaps also the
        -:  218: * transactor framework (see pqxx/transactor.hxx).
        -:  219: *
        -:  220: * When a connection breaks, or fails to establish itself in the first place,
        -:  221: * you will typically get a @ref broken_connection exception.  This can happen
        -:  222: * at almost any point.
        -:  223: *
        -:  224: * @warning On Unix-like systems, including GNU and BSD systems, your program
        -:  225: * may receive the SIGPIPE signal when the connection to the backend breaks. By
        -:  226: * default this signal will abort your program.  Use "signal(SIGPIPE, SIG_IGN)"
        -:  227: * if you want your program to continue running after a connection fails.
        -:  228: */
        -:  229:class PQXX_LIBEXPORT connection
        -:  230:{
        -:  231:public:
        -:  232:  connection() : connection{""} {}
        -:  233:
        -:  234:  /// Connect to a database, using `options` string.
function _ZN4pqxx10connectionC2EPKc called 20 returned 100% blocks executed 50%
       40:  235:  explicit connection(char const options[])
        -:  236:  {
       20:  237:    check_version();
       20:  238:    init(options);
       20:  238-block  0
branch  0 taken 20
branch  1 taken 0
       20:  239:  }
       20:  239-block  0
    $$$$$:  239-block  1
    $$$$$:  239-block  2
        -:  240:
        -:  241:  /// Connect to a database, using `options` string.
function _ZN4pqxx10connectionC2ENS_5zviewE called 20 returned 100% blocks executed 100%
       20:  242:  explicit connection(zview options) : connection{options.c_str()}
        -:  243:  {
        -:  244:    // (Delegates to other constructor which calls check_version for us.)
       20:  245:  }
       20:  245-block  0
        -:  246:
        -:  247:  /// Move constructor.
        -:  248:  /** Moving a connection is not allowed if it has an open transaction, or has
        -:  249:   * error handlers or notification receivers registered on it.  In those
        -:  250:   * situations, other objects may hold references to the old object which
        -:  251:   * would become invalid and might produce hard-to-diagnose bugs.
        -:  252:   */
        -:  253:  connection(connection &&rhs);
        -:  254:
        -:  255:#if defined(PQXX_HAVE_CONCEPTS)
        -:  256:  /// Connect to a database, passing options as a range of key/value pairs.
        -:  257:  /** @warning Experimental.  Requires C++20 "concepts" support.  Define
        -:  258:   * `PQXX_HAVE_CONCEPTS` to enable it.
        -:  259:   *
        -:  260:   * There's no need to escape the parameter values.
        -:  261:   *
        -:  262:   * See the PostgreSQL libpq documentation for the full list of possible
        -:  263:   * options:
        -:  264:   *
        -:  265:   * https://postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS
        -:  266:   *
        -:  267:   * The options can be anything that can be iterated as a series of pairs of
        -:  268:   * zero-terminated strings: `std::pair<std::string, std::string>`, or
        -:  269:   * `std::tuple<pqxx::zview, char const *>`, or
        -:  270:   * `std::map<std::string, pqxx::zview>`, and so on.
        -:  271:   */
        -:  272:  template<internal::ZKey_ZValues MAPPING>
        -:  273:  inline connection(MAPPING const &params);
        -:  274:#endif // PQXX_HAVE_CONCEPTS
        -:  275:
function _ZN4pqxx10connectionD2Ev called 20 returned 100% blocks executed 33%
       20:  276:  ~connection()
        -:  277:  {
        -:  278:    try
        -:  279:    {
       20:  280:      close();
       20:  280-block  0
branch  0 taken 20
branch  1 taken 0
       20:  281:    }
       20:  281-block  0
    $$$$$:  281-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  281-block  2
        -:  282:    catch (std::exception const &)
    #####:  283:    {}
    $$$$$:  283-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  283-block  1
    $$$$$:  283-block  2
       20:  284:  }
    $$$$$:  284-block  0
       20:  284-block  1
        -:  285:
        -:  286:  /// Move assignment.
        -:  287:  /** Neither connection can have an open transaction, registered error
        -:  288:   * handlers, or registered notification receivers.
        -:  289:   */
        -:  290:  connection &operator=(connection &&rhs);
        -:  291:
        -:  292:  connection(connection const &) = delete;
        -:  293:  connection &operator=(connection const &) = delete;
        -:  294:
        -:  295:  /// Is this connection open at the moment?
        -:  296:  /** @warning Most code does **not** need this function.  Resist the
        -:  297:   * temptation to check your connection after opening it: if the connection
        -:  298:   * attempt failed, the constructor will never even return, throwing a
        -:  299:   * @ref broken_connection exception instead.
        -:  300:   */
        -:  301:  [[nodiscard]] bool PQXX_PURE is_open() const noexcept;
        -:  302:
        -:  303:  /// Invoke notice processor function.  The message should end in newline.
        -:  304:  void process_notice(char const[]) noexcept;
        -:  305:  /// Invoke notice processor function.  Newline at end is recommended.
        -:  306:  /** The zview variant, with a message ending in newline, is the most
        -:  307:   * efficient way to call process_notice.
        -:  308:   */
        -:  309:  void process_notice(zview) noexcept;
        -:  310:
        -:  311:  /// Enable tracing to a given output stream, or nullptr to disable.
        -:  312:  void trace(std::FILE *) noexcept;
        -:  313:
        -:  314:  /**
        -:  315:   * @name Connection properties
        -:  316:   *
        -:  317:   * These are probably not of great interest, since most are derived from
        -:  318:   * information supplied by the client program itself, but they are included
        -:  319:   * for completeness.
        -:  320:   *
        -:  321:   * The connection needs to be currently active for these to work.
        -:  322:   */
        -:  323:  //@{
        -:  324:  /// Name of the database to which we're connected, if any.
        -:  325:  /** Returns nullptr when not connected. */
        -:  326:  [[nodiscard]] char const *dbname() const;
        -:  327:
        -:  328:  /// Database user ID under which we are connected, if any.
        -:  329:  /** Returns nullptr when not connected. */
        -:  330:  [[nodiscard]] char const *username() const;
        -:  331:
        -:  332:  /// Database server address, if given.
        -:  333:  /** This may be an IP address, or a hostname, or (for a Unix domain socket)
        -:  334:   * a socket path.  Returns nullptr when not connected.
        -:  335:   */
        -:  336:  [[nodiscard]] char const *hostname() const;
        -:  337:
        -:  338:  /// Server port number on which we are connected to the database.
        -:  339:  [[nodiscard]] char const *port() const;
        -:  340:
        -:  341:  /// Process ID for backend process, or 0 if inactive.
        -:  342:  [[nodiscard]] int PQXX_PURE backendpid() const & noexcept;
        -:  343:
        -:  344:  /// Socket currently used for connection, or -1 for none.  Use with care!
        -:  345:  /** Query the current socket number.  This is intended for event loops based
        -:  346:   * on functions such as select() or poll(), where you're waiting for any of
        -:  347:   * multiple file descriptors to become ready for communication.
        -:  348:   *
        -:  349:   * Please try to stay away from this function.  It is really only meant for
        -:  350:   * event loops that need to wait on more than one file descriptor.  If all
        -:  351:   * you need is to block until a notification arrives, for instance, use
        -:  352:   * await_notification().  If you want to issue queries and retrieve results
        -:  353:   * in nonblocking fashion, check out the pipeline class.
        -:  354:   */
        -:  355:  [[nodiscard]] int PQXX_PURE sock() const & noexcept;
        -:  356:
        -:  357:  /// What version of the PostgreSQL protocol is this connection using?
        -:  358:  /** The answer can be 0 (when there is no connection); 3 for protocol 3.0; or
        -:  359:   * possibly higher values as newer protocol versions come into use.
        -:  360:   */
        -:  361:  [[nodiscard]] int PQXX_PURE protocol_version() const noexcept;
        -:  362:
        -:  363:  /// What version of the PostgreSQL server are we connected to?
        -:  364:  /** The result is a bit complicated: each of the major, medium, and minor
        -:  365:   * release numbers is written as a two-digit decimal number, and the three
        -:  366:   * are then concatenated.  Thus server version 9.4.2 will be returned as the
        -:  367:   * decimal number 90402.  If there is no connection to the server, this
        -:  368:   * returns zero.
        -:  369:   *
        -:  370:   * @warning When writing version numbers in your code, don't add zero at the
        -:  371:   * beginning!  Numbers beginning with zero are interpreted as octal (base-8)
        -:  372:   * in C++.  Thus, 070402 is not the same as 70402, and 080000 is not a number
        -:  373:   * at all because there is no digit "8" in octal notation.  Use strictly
        -:  374:   * decimal notation when it comes to these version numbers.
        -:  375:   */
        -:  376:  [[nodiscard]] int PQXX_PURE server_version() const noexcept;
        -:  377:  //@}
        -:  378:
        -:  379:  /// @name Text encoding
        -:  380:  /**
        -:  381:   * Each connection is governed by a "client encoding," which dictates how
        -:  382:   * strings and other text is represented in bytes.  The database server will
        -:  383:   * send text data to you in this encoding, and you should use it for the
        -:  384:   * queries and data which you send to the server.
        -:  385:   *
        -:  386:   * Search the PostgreSQL documentation for "character set encodings" to find
        -:  387:   * out more about the available encodings, how to extend them, and how to use
        -:  388:   * them.  Not all server-side encodings are compatible with all client-side
        -:  389:   * encodings or vice versa.
        -:  390:   *
        -:  391:   * Encoding names are case-insensitive, so e.g. "UTF8" is equivalent to
        -:  392:   * "utf8".
        -:  393:   *
        -:  394:   * You can change the client encoding, but this may not work when the
        -:  395:   * connection is in a special state, such as when streaming a table.  It's
        -:  396:   * not clear what happens if you change the encoding during a transaction,
        -:  397:   * and then abort the transaction.
        -:  398:   */
        -:  399:  //@{
        -:  400:  /// Get client-side character encoding, by name.
        -:  401:  [[nodiscard]] std::string get_client_encoding() const;
        -:  402:
        -:  403:  /// Set client-side character encoding, by name.
        -:  404:  /**
        -:  405:   * @param encoding Name of the character set encoding to use.
        -:  406:   */
        -:  407:  void set_client_encoding(zview encoding) &
        -:  408:  {
        -:  409:    set_client_encoding(encoding.c_str());
        -:  410:  }
        -:  411:
        -:  412:  /// Set client-side character encoding, by name.
        -:  413:  /**
        -:  414:   * @param encoding Name of the character set encoding to use.
        -:  415:   */
        -:  416:  void set_client_encoding(char const encoding[]) &;
        -:  417:
        -:  418:  /// Get the connection's encoding, as a PostgreSQL-defined code.
        -:  419:  [[nodiscard]] int encoding_id() const;
        -:  420:
        -:  421:  //@}
        -:  422:
        -:  423:  /// Set one of the session variables to a new value.
        -:  424:  /** This executes SQL, so do not do it while a pipeline or stream is active
        -:  425:   * on the connection.
        -:  426:   *
        -:  427:   * The value you set here will last for the rest of the connection's
        -:  428:   * duration, or until you set a new value.
        -:  429:   *
        -:  430:   * If you set the value while in a @ref dbtransaction (i.e. any transaction
        -:  431:   * that is not a @ref nontransaction), then rolling back the transaction will
        -:  432:   * undo the change.
        -:  433:   *
        -:  434:   * All applies to setting _session_ variables.  You can also set the same
        -:  435:   * variables as _local_ variables, in which case they will always revert to
        -:  436:   * their previous value when the transaction ends (or when you overwrite them
        -:  437:   * of course).  To set a local variable, simply execute an SQL statement
        -:  438:   * along the lines of "`SET LOCAL var = 'value'`" inside your transaction.
        -:  439:   *
        -:  440:   * @param var The variable to set.
        -:  441:   * @param value The new value for the variable.
        -:  442:   * @throw @ref variable_set_to_null if the value is null; this is not
        -:  443:   * allowed.
        -:  444:   */
        -:  445:  template<typename TYPE>
        -:  446:  void set_session_var(std::string_view var, TYPE const &value) &
        -:  447:  {
        -:  448:    if constexpr (nullness<TYPE>::has_null)
        -:  449:    {
        -:  450:      if (nullness<TYPE>::is_null(value))
        -:  451:        throw variable_set_to_null{
        -:  452:          internal::concat("Attempted to set variable ", var, " to null.")};
        -:  453:    }
        -:  454:    exec(internal::concat("SET ", quote_name(var), "=", quote(value)));
        -:  455:  }
        -:  456:
        -:  457:  /// Read currently applicable value of a variable.
        -:  458:  /** This function executes an SQL statement, so it won't work while a
        -:  459:   * @ref pipeline or query stream is active on the connection.
        -:  460:   *
        -:  461:   * @return a blank `std::optional` if the variable's value is null, or its
        -:  462:   * string value otherwise.
        -:  463:   */
        -:  464:  std::string get_var(std::string_view var);
        -:  465:
        -:  466:  /// Read currently applicable value of a variable.
        -:  467:  /** This function executes an SQL statement, so it won't work while a
        -:  468:   * @ref pipeline or query stream is active on the connection.
        -:  469:   *
        -:  470:   * If there is any possibility that the variable is null, ensure that `TYPE`
        -:  471:   * can represent null values.
        -:  472:   */
        -:  473:  template<typename TYPE> TYPE get_var_as(std::string_view var)
        -:  474:  {
        -:  475:    return from_string<TYPE>(get_var(var));
        -:  476:  }
        -:  477:
        -:  478:  /**
        -:  479:   * @name Notifications and Receivers
        -:  480:   */
        -:  481:  //@{
        -:  482:  /// Check for pending notifications and take appropriate action.
        -:  483:  /** This does not block.  To wait for incoming notifications, either call
        -:  484:   * await_notification() (it calls this function); or wait for incoming data
        -:  485:   * on the connection's socket (i.e. wait to read), and then call this
        -:  486:   * function repeatedly until it returns zero.  After that, there are no more
        -:  487:   * pending notifications so you may want to wait again.
        -:  488:   *
        -:  489:   * If any notifications are pending when you call this function, it
        -:  490:   * processes them by finding any receivers that match the notification string
        -:  491:   * and invoking those.  If no receivers match, there is nothing to invoke but
        -:  492:   * we do consider the notification processed.
        -:  493:   *
        -:  494:   * If any of the client-registered receivers throws an exception, the
        -:  495:   * function will report it using the connection's errorhandlers.  It does not
        -:  496:   * re-throw the exceptions.
        -:  497:   *
        -:  498:   * @return Number of notifications processed.
        -:  499:   */
        -:  500:  int get_notifs();
        -:  501:
        -:  502:  /// Wait for a notification to come in.
        -:  503:  /** There are other events that will also terminate the wait, such as the
        -:  504:   * backend failing.  It will also wake up periodically.
        -:  505:   *
        -:  506:   * If a notification comes in, the call will process it, along with any other
        -:  507:   * notifications that may have been pending.
        -:  508:   *
        -:  509:   * To wait for notifications into your own event loop instead, wait until
        -:  510:   * there is incoming data on the connection's socket to be read, then call
        -:  511:   * @ref get_notifs() repeatedly until it returns zero.
        -:  512:   *
        -:  513:   * @return Number of notifications processed.
        -:  514:   */
        -:  515:  int await_notification();
        -:  516:
        -:  517:  /// Wait for a notification to come in, or for given timeout to pass.
        -:  518:  /** There are other events that will also terminate the wait, such as the
        -:  519:   * backend failing, or timeout expiring.
        -:  520:   *
        -:  521:   * If a notification comes in, the call will process it, along with any other
        -:  522:   * notifications that may have been pending.
        -:  523:   *
        -:  524:   * To wait for notifications into your own event loop instead, wait until
        -:  525:   * there is incoming data on the connection's socket to be read, then call
        -:  526:   * @ref get_notifs repeatedly until it returns zero.
        -:  527:   *
        -:  528:   * @return Number of notifications processed
        -:  529:   */
        -:  530:  int await_notification(std::time_t seconds, long microseconds);
        -:  531:  //@}
        -:  532:
        -:  533:  /**
        -:  534:   * @name Password encryption
        -:  535:   *
        -:  536:   * Use this when setting a new password for the user if password encryption
        -:  537:   * is enabled.  Inputs are the SQL name for the user for whom you with to
        -:  538:   * encrypt a password; the plaintext password; and the hash algorithm.
        -:  539:   *
        -:  540:   * The algorithm must be one of "md5", "scram-sha-256" (introduced in
        -:  541:   * PostgreSQL 10), or `nullptr`.  If the pointer is null, this will query
        -:  542:   * the `password_encryption setting` from the server, and use the default
        -:  543:   * algorithm as defined there.
        -:  544:   *
        -:  545:   * @return encrypted version of the password, suitable for encrypted
        -:  546:   * PostgreSQL authentication.
        -:  547:   *
        -:  548:   * Thus you can change a user's password with:
        -:  549:   * ```cxx
        -:  550:   * void setpw(transaction_base &t, string const &user, string const &pw)
        -:  551:   * {
        -:  552:   *   t.exec0("ALTER USER " + user + " "
        -:  553:   *       "PASSWORD '" + t.conn().encrypt_password(user,pw) + "'");
        -:  554:   * }
        -:  555:   * ```
        -:  556:   *
        -:  557:   * When building this against a libpq older than version 10, this will use
        -:  558:   * an older function which only supports md5.  In that case, requesting a
        -:  559:   * different algorithm than md5 will result in a @ref feature_not_supported
        -:  560:   * exception.
        -:  561:   */
        -:  562:  //@{
        -:  563:  /// Encrypt a password for a given user.
        -:  564:  [[nodiscard]] std::string
        -:  565:  encrypt_password(zview user, zview password, zview algorithm)
        -:  566:  {
        -:  567:    return encrypt_password(user.c_str(), password.c_str(), algorithm.c_str());
        -:  568:  }
        -:  569:  /// Encrypt a password for a given user.
        -:  570:  [[nodiscard]] std::string encrypt_password(
        -:  571:    char const user[], char const password[], char const *algorithm = nullptr);
        -:  572:  //@}
        -:  573:
        -:  574:  /**
        -:  575:   * @name Prepared statements
        -:  576:   *
        -:  577:   * PostgreSQL supports prepared SQL statements, i.e. statements that you can
        -:  578:   * register under a name you choose, optimized once by the backend, and
        -:  579:   * executed any number of times under the given name.
        -:  580:   *
        -:  581:   * Prepared statement definitions are not sensitive to transaction
        -:  582:   * boundaries. A statement defined inside a transaction will remain defined
        -:  583:   * outside that transaction, even if the transaction itself is subsequently
        -:  584:   * aborted.  Once a statement has been prepared, it will only go away if you
        -:  585:   * close the connection or explicitly "unprepare" the statement.
        -:  586:   *
        -:  587:   * Use the `pqxx::transaction_base::exec_prepared` functions to execute a
        -:  588:   * prepared statement.  See @ref prepared for a full discussion.
        -:  589:   *
        -:  590:   * @warning Using prepared statements can save time, but if your statement
        -:  591:   * takes parameters, it may also make your application significantly slower!
        -:  592:   * The reason is that the server works out a plan for executing the query
        -:  593:   * when you prepare it.  At that time, of course it does not know the values
        -:  594:   * for the parameters that you will pass.  If you execute a query without
        -:  595:   * preparing it, then the server works out the plan on the spot, with full
        -:  596:   * knowledge of the parameter values.
        -:  597:   *
        -:  598:   * A statement's definition can refer to its parameters as `$1`, `$2`, etc.
        -:  599:   * The first parameter you pass to the call provides a value for `$1`, and
        -:  600:   * so on.
        -:  601:   *
        -:  602:   * Here's an example of how to use prepared statements.
        -:  603:   *
        -:  604:   * ```cxx
        -:  605:   * using namespace pqxx;
        -:  606:   * void foo(connection &c)
        -:  607:   * {
        -:  608:   *   c.prepare("findtable", "select * from pg_tables where name=$1");
        -:  609:   *   work tx{c};
        -:  610:   *   result r = tx.exec_prepared("findtable", "mytable");
        -:  611:   *   if (std::empty(r)) throw runtime_error{"mytable not found!"};
        -:  612:   * }
        -:  613:   * ```
        -:  614:   */
        -:  615:  //@{
        -:  616:
        -:  617:  /// Define a prepared statement.
        -:  618:  /**
        -:  619:   * @param name unique name for the new prepared statement.
        -:  620:   * @param definition SQL statement to prepare.
        -:  621:   */
        -:  622:  void prepare(zview name, zview definition) &
        -:  623:  {
        -:  624:    prepare(name.c_str(), definition.c_str());
        -:  625:  }
        -:  626:
        -:  627:  /**
        -:  628:   * @param name unique name for the new prepared statement.
        -:  629:   * @param definition SQL statement to prepare.
        -:  630:   */
        -:  631:  void prepare(char const name[], char const definition[]) &;
        -:  632:
        -:  633:  /// Define a nameless prepared statement.
        -:  634:  /**
        -:  635:   * This can be useful if you merely want to pass large binary parameters to a
        -:  636:   * statement without otherwise wishing to prepare it.  If you use this
        -:  637:   * feature, always keep the definition and the use close together to avoid
        -:  638:   * the nameless statement being redefined unexpectedly by code somewhere
        -:  639:   * else.
        -:  640:   */
        -:  641:  void prepare(char const definition[]) &;
        -:  642:  void prepare(zview definition) & { return prepare(definition.c_str()); }
        -:  643:
        -:  644:  /// Drop prepared statement.
        -:  645:  void unprepare(std::string_view name);
        -:  646:
        -:  647:  //@}
        -:  648:
        -:  649:  // C++20: constexpr.  Breaks ABI.
        -:  650:  /// Suffix unique number to name to make it unique within session context.
        -:  651:  /** Used internally to generate identifiers for SQL objects (such as cursors
        -:  652:   * and nested transactions) based on a given human-readable base name.
        -:  653:   */
        -:  654:  [[nodiscard]] std::string adorn_name(std::string_view);
        -:  655:
        -:  656:  /**
        -:  657:   * @defgroup escaping-functions String-escaping functions
        -:  658:   */
        -:  659:  //@{
        -:  660:
        -:  661:  /// Escape string for use as SQL string literal on this connection.
        -:  662:  [[nodiscard]] std::string esc(char const text[]) const
        -:  663:  {
        -:  664:    return esc(std::string_view{text});
        -:  665:  }
        -:  666:
        -:  667:#if defined(PQXX_HAVE_SPAN)
        -:  668:  /// Escape string for use as SQL string literal, into `buffer`.
        -:  669:  /** Use this variant when you want to re-use the same buffer across multiple
        -:  670:   * calls.  If that's not the case, or convenience and simplicity are more
        -:  671:   * important, use the single-argument variant.
        -:  672:   *
        -:  673:   * For every byte in `text`, there must be at least 2 bytes of space in
        -:  674:   * `buffer`; plus there must be one byte of space for a trailing zero.
        -:  675:   * Throws @ref range_error if this space is not available.
        -:  676:   *
        -:  677:   * Returns a reference to the escaped string, which is actually stored in
        -:  678:   * `buffer`.
        -:  679:   */
        -:  680:  [[nodiscard]] std::string_view
        -:  681:  esc(std::string_view text, std::span<char> buffer)
        -:  682:  {
        -:  683:    auto const size{std::size(text)}, space{std::size(buffer)};
        -:  684:    auto const needed{2 * size + 1};
        -:  685:    if (space < needed)
        -:  686:      throw range_error{internal::concat(
        -:  687:        "Not enough room to escape string of ", size, " byte(s): need ",
        -:  688:        needed, " bytes of buffer space, but buffer size is ", space, ".")};
        -:  689:    auto const data{buffer.data()};
        -:  690:    return {data, esc_to_buf(text, data)};
        -:  691:  }
        -:  692:#endif
        -:  693:
        -:  694:  /// Escape string for use as SQL string literal on this connection.
        -:  695:  /** @warning This is meant for text strings only.  It cannot contain bytes
        -:  696:   * whose value is zero ("nul bytes").
        -:  697:   */
        -:  698:  [[nodiscard]] std::string esc(std::string_view text) const;
        -:  699:
        -:  700:#if defined(PQXX_HAVE_CONCEPTS)
        -:  701:  /// Escape binary string for use as SQL string literal on this connection.
        -:  702:  /** This is identical to `esc_raw(data)`. */
        -:  703:  template<binary DATA> [[nodiscard]] std::string esc(DATA const &data) const
        -:  704:  {
        -:  705:    return esc_raw(data);
        -:  706:  }
        -:  707:#endif
        -:  708:
        -:  709:#if defined(PQXX_HAVE_CONCEPTS) && defined(PQXX_HAVE_SPAN)
        -:  710:  /// Escape binary string for use as SQL string literal, into `buffer`.
        -:  711:  /** Use this variant when you want to re-use the same buffer across multiple
        -:  712:   * calls.  If that's not the case, or convenience and simplicity are more
        -:  713:   * important, use the single-argument variant.
        -:  714:   *
        -:  715:   * For every byte in `data`, there must be at least two bytes of space in
        -:  716:   * `buffer`; plus there must be two bytes of space for a header and one for
        -:  717:   * a trailing zero.  Throws @ref range_error if this space is not available.
        -:  718:   *
        -:  719:   * Returns a reference to the escaped string, which is actually stored in
        -:  720:   * `buffer`.
        -:  721:   */
        -:  722:  template<binary DATA>
        -:  723:  [[nodiscard]] zview esc(DATA const &data, std::span<char> buffer) const
        -:  724:  {
        -:  725:    auto const size{std::size(data)}, space{std::size(buffer)};
        -:  726:    auto const needed{internal::size_esc_bin(std::size(data))};
        -:  727:    if (space < needed)
        -:  728:      throw range_error{internal::concat(
        -:  729:        "Not enough room to escape binary string of ", size, " byte(s): need ",
        -:  730:        needed, " bytes of buffer space, but buffer size is ", space, ".")};
        -:  731:
        -:  732:    bytes_view view{std::data(data), std::size(data)};
        -:  733:    auto const out{std::data(buffer)};
        -:  734:    // Actually, in the modern format, we know beforehand exactly how many
        -:  735:    // bytes we're going to fill.  Just leave out the trailing zero.
        -:  736:    internal::esc_bin(view, out);
        -:  737:    return zview{out, needed - 1};
        -:  738:  }
        -:  739:#endif
        -:  740:
        -:  741:  /// Escape binary string for use as SQL string literal on this connection.
        -:  742:  [[deprecated("Use std::byte for binary data.")]] std::string
        -:  743:  esc_raw(unsigned char const bin[], std::size_t len) const;
        -:  744:
        -:  745:  /// Escape binary string for use as SQL string literal on this connection.
        -:  746:  /** You can also just use @ref esc with a binary string. */
        -:  747:  [[nodiscard]] std::string esc_raw(bytes_view) const;
        -:  748:
        -:  749:#if defined(PQXX_HAVE_SPAN)
        -:  750:  /// Escape binary string for use as SQL string literal, into `buffer`.
        -:  751:  /** You can also just use @ref esc with a binary string. */
        -:  752:  [[nodiscard]] std::string esc_raw(bytes_view, std::span<char> buffer) const;
        -:  753:#endif
        -:  754:
        -:  755:#if defined(PQXX_HAVE_CONCEPTS)
        -:  756:  /// Escape binary string for use as SQL string literal on this connection.
        -:  757:  /** You can also just use @ref esc with a binary string. */
        -:  758:  template<binary DATA>
        -:  759:  [[nodiscard]] std::string esc_raw(DATA const &data) const
        -:  760:  {
        -:  761:    return esc_raw(bytes_view{std::data(data), std::size(data)});
        -:  762:  }
        -:  763:#endif
        -:  764:
        -:  765:#if defined(PQXX_HAVE_CONCEPTS) && defined(PQXX_HAVE_SPAN)
        -:  766:  /// Escape binary string for use as SQL string literal, into `buffer`.
        -:  767:  template<binary DATA>
        -:  768:  [[nodiscard]] zview esc_raw(DATA const &data, std::span<char> buffer) const
        -:  769:  {
        -:  770:    return this->esc(binary_cast(data), buffer);
        -:  771:  }
        -:  772:#endif
        -:  773:
        -:  774:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  775:  /// Unescape binary data, e.g. from a table field or notification payload.
        -:  776:  /** Takes a binary string as escaped by PostgreSQL, and returns a restored
        -:  777:   * copy of the original binary data.
        -:  778:   *
        -:  779:   * (The data must be encoded in PostgreSQL's "hex" format.  The legacy
        -:  780:   * "bytea" escape format, used prior to PostgreSQL 9.0, is no longer
        -:  781:   * supported.)
        -:  782:   */
        -:  783:  [[nodiscard]] bytes unesc_bin(std::string_view text) const
        -:  784:  {
        -:  785:    bytes buf;
        -:  786:    buf.resize(pqxx::internal::size_unesc_bin(std::size(text)));
        -:  787:    pqxx::internal::unesc_bin(text, buf.data());
        -:  788:    return buf;
        -:  789:  }
        -:  790:
        -:  791:  /// Escape and quote a string of binary data.
        -:  792:  std::string quote_raw(bytes_view) const;
        -:  793:
        -:  794:#if defined(PQXX_HAVE_CONCEPTS)
        -:  795:  /// Escape and quote a string of binary data.
        -:  796:  /** You can also just use @ref quote with binary data. */
        -:  797:  template<binary DATA>
        -:  798:  [[nodiscard]] std::string quote_raw(DATA const &data) const
        -:  799:  {
        -:  800:    return quote_raw(bytes_view{std::data(data), std::size(data)});
        -:  801:  }
        -:  802:#endif
        -:  803:
        -:  804:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  805:  /// Escape and quote an SQL identifier for use in a query.
        -:  806:  [[nodiscard]] std::string quote_name(std::string_view identifier) const;
        -:  807:
        -:  808:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  809:  /// Escape and quote a table name.
        -:  810:  /** When passing just a table name, this is just another name for
        -:  811:   * @ref quote_name.
        -:  812:   */
        -:  813:  [[nodiscard]] std::string quote_table(std::string_view name) const;
        -:  814:
        -:  815:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  816:  /// Escape and quote a table path.
        -:  817:  /** A table path consists of a table name, optionally prefixed by a schema
        -:  818:   * name; and if both are given, they are in turn optionally prefixed by a
        -:  819:   * database name.
        -:  820:   *
        -:  821:   * Each portion of the path (database name, schema name, table name) will be
        -:  822:   * quoted separately, and they will be joined together by dots.  So for
        -:  823:   * example, `myschema.mytable` will become `"myschema"."mytable"`.
        -:  824:   */
        -:  825:  [[nodiscard]] std::string quote_table(table_path) const;
        -:  826:
        -:  827:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  828:  /// Quote and comma-separate a series of column names.
        -:  829:  /** Use this to save a bit of work in cases where you repeatedly need to pass
        -:  830:   * the same list of column names, e.g. with @ref stream_to and @ref
        -:  831:   * stream_from. Some functions that need to quote the columns list
        -:  832:   * internally, will have a "raw" alternative which let you do the quoting
        -:  833:   * yourself.  It's a bit of extra work, but it can in rare cases let you
        -:  834:   * eliminate some duplicate work in quoting them repeatedly.
        -:  835:   */
        -:  836:  template<PQXX_CHAR_STRINGS_ARG STRINGS>
        -:  837:  inline std::string quote_columns(STRINGS const &columns) const;
        -:  838:
        -:  839:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  840:  /// Represent object as SQL string, including quoting & escaping.
        -:  841:  /**
        -:  842:   * Recognises nulls and represents them as SQL nulls.  They get no quotes.
        -:  843:   */
        -:  844:  template<typename T>
        -:  845:  [[nodiscard]] inline std::string quote(T const &t) const;
        -:  846:
        -:  847:  [[deprecated("Use std::byte for binary data.")]] std::string
        -:  848:  quote(binarystring const &) const;
        -:  849:
        -:  850:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  851:  /// Escape and quote binary data for use as a BYTEA value in SQL statement.
        -:  852:  [[nodiscard]] std::string quote(bytes_view bytes) const;
        -:  853:
        -:  854:  // TODO: Make "into buffer" variant to eliminate a string allocation.
        -:  855:  /// Escape string for literal LIKE match.
        -:  856:  /** Use this when part of an SQL "LIKE" pattern should match only as a
        -:  857:   * literal string, not as a pattern, even if it contains "%" or "_"
        -:  858:   * characters that would normally act as wildcards.
        -:  859:   *
        -:  860:   * The string does not get string-escaped or quoted.  You do that later.
        -:  861:   *
        -:  862:   * For instance, let's say you have a string `name` entered by the user,
        -:  863:   * and you're searching a `file` column for items that match `name`
        -:  864:   * followed by a dot and three letters.  Even if `name` contains wildcard
        -:  865:   * characters "%" or "_", you only want those to match literally, so "_"
        -:  866:   * only matches "_" and "%" only matches a single "%".
        -:  867:   *
        -:  868:   * You do that by "like-escaping" `name`, appending the wildcard pattern
        -:  869:   * `".___"`, and finally, escaping and quoting the result for inclusion in
        -:  870:   * your query:
        -:  871:   *
        -:  872:   * ```cxx
        -:  873:   *    tx.exec(
        -:  874:   *        "SELECT file FROM item WHERE file LIKE " +
        -:  875:   *        tx.quote(tx.esc_like(name) + ".___"));
        -:  876:   * ```
        -:  877:   *
        -:  878:   * The SQL "LIKE" operator also lets you choose your own escape character.
        -:  879:   * This is supported, but must be a single-byte character.
        -:  880:   */
        -:  881:  [[nodiscard]] std::string
        -:  882:  esc_like(std::string_view text, char escape_char = '\\') const;
        -:  883:
        -:  884:  /// Escape string for use as SQL string literal on this connection.
        -:  885:  /** @warning This accepts a length, and it does not require a terminating
        -:  886:   * zero byte.  But if there is a zero byte, escaping stops there even if
        -:  887:   * it's not at the end of the string!
        -:  888:   */
        -:  889:  [[deprecated("Use std::string_view or pqxx:zview.")]] std::string
        -:  890:  esc(char const text[], std::size_t maxlen) const
        -:  891:  {
        -:  892:    return esc(std::string_view{text, maxlen});
        -:  893:  }
        -:  894:
        -:  895:  /// Unescape binary data, e.g. from a table field or notification payload.
        -:  896:  /** Takes a binary string as escaped by PostgreSQL, and returns a restored
        -:  897:   * copy of the original binary data.
        -:  898:   */
        -:  899:  [[nodiscard, deprecated("Use unesc_bin() instead.")]] std::string
        -:  900:  unesc_raw(zview text) const
        -:  901:  {
        -:  902:#include "pqxx/internal/ignore-deprecated-pre.hxx"
        -:  903:    return unesc_raw(text.c_str());
        -:  904:#include "pqxx/internal/ignore-deprecated-post.hxx"
        -:  905:  }
        -:  906:
        -:  907:  /// Unescape binary data, e.g. from a table field or notification payload.
        -:  908:  /** Takes a binary string as escaped by PostgreSQL, and returns a restored
        -:  909:   * copy of the original binary data.
        -:  910:   */
        -:  911:  [[nodiscard, deprecated("Use unesc_bin() instead.")]] std::string
        -:  912:  unesc_raw(char const text[]) const;
        -:  913:
        -:  914:  /// Escape and quote a string of binary data.
        -:  915:  [[deprecated("Use quote(bytes_view).")]] std::string
        -:  916:  quote_raw(unsigned char const bin[], std::size_t len) const;
        -:  917:  //@}
        -:  918:
        -:  919:  /// Attempt to cancel the ongoing query, if any.
        -:  920:  /** You can use this from another thread, and/or while a query is executing
        -:  921:   * in a pipeline, but it's up to you to ensure that you're not canceling the
        -:  922:   * wrong query.  This may involve locking.
        -:  923:   */
        -:  924:  void cancel_query();
        -:  925:
        -:  926:#if defined(_WIN32) || __has_include(<fcntl.h>)
        -:  927:  /// Set socket to blocking (true) or nonblocking (false).
        -:  928:  /** @warning Do not use this unless you _really_ know what you're doing.
        -:  929:   * @warning This function is available on most systems, but not necessarily
        -:  930:   * all.
        -:  931:   */
        -:  932:  void set_blocking(bool block) &;
        -:  933:#endif // defined(_WIN32) || __has_include(<fcntl.h>)
        -:  934:
        -:  935:  /// Set session verbosity.
        -:  936:  /** Set the verbosity of error messages to "terse", "normal" (the default),
        -:  937:   * or "verbose."
        -:  938:   *
        -:  939:   *  If "terse", returned messages include severity, primary text, and
        -:  940:   * position only; this will normally fit on a single line. "normal" produces
        -:  941:   * messages that include the above plus any detail, hint, or context fields
        -:  942:   * (these might span multiple lines).  "verbose" includes all available
        -:  943:   * fields.
        -:  944:   */
        -:  945:  void set_verbosity(error_verbosity verbosity) & noexcept;
        -:  946:
        -:  947:  /// Return pointers to the active errorhandlers.
        -:  948:  /** The entries are ordered from oldest to newest handler.
        -:  949:   *
        -:  950:   * You may use this to find errorhandlers that your application wants to
        -:  951:   * delete when destroying the connection.  Be aware, however, that libpqxx
        -:  952:   * may also add errorhandlers of its own, and those will be included in the
        -:  953:   * list.  If this is a problem for you, derive your errorhandlers from a
        -:  954:   * custom base class derived from pqxx::errorhandler.  Then use dynamic_cast
        -:  955:   * to find which of the error handlers are yours.
        -:  956:   *
        -:  957:   * The pointers point to the real errorhandlers.  The container it returns
        -:  958:   * however is a copy of the one internal to the connection, not a reference.
        -:  959:   */
        -:  960:  [[nodiscard]] std::vector<errorhandler *> get_errorhandlers() const;
        -:  961:
        -:  962:  /// Return a connection string encapsulating this connection's options.
        -:  963:  /** The connection must be currently open for this to work.
        -:  964:   *
        -:  965:   * Returns a reconstruction of this connection's connection string.  It may
        -:  966:   * not exactly match the connection string you passed in when creating this
        -:  967:   * connection.
        -:  968:   */
        -:  969:  [[nodiscard]] std::string connection_string() const;
        -:  970:
        -:  971:  /// Explicitly close the connection.
        -:  972:  /** The destructor will do this for you automatically.  Still, there is a
        -:  973:   * reason to `close()` objects explicitly where possible: if an error should
        -:  974:   * occur while closing, `close()` can throw an exception.  A destructor
        -:  975:   * cannot.
        -:  976:   *
        -:  977:   * Closing a connection is idempotent.  Closing a connection that's already
        -:  978:   * closed does nothing.
        -:  979:   */
        -:  980:  void close();
        -:  981:
        -:  982:  /// Seize control of a raw libpq connection.
        -:  983:  /** @warning Do not do this.  Please.  It's for very rare, very specific
        -:  984:   * use-cases.  The mechanism may change (or break) in unexpected ways in
        -:  985:   * future versions.
        -:  986:   *
        -:  987:   * @param raw_conn a raw libpq `PQconn` pointer.
        -:  988:   */
        -:  989:  static connection seize_raw_connection(internal::pq::PGconn *raw_conn)
        -:  990:  {
        -:  991:    return connection{raw_conn};
        -:  992:  }
        -:  993:
        -:  994:  /// Release the raw connection without closing it.
        -:  995:  /** @warning Do not do this.  It's for very rare, very specific use-cases.
        -:  996:   * The mechanism may change (or break) in unexpected ways in future versions.
        -:  997:   *
        -:  998:   * The `connection` object becomes unusable after this.
        -:  999:   */
        -: 1000:  internal::pq::PGconn *release_raw_connection() &&
        -: 1001:  {
        -: 1002:    return std::exchange(m_conn, nullptr);
        -: 1003:  }
        -: 1004:
        -: 1005:  /// Set session variable, using SQL's `SET` command.
        -: 1006:  /** @deprecated To set a session variable, use @ref set_session_var.  To set
        -: 1007:   * a transaction-local variable, execute an SQL `SET` command.
        -: 1008:   *
        -: 1009:   * @warning When setting a string value, you must escape and quote it first.
        -: 1010:   * Use the @ref quote() function to do that.
        -: 1011:   *
        -: 1012:   * @warning This executes an SQL query, so do not get or set variables while
        -: 1013:   * a table stream or pipeline is active on the same connection.
        -: 1014:   *
        -: 1015:   * @param var Variable to set.
        -: 1016:   * @param value New value for Var.  This can be any SQL expression.  If it's
        -: 1017:   * a string, be sure that it's properly escaped and quoted.
        -: 1018:   */
        -: 1019:  [[deprecated("To set session variables, use set_session_var.")]] void
        -: 1020:  set_variable(std::string_view var, std::string_view value) &;
        -: 1021:
        -: 1022:  /// Read session variable, using SQL's `SHOW` command.
        -: 1023:  /** @warning This executes an SQL query, so do not get or set variables while
        -: 1024:   * a table stream or pipeline is active on the same connection.
        -: 1025:   */
        -: 1026:  [[deprecated("Use get_var instead.")]] std::string
        -: 1027:    get_variable(std::string_view);
        -: 1028:
        -: 1029:private:
        -: 1030:  friend class connecting;
        -: 1031:  enum connect_mode
        -: 1032:  {
        -: 1033:    connect_nonblocking
        -: 1034:  };
        -: 1035:  connection(connect_mode, zview connection_string);
        -: 1036:
        -: 1037:  /// For use by @ref seize_raw_connection.
        -: 1038:  explicit connection(internal::pq::PGconn *raw_conn) : m_conn{raw_conn} {}
        -: 1039:
        -: 1040:  /// Poll for ongoing connection, try to progress towards completion.
        -: 1041:  /** Returns a pair of "now please wait to read data from socket" and "now
        -: 1042:   * please wait to write data to socket."  Both will be false when done.
        -: 1043:   *
        -: 1044:   * Throws an exception if polling indicates that the connection has failed.
        -: 1045:   */
        -: 1046:  std::pair<bool, bool> poll_connect();
        -: 1047:
        -: 1048:  // Initialise based on connection string.
        -: 1049:  void init(char const options[]);
        -: 1050:  // Initialise based on parameter names and values.
        -: 1051:  void init(char const *params[], char const *values[]);
        -: 1052:  void complete_init();
        -: 1053:
        -: 1054:  result make_result(
        -: 1055:    internal::pq::PGresult *pgr, std::shared_ptr<std::string> const &query,
        -: 1056:    std::string_view desc = ""sv);
        -: 1057:
        -: 1058:  void PQXX_PRIVATE set_up_state();
        -: 1059:
        -: 1060:  int PQXX_PRIVATE PQXX_PURE status() const noexcept;
        -: 1061:
        -: 1062:  /// Escape a string, into a buffer allocated by the caller.
        -: 1063:  /** The buffer must have room for at least `2*std::size(text) + 1` bytes.
        -: 1064:   *
        -: 1065:   * Returns the number of bytes written, including the trailing zero.
        -: 1066:   */
        -: 1067:  std::size_t esc_to_buf(std::string_view text, char *buf) const;
        -: 1068:
        -: 1069:  friend class internal::gate::const_connection_largeobject;
        -: 1070:  char const *PQXX_PURE err_msg() const noexcept;
        -: 1071:
        -: 1072:  void PQXX_PRIVATE process_notice_raw(char const msg[]) noexcept;
        -: 1073:
        -: 1074:  result exec_prepared(std::string_view statement, internal::c_params const &);
        -: 1075:
        -: 1076:  /// Throw @ref usage_error if this connection is not in a movable state.
        -: 1077:  void check_movable() const;
        -: 1078:  /// Throw @ref usage_error if not in a state where it can be move-assigned.
        -: 1079:  void check_overwritable() const;
        -: 1080:
        -: 1081:  friend class internal::gate::connection_errorhandler;
        -: 1082:  void PQXX_PRIVATE register_errorhandler(errorhandler *);
        -: 1083:  void PQXX_PRIVATE unregister_errorhandler(errorhandler *) noexcept;
        -: 1084:
        -: 1085:  friend class internal::gate::connection_transaction;
        -: 1086:  result exec(std::string_view, std::string_view = ""sv);
        -: 1087:  result PQXX_PRIVATE
        -: 1088:  exec(std::shared_ptr<std::string> const &, std::string_view = ""sv);
        -: 1089:  void PQXX_PRIVATE register_transaction(transaction_base *);
        -: 1090:  void PQXX_PRIVATE unregister_transaction(transaction_base *) noexcept;
        -: 1091:
        -: 1092:  friend struct internal::gate::connection_stream_from;
        -: 1093:  /// Read a line of COPY output.
        -: 1094:  /** If the output indicates that the COPY has ended, the buffer pointer
        -: 1095:   * will be null and the size will be zero.  Otherwise, the pointer will hold
        -: 1096:   * a buffer containing the line, and size will be its length not including
        -: 1097:   * the newline at the end.
        -: 1098:   */
        -: 1099:  std::pair<std::unique_ptr<char, void (*)(void const *)>, std::size_t>
        -: 1100:  read_copy_line();
        -: 1101:
        -: 1102:  friend class internal::gate::connection_stream_to;
        -: 1103:  void PQXX_PRIVATE write_copy_line(std::string_view);
        -: 1104:  void PQXX_PRIVATE end_copy_write();
        -: 1105:
        -: 1106:  friend class internal::gate::connection_largeobject;
        -: 1107:  internal::pq::PGconn *raw_connection() const { return m_conn; }
        -: 1108:
        -: 1109:  friend class internal::gate::connection_notification_receiver;
        -: 1110:  void add_receiver(notification_receiver *);
        -: 1111:  void remove_receiver(notification_receiver *) noexcept;
        -: 1112:
        -: 1113:  friend class internal::gate::connection_pipeline;
        -: 1114:  void PQXX_PRIVATE start_exec(char const query[]);
        -: 1115:  bool PQXX_PRIVATE consume_input() noexcept;
        -: 1116:  bool PQXX_PRIVATE is_busy() const noexcept;
        -: 1117:  internal::pq::PGresult *get_result();
        -: 1118:
        -: 1119:  friend class internal::gate::connection_dbtransaction;
        -: 1120:  friend class internal::gate::connection_sql_cursor;
        -: 1121:
        -: 1122:  result exec_params(std::string_view query, internal::c_params const &args);
        -: 1123:
        -: 1124:  /// Connection handle.
       20: 1125:  internal::pq::PGconn *m_conn = nullptr;
        -: 1126:
        -: 1127:  /// Active transaction on connection, if any.
        -: 1128:  /** We don't use this for anything, except to check for open transactions
        -: 1129:   * when we close the connection or start a new transaction.
        -: 1130:   *
        -: 1131:   * We also don't allow move construction or move assignment while there's a
        -: 1132:   * transaction, since moving the connection in that case would leave one or
        -: 1133:   * more pointers back from the transaction to the connection dangling.
        -: 1134:   */
       20: 1135:  transaction_base const *m_trans = nullptr;
        -: 1136:
        -: 1137:  std::list<errorhandler *> m_errorhandlers;
        -: 1138:
        -: 1139:  using receiver_list =
        -: 1140:    std::multimap<std::string, pqxx::notification_receiver *>;
        -: 1141:  /// Notification receivers.
        -: 1142:  receiver_list m_receivers;
        -: 1143:
        -: 1144:  /// Unique number to use as suffix for identifiers (see adorn_name()).
       20: 1145:  int m_unique_id = 0;
        -: 1146:};
        -: 1147:
        -: 1148:
        -: 1149:/// @deprecated Old base class for connection.  They are now the same class.
        -: 1150:using connection_base = connection;
        -: 1151:
        -: 1152:
        -: 1153:/// An ongoing, non-blocking stepping stone to a connection.
        -: 1154:/** Use this when you want to create a connection to the database, but without
        -: 1155: * blocking your whole thread.   It is only available on systems that have
        -: 1156: * the `<fcntl.h>` header, and Windows.
        -: 1157: *
        -: 1158: * Connecting in this way is probably not "faster" (it's more complicated and
        -: 1159: * has some extra overhead), but in some situations you can use it to make your
        -: 1160: * application as a whole faster.  It all depends on having other useful work
        -: 1161: * to do in the same thread, and being able to wait on a socket.  If you have
        -: 1162: * other I/O going on at the same time, your event loop can wait for both the
        -: 1163: * libpqxx socket and your own sockets, and wake up whenever any of them is
        -: 1164: * ready to do work.
        -: 1165: *
        -: 1166: * Connecting in this way is not properly "asynchronous;" it's merely
        -: 1167: * "nonblocking."  This means it's not a super-high-performance mechanism like
        -: 1168: * you might get with e.g. `io_uring`.  In particular, if we need to look up
        -: 1169: * the database hostname in DNS, that will happen synchronously.
        -: 1170: *
        -: 1171: * To use this, create the `connecting` object, passing a connection string.
        -: 1172: * Then loop: If @ref wait_to_read returns true, wait for the socket to have
        -: 1173: * incoming data on it.  If @ref wait_to_write returns true, wait for the
        -: 1174: * socket to be ready for writing.  Then call @ref process to process any
        -: 1175: * incoming or outgoing data.  Do all of this until @ref done returns true (or
        -: 1176: * there is an exception).  Finally, call @ref produce to get the completed
        -: 1177: * connection.
        -: 1178: *
        -: 1179: * For example:
        -: 1180: *
        -: 1181: * ```cxx
        -: 1182: *     pqxx::connecting cg{};
        -: 1183: *
        -: 1184: *     // Loop until we're done connecting.
        -: 1185: *     while (!cg.done())
        -: 1186: *     {
        -: 1187: *         wait_for_fd(cg.sock(), cg.wait_to_read(), cg.wait_to_write());
        -: 1188: *         cg.process();
        -: 1189: *     }
        -: 1190: *
        -: 1191: *     pqxx::connection cx = std::move(cg).produce();
        -: 1192: *
        -: 1193: *     // At this point, cx is a working connection.  You can no longer use
        -: 1194: *     // cg at all.
        -: 1195: * ```
        -: 1196: */
        -: 1197:class PQXX_LIBEXPORT connecting
        -: 1198:{
        -: 1199:public:
        -: 1200:  /// Start connecting.
        -: 1201:  connecting(zview connection_string = ""_zv);
        -: 1202:
        -: 1203:  connecting(connecting const &) = delete;
        -: 1204:  connecting(connecting &&) = default;
        -: 1205:  connecting &operator=(connecting const &) = delete;
        -: 1206:  connecting &operator=(connecting &&) = default;
        -: 1207:
        -: 1208:  /// Get the socket.  The socket may change during the connection process.
        -: 1209:  [[nodiscard]] int sock() const & noexcept { return m_conn.sock(); }
        -: 1210:
        -: 1211:  /// Should we currently wait to be able to _read_ from the socket?
        -: 1212:  [[nodiscard]] constexpr bool wait_to_read() const & noexcept
        -: 1213:  {
        -: 1214:    return m_reading;
        -: 1215:  }
        -: 1216:
        -: 1217:  /// Should we currently wait to be able to _write_ to the socket?
        -: 1218:  [[nodiscard]] constexpr bool wait_to_write() const & noexcept
        -: 1219:  {
        -: 1220:    return m_writing;
        -: 1221:  }
        -: 1222:
        -: 1223:  /// Progress towards completion (but don't block).
        -: 1224:  void process() &;
        -: 1225:
        -: 1226:  /// Is our connection finished?
        -: 1227:  [[nodiscard]] constexpr bool done() const & noexcept
        -: 1228:  {
        -: 1229:    return not m_reading and not m_writing;
        -: 1230:  }
        -: 1231:
        -: 1232:  /// Produce the completed connection object.
        -: 1233:  /** Use this only once, after @ref done returned `true`.  Once you have
        -: 1234:   * called this, the `connecting` instance has no more use or meaning.  You
        -: 1235:   * can't call any of its member functions afterwards.
        -: 1236:   *
        -: 1237:   * This member function is rvalue-qualified, meaning that you can only call
        -: 1238:   * it on an rvalue instance of the class.  If what you have is not an rvalue,
        -: 1239:   * turn it into one by wrapping it in `std::move()`.
        -: 1240:   */
        -: 1241:  [[nodiscard]] connection produce() &&;
        -: 1242:
        -: 1243:private:
        -: 1244:  connection m_conn;
        -: 1245:  bool m_reading{false};
        -: 1246:  bool m_writing{true};
        -: 1247:};
        -: 1248:
        -: 1249:
function _ZNK4pqxx10connection5quoteINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEES7_RKT_ called 43 returned 100% blocks executed 50%
       43: 1250:template<typename T> inline std::string connection::quote(T const &t) const
        -: 1251:{
        -: 1252:  if constexpr (nullness<T>::always_null)
        -: 1253:  {
        -: 1254:    return "NULL";
        -: 1255:  }
        -: 1256:  else
        -: 1257:  {
       43: 1258:    if (is_null(t))
       43: 1258-block  0
branch  0 taken 43
branch  1 taken 0
    #####: 1259:      return "NULL";
    $$$$$: 1259-block  0
branch  0 never executed
branch  1 never executed
    $$$$$: 1259-block  1
    $$$$$: 1259-block  2
    $$$$$: 1259-block  3
       43: 1260:    auto const text{to_string(t)};
        -: 1261:
        -: 1262:    // Okay, there's an easy way to do this and there's a hard way.  The easy
        -: 1263:    // way was "quote, esc(to_string(t)), quote".  I'm going with the hard way
        -: 1264:    // because it's going to save some string manipulation that will probably
        -: 1265:    // incur some unnecessary memory allocations and deallocations.
       43: 1266:    std::string buf{'\''};
       43: 1266-block  0
branch  0 taken 43
branch  1 taken 0
    $$$$$: 1266-block  1
       43: 1267:    buf.resize(2 + 2 * std::size(text) + 1);
       43: 1267-block  0
branch  0 taken 43
branch  1 taken 0
       43: 1268:    auto const content_bytes{esc_to_buf(text, buf.data() + 1)};
       43: 1268-block  0
branch  0 taken 43
branch  1 taken 0
       43: 1269:    auto const closing_quote{1 + content_bytes};
       43: 1270:    buf[closing_quote] = '\'';
       43: 1271:    auto const end{closing_quote + 1};
       43: 1272:    buf.resize(end);
       43: 1272-block  0
branch  0 taken 43
branch  1 taken 0
       43: 1273:    return buf;
       43: 1274:  }
       43: 1274-block  0
branch  0 taken 43
branch  1 taken 0
    $$$$$: 1274-block  1
    $$$$$: 1274-block  2
       43: 1274-block  3
    $$$$$: 1274-block  4
       43: 1275:}
       43: 1275-block  0
        -: 1276:
        -: 1277:
        -: 1278:template<PQXX_CHAR_STRINGS_ARG STRINGS>
        -: 1279:inline std::string connection::quote_columns(STRINGS const &columns) const
        -: 1280:{
        -: 1281:  return separated_list(
        -: 1282:    ","sv, std::cbegin(columns), std::cend(columns),
        -: 1283:    [this](auto col) { return this->quote_name(*col); });
        -: 1284:}
        -: 1285:
        -: 1286:
        -: 1287:#if defined(PQXX_HAVE_CONCEPTS)
        -: 1288:template<internal::ZKey_ZValues MAPPING>
        -: 1289:inline connection::connection(MAPPING const &params)
        -: 1290:{
        -: 1291:  check_version();
        -: 1292:
        -: 1293:  std::vector<char const *> keys, values;
        -: 1294:  if constexpr (std::ranges::sized_range<MAPPING>)
        -: 1295:  {
        -: 1296:    auto const size{std::ranges::size(params) + 1};
        -: 1297:    keys.reserve(size);
        -: 1298:    values.reserve(size);
        -: 1299:  }
        -: 1300:  for (auto const &[key, value] : params)
        -: 1301:  {
        -: 1302:    keys.push_back(internal::as_c_string(key));
        -: 1303:    values.push_back(internal::as_c_string(value));
        -: 1304:  }
        -: 1305:  keys.push_back(nullptr);
        -: 1306:  values.push_back(nullptr);
        -: 1307:  init(std::data(keys), std::data(values));
        -: 1308:}
        -: 1309:#endif // PQXX_HAVE_CONCEPTS
        -: 1310:
        -: 1311:
        -: 1312:/// Encrypt a password.  @deprecated Use connection::encrypt_password instead.
        -: 1313:[[nodiscard,
        -: 1314:  deprecated("Use connection::encrypt_password instead.")]] std::string
        -: 1315:  PQXX_LIBEXPORT
        -: 1316:  encrypt_password(char const user[], char const password[]);
        -: 1317:
        -: 1318:/// Encrypt password.  @deprecated Use connection::encrypt_password instead.
        -: 1319:[[nodiscard,
        -: 1320:  deprecated("Use connection::encrypt_password instead.")]] inline std::string
        -: 1321:encrypt_password(zview user, zview password)
        -: 1322:{
        -: 1323:#include "pqxx/internal/ignore-deprecated-pre.hxx"
        -: 1324:  return encrypt_password(user.c_str(), password.c_str());
        -: 1325:#include "pqxx/internal/ignore-deprecated-post.hxx"
        -: 1326:}
        -: 1327:} // namespace pqxx
        -: 1328:#endif
