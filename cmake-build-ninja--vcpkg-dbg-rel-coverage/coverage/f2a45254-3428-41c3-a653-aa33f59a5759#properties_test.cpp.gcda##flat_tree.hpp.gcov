        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/boost/container/detail/flat_tree.hpp
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Organization_Properties.dir/organization/properties/properties_test.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Organization_Properties.dir/organization/properties/properties_test.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:////////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3:// (C) Copyright Ion Gaztanaga 2005-2015. Distributed under the Boost
        -:    4:// Software License, Version 1.0. (See accompanying file
        -:    5:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    6://
        -:    7:// See http://www.boost.org/libs/container for documentation.
        -:    8://
        -:    9:////////////////////////////////////////////////////////////////////////////////
        -:   10:
        -:   11:#ifndef BOOST_CONTAINER_FLAT_TREE_HPP
        -:   12:#define BOOST_CONTAINER_FLAT_TREE_HPP
        -:   13:
        -:   14:#ifndef BOOST_CONFIG_HPP
        -:   15:#  include <boost/config.hpp>
        -:   16:#endif
        -:   17:
        -:   18:#if defined(BOOST_HAS_PRAGMA_ONCE)
        -:   19:#  pragma once
        -:   20:#endif
        -:   21:
        -:   22:#include <boost/container/detail/config_begin.hpp>
        -:   23:#include <boost/container/detail/workaround.hpp>
        -:   24:
        -:   25:#include <boost/container/container_fwd.hpp>
        -:   26:
        -:   27:#include <boost/move/utility_core.hpp>
        -:   28:
        -:   29:#include <boost/container/detail/pair.hpp>
        -:   30:#include <boost/container/vector.hpp>
        -:   31:#include <boost/container/allocator_traits.hpp>
        -:   32:
        -:   33:#include <boost/container/detail/value_init.hpp>
        -:   34:#include <boost/container/detail/destroyers.hpp>
        -:   35:#include <boost/container/detail/algorithm.hpp> //algo_equal(), algo_lexicographical_compare
        -:   36:#include <boost/container/detail/iterator.hpp>
        -:   37:#include <boost/container/detail/is_sorted.hpp>
        -:   38:#include <boost/container/detail/type_traits.hpp>
        -:   39:#include <boost/container/detail/iterators.hpp>
        -:   40:#include <boost/container/detail/mpl.hpp>
        -:   41:#include <boost/container/detail/is_contiguous_container.hpp>
        -:   42:#include <boost/container/detail/is_container.hpp>
        -:   43:
        -:   44:#include <boost/intrusive/detail/minimal_pair_header.hpp>      //pair
        -:   45:
        -:   46:#include <boost/move/make_unique.hpp>
        -:   47:#include <boost/move/iterator.hpp>
        -:   48:#include <boost/move/adl_move_swap.hpp>
        -:   49:#include <boost/move/detail/iterator_to_raw_pointer.hpp>
        -:   50:#include <boost/move/detail/force_ptr.hpp>
        -:   51:#include <boost/move/algo/adaptive_sort.hpp>
        -:   52:#include <boost/move/algo/detail/pdqsort.hpp>
        -:   53:
        -:   54:#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:   55:#include <boost/move/detail/fwd_macros.hpp>
        -:   56:#endif
        -:   57:
        -:   58:#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:   59:
        -:   60:#if defined(BOOST_GCC) && (BOOST_GCC >= 40600)
        -:   61:#pragma GCC diagnostic push
        -:   62:#pragma GCC diagnostic ignored "-Wunused-result"
        -:   63:#endif
        -:   64:
        -:   65://merge_unique
        -:   66:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME merge_unique
        -:   67:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   68:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   69:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 3
        -:   70:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 3
        -:   71:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   72:
        -:   73://merge_equal
        -:   74:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME merge
        -:   75:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   76:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   77:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 3
        -:   78:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 3
        -:   79:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   80:
        -:   81://index_of
        -:   82:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME index_of
        -:   83:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   84:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   85:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 1
        -:   86:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 1
        -:   87:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   88:
        -:   89://nth
        -:   90:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME nth
        -:   91:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   92:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   93:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 1
        -:   94:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 1
        -:   95:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   96:
        -:   97://reserve
        -:   98:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME reserve
        -:   99:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:  100:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:  101:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 1
        -:  102:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 1
        -:  103:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:  104:
        -:  105://capacity
        -:  106:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME capacity
        -:  107:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:  108:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:  109:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 0
        -:  110:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 0
        -:  111:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:  112:
        -:  113:#if defined(BOOST_GCC) && (BOOST_GCC >= 40600)
        -:  114:#pragma GCC diagnostic pop
        -:  115:#endif
        -:  116:
        -:  117:
        -:  118:#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:  119:
        -:  120:namespace boost {
        -:  121:namespace container {
        -:  122:namespace dtl {
        -:  123:
        -:  124:///////////////////////////////////////
        -:  125://
        -:  126:// Helper functions to merge elements
        -:  127://
        -:  128:///////////////////////////////////////
        -:  129:
        -:  130:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(stored_allocator_type)
        -:  131:
        -:  132:///////////////////////////////////////
        -:  133://
        -:  134://  flat_tree_container_inplace_merge
        -:  135://
        -:  136:///////////////////////////////////////
        -:  137:template<class SequenceContainer, class Compare>
        -:  138:inline void flat_tree_container_inplace_merge //is_contiguous_container == true
        -:  139:   (SequenceContainer& dest, typename SequenceContainer::iterator it, Compare comp , dtl::true_)
        -:  140:{
        -:  141:   typedef typename SequenceContainer::value_type  value_type;
        -:  142:   value_type *const braw = boost::movelib::to_raw_pointer(dest.data());
        -:  143:   value_type *const iraw = boost::movelib::iterator_to_raw_pointer(it);
        -:  144:   //Don't use iterator_to_raw_pointer for end as debug iterators can assert when
        -:  145:   //"operator ->" is used with the end iterator
        -:  146:   value_type *const eraw = braw + dest.size();
        -:  147:   boost::movelib::adaptive_merge
        -:  148:      (braw, iraw, eraw, comp, eraw, back_free_capacity<SequenceContainer>::get(dest));
        -:  149:}
        -:  150:
        -:  151:template<class SequenceContainer, class Compare>
        -:  152:inline void flat_tree_container_inplace_merge //is_contiguous_container == false
        -:  153:   (SequenceContainer& dest, typename SequenceContainer::iterator it, Compare comp, dtl::false_)
        -:  154:{
        -:  155:   boost::movelib::adaptive_merge(dest.begin(), it, dest.end(), comp);
        -:  156:}
        -:  157:
        -:  158:///////////////////////////////////////
        -:  159://
        -:  160://  flat_tree_container_inplace_sort_ending
        -:  161://
        -:  162:///////////////////////////////////////
        -:  163:template<class SequenceContainer, class Compare>
        -:  164:inline void flat_tree_container_inplace_sort_ending //is_contiguous_container == true
        -:  165:   (SequenceContainer& dest, typename SequenceContainer::iterator it, Compare comp, dtl::true_)
        -:  166:{
        -:  167:   typedef typename SequenceContainer::value_type  value_type;
        -:  168:   value_type *const iraw = boost::movelib::iterator_to_raw_pointer(it);
        -:  169:   //Don't use iterator_to_raw_pointer for end as debug iterators can assert when
        -:  170:   //"operator ->" is used with the end iterator
        -:  171:   value_type* const eraw = boost::movelib::to_raw_pointer(dest.data()) + dest.size();
        -:  172:
        -:  173:
        -:  174:   boost::movelib::adaptive_sort
        -:  175:      (iraw, eraw, comp, eraw, back_free_capacity<SequenceContainer>::get(dest));
        -:  176:}
        -:  177:
        -:  178:template<class SequenceContainer, class Compare>
        -:  179:inline void flat_tree_container_inplace_sort_ending //is_contiguous_container == false
        -:  180:   (SequenceContainer& dest, typename SequenceContainer::iterator it, Compare comp , dtl::false_)
        -:  181:{
        -:  182:   boost::movelib::adaptive_sort(it, dest.end(), comp);
        -:  183:}
        -:  184:
        -:  185:///////////////////////////////////////
        -:  186://
        -:  187://          flat_tree_merge
        -:  188://
        -:  189:///////////////////////////////////////
        -:  190:template<class SequenceContainer, class Iterator, class Compare>
        -:  191:inline void flat_tree_merge_equal
        -:  192:   (SequenceContainer& dest, Iterator first, Iterator last, Compare comp, dtl::true_)
        -:  193:{
        -:  194:   dest.merge(first, last, comp);
        -:  195:}
        -:  196:
        -:  197:template<class SequenceContainer, class Iterator, class Compare>
        -:  198:inline void flat_tree_merge_equal   //has_merge_unique == false
        -:  199:   (SequenceContainer& dest, Iterator first, Iterator last, Compare comp, dtl::false_)
        -:  200:{
        -:  201:   if(first != last) {
        -:  202:      typedef typename SequenceContainer::iterator    iterator;
        -:  203:      iterator const it = dest.insert( dest.end(), first, last );
        -:  204:      dtl::bool_<is_contiguous_container<SequenceContainer>::value> contiguous_tag;
        -:  205:      (flat_tree_container_inplace_merge)(dest, it, comp, contiguous_tag);
        -:  206:   }
        -:  207:}
        -:  208:
        -:  209:///////////////////////////////////////
        -:  210://
        -:  211://       flat_tree_merge_unique
        -:  212://
        -:  213:///////////////////////////////////////
        -:  214:template<class SequenceContainer, class Iterator, class Compare>
        -:  215:inline void flat_tree_merge_unique  //has_merge_unique == true
        -:  216:   (SequenceContainer& dest, Iterator first, Iterator last, Compare comp, dtl::true_)
        -:  217:{
        -:  218:   dest.merge_unique(first, last, comp);
        -:  219:}
        -:  220:
        -:  221:template<class SequenceContainer, class Iterator, class Compare>
        -:  222:inline void flat_tree_merge_unique  //has_merge_unique == false
        -:  223:   (SequenceContainer& dest, Iterator first, Iterator last, Compare comp, dtl::false_)
        -:  224:{
        -:  225:   if (first != last) {
        -:  226:      typedef typename SequenceContainer::iterator          iterator;
        -:  227:      typedef typename SequenceContainer::size_type         size_type;
        -:  228:      typedef typename SequenceContainer::difference_type   difference_type;
        -:  229:
        -:  230:      size_type const old_sz = dest.size();
        -:  231:      iterator const first_new = dest.insert(dest.cend(), first, last );
        -:  232:      iterator e = boost::movelib::inplace_set_unique_difference(first_new, dest.end(), dest.begin(), first_new, comp);
        -:  233:      dest.erase(e, dest.end());
        -:  234:      dtl::bool_<is_contiguous_container<SequenceContainer>::value> contiguous_tag;
        -:  235:      (flat_tree_container_inplace_merge)(dest, dest.begin() + difference_type(old_sz), comp, contiguous_tag);
        -:  236:   }
        -:  237:}
        -:  238:
        -:  239:///////////////////////////////////////
        -:  240://
        -:  241://         flat_tree_index_of
        -:  242://
        -:  243:///////////////////////////////////////
        -:  244:template<class SequenceContainer, class Iterator>
        -:  245:inline typename SequenceContainer::size_type
        -:  246:   flat_tree_index_of   // has_index_of == true
        -:  247:      (SequenceContainer& cont, Iterator p, dtl::true_)
        -:  248:{
        -:  249:   return cont.index_of(p);
        -:  250:}
        -:  251:
        -:  252:template<class SequenceContainer, class Iterator>
        -:  253:inline typename SequenceContainer::size_type
        -:  254:   flat_tree_index_of   // has_index_of == false
        -:  255:      (SequenceContainer& cont, Iterator p, dtl::false_)
        -:  256:{
        -:  257:   typedef typename SequenceContainer::size_type size_type;
        -:  258:   return static_cast<size_type>(p - cont.begin());
        -:  259:}
        -:  260:
        -:  261:///////////////////////////////////////
        -:  262://
        -:  263://         flat_tree_nth
        -:  264://
        -:  265:///////////////////////////////////////
        -:  266:template<class Iterator, class SequenceContainer>
        -:  267:inline Iterator
        -:  268:   flat_tree_nth  // has_nth == true
        -:  269:      (SequenceContainer& cont, typename SequenceContainer::size_type n, dtl::true_)
        -:  270:{
        -:  271:   return cont.nth(n);
        -:  272:}
        -:  273:
        -:  274:template<class Iterator, class SequenceContainer>
        -:  275:inline Iterator
        -:  276:   flat_tree_nth  // has_nth == false
        -:  277:      (SequenceContainer& cont, typename SequenceContainer::size_type n, dtl::false_)
        -:  278:{
        -:  279:   return cont.begin()+ typename SequenceContainer::difference_type(n);
        -:  280:}
        -:  281:
        -:  282:///////////////////////////////////////
        -:  283://
        -:  284://    flat_tree_get_stored_allocator
        -:  285://
        -:  286:///////////////////////////////////////
        -:  287:template<class SequenceContainer>
        -:  288:inline typename SequenceContainer::stored_allocator_type &
function _ZN5boost9container3dtl30flat_tree_get_stored_allocatorINS0_6vectorINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS0_13new_allocatorISG_EEvEEEERNT_21stored_allocator_typeERSK_NS_11move_detail5bool_ILb1EEE called 4 returned 100% blocks executed 100%
        4:  289:   flat_tree_get_stored_allocator   // has_get_stored_allocator == true
        -:  290:      (SequenceContainer& cont, dtl::true_)
        -:  291:{
        4:  292:   return cont.get_stored_allocator();
        4:  292-block  0
        -:  293:}
        -:  294:
        -:  295:template<class SequenceContainer>
        -:  296:inline const typename SequenceContainer::stored_allocator_type &
        -:  297:   flat_tree_get_stored_allocator   // has_get_stored_allocator == true
        -:  298:      (const SequenceContainer& cont, dtl::true_)
        -:  299:{
        -:  300:   return cont.get_stored_allocator();
        -:  301:}
        -:  302:
        -:  303:template<class SequenceContainer>
        -:  304:inline typename SequenceContainer::allocator_type
        -:  305:   flat_tree_get_stored_allocator   // has_get_stored_allocator == false
        -:  306:      (SequenceContainer& cont, dtl::false_)
        -:  307:{
        -:  308:   return cont.get_allocator();
        -:  309:}
        -:  310:
        -:  311:///////////////////////////////////////
        -:  312://
        -:  313://    flat_tree_adopt_sequence_equal
        -:  314://
        -:  315:///////////////////////////////////////
        -:  316:template<class SequenceContainer, class Compare>
        -:  317:void flat_tree_sort_contiguous_to_adopt // is_contiguous_container == true
        -:  318:   (SequenceContainer &tseq, BOOST_RV_REF(SequenceContainer) seq, Compare comp)
        -:  319:{
        -:  320:   if(tseq.capacity() >= (seq.capacity() - seq.size())) {
        -:  321:      tseq.clear();
        -:  322:      boost::movelib::adaptive_sort
        -:  323:      (boost::movelib::iterator_to_raw_pointer(seq.begin())
        -:  324:         , boost::movelib::iterator_to_raw_pointer(seq.end())
        -:  325:         , comp
        -:  326:         , boost::movelib::iterator_to_raw_pointer(tseq.begin())
        -:  327:         , tseq.capacity());
        -:  328:   }
        -:  329:   else{
        -:  330:      boost::movelib::adaptive_sort
        -:  331:      (boost::movelib::iterator_to_raw_pointer(seq.begin())
        -:  332:         , boost::movelib::iterator_to_raw_pointer(seq.end())
        -:  333:         , comp
        -:  334:         , boost::movelib::iterator_to_raw_pointer(seq.end())
        -:  335:         , seq.capacity() - seq.size());
        -:  336:   }
        -:  337:}
        -:  338:
        -:  339:template<class SequenceContainer, class Compare>
        -:  340:inline void flat_tree_adopt_sequence_equal // is_contiguous_container == true
        -:  341:   (SequenceContainer &tseq, BOOST_RV_REF(SequenceContainer) seq, Compare comp, dtl::true_)
        -:  342:{
        -:  343:   flat_tree_sort_contiguous_to_adopt(tseq, boost::move(seq), comp);
        -:  344:   tseq = boost::move(seq);
        -:  345:}
        -:  346:
        -:  347:template<class SequenceContainer, class Compare>
        -:  348:inline void flat_tree_adopt_sequence_equal // is_contiguous_container == false
        -:  349:   (SequenceContainer &tseq, BOOST_RV_REF(SequenceContainer) seq, Compare comp, dtl::false_)
        -:  350:{
        -:  351:   boost::movelib::adaptive_sort(seq.begin(), seq.end(), comp);
        -:  352:   tseq = boost::move(seq);
        -:  353:}
        -:  354:
        -:  355:///////////////////////////////////////
        -:  356://
        -:  357://    flat_tree_adopt_sequence_unique
        -:  358://
        -:  359:///////////////////////////////////////
        -:  360:template<class SequenceContainer, class Compare>
        -:  361:void flat_tree_adopt_sequence_unique// is_contiguous_container == true
        -:  362:   (SequenceContainer &tseq, BOOST_RV_REF(SequenceContainer) seq, Compare comp, dtl::true_)
        -:  363:{
        -:  364:   boost::movelib::pdqsort
        -:  365:      ( boost::movelib::iterator_to_raw_pointer(seq.begin())
        -:  366:      , boost::movelib::iterator_to_raw_pointer(seq.end())
        -:  367:      , comp);
        -:  368:   seq.erase(boost::movelib::unique
        -:  369:      (seq.begin(), seq.end(), boost::movelib::negate<Compare>(comp)), seq.cend());
        -:  370:   tseq = boost::move(seq);
        -:  371:}
        -:  372:
        -:  373:template<class SequenceContainer, class Compare>
        -:  374:void flat_tree_adopt_sequence_unique// is_contiguous_container == false
        -:  375:   (SequenceContainer &tseq, BOOST_RV_REF(SequenceContainer) seq, Compare comp, dtl::false_)
        -:  376:{
        -:  377:   boost::movelib::pdqsort(seq.begin(), seq.end(), comp);
        -:  378:   seq.erase(boost::movelib::unique
        -:  379:      (seq.begin(), seq.end(), boost::movelib::negate<Compare>(comp)), seq.cend());
        -:  380:   tseq = boost::move(seq);
        -:  381:}
        -:  382:
        -:  383:///////////////////////////////////////
        -:  384://
        -:  385://       flat_tree_reserve
        -:  386://
        -:  387:///////////////////////////////////////
        -:  388:template<class SequenceContainer>
        -:  389:inline void // has_reserve == true
        -:  390:   flat_tree_reserve(SequenceContainer &tseq, typename SequenceContainer::size_type cap, dtl::true_)
        -:  391:{
        -:  392:   tseq.reserve(cap);
        -:  393:}
        -:  394:
        -:  395:template<class SequenceContainer>
        -:  396:inline void // has_reserve == false
        -:  397:   flat_tree_reserve(SequenceContainer &, typename SequenceContainer::size_type, dtl::false_)
        -:  398:{
        -:  399:}
        -:  400:
        -:  401:///////////////////////////////////////
        -:  402://
        -:  403://       flat_tree_capacity
        -:  404://
        -:  405:///////////////////////////////////////
        -:  406:template<class SequenceContainer>   // has_capacity == true
        -:  407:inline typename SequenceContainer::size_type
        -:  408:   flat_tree_capacity(const SequenceContainer &tseq, dtl::true_)
        -:  409:{
        -:  410:   return tseq.capacity();
        -:  411:}
        -:  412:
        -:  413:template<class SequenceContainer>   // has_capacity == false
        -:  414:inline typename SequenceContainer::size_type
        -:  415:   flat_tree_capacity(const SequenceContainer &tseq, dtl::false_)
        -:  416:{
        -:  417:   return tseq.size();
        -:  418:}
        -:  419:
        -:  420:///////////////////////////////////////
        -:  421://
        -:  422://       flat_tree_value_compare
        -:  423://
        -:  424:///////////////////////////////////////
        -:  425:
        -:  426:template<class Compare, class Value, class KeyOfValue>
        -:  427:class flat_tree_value_compare
        -:  428:   : private Compare
        -:  429:{
        -:  430:   typedef Value              first_argument_type;
        -:  431:   typedef Value              second_argument_type;
        -:  432:   typedef bool               return_type;
        -:  433:   public:
function _ZN5boost9container3dtl23flat_tree_value_compareISt4lessINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEENS1_4pairIS9_St10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EEEC2Ev called 4 returned 100% blocks executed 100%
        4:  434:   inline flat_tree_value_compare()
        -:  435:      : Compare()
        4:  436:   {}
        4:  436-block  0
        -:  437:
        -:  438:   inline flat_tree_value_compare(const Compare &pred)
        -:  439:      : Compare(pred)
        -:  440:   {}
        -:  441:
        -:  442:   inline bool operator()(const Value& lhs, const Value& rhs) const
        -:  443:   {
        -:  444:      KeyOfValue key_extract;
        -:  445:      return Compare::operator()(key_extract(lhs), key_extract(rhs));
        -:  446:   }
        -:  447:
function _ZNK5boost9container3dtl23flat_tree_value_compareISt4lessINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEENS1_4pairIS9_St10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EEE8get_compEv called 11 returned 100% blocks executed 100%
       11:  448:   inline const Compare &get_comp() const
       11:  449:      {  return *this;  }
       11:  449-block  0
        -:  450:
function _ZN5boost9container3dtl23flat_tree_value_compareISt4lessINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEENS1_4pairIS9_St10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EEE8get_compEv called 4 returned 100% blocks executed 100%
        4:  451:   inline Compare &get_comp()
        4:  452:      {  return *this;  }
        4:  452-block  0
        -:  453:};
        -:  454:
        -:  455:
        -:  456:///////////////////////////////////////
        -:  457://
        -:  458://       select_container_type
        -:  459://
        -:  460:///////////////////////////////////////
        -:  461:template < class Value, class AllocatorOrContainer
        -:  462:         , bool = boost::container::dtl::is_container<AllocatorOrContainer>::value
        -:  463:         >
        -:  464:struct select_container_type
        -:  465:{
        -:  466:   typedef AllocatorOrContainer type;
        -:  467:};
        -:  468:
        -:  469:template <class Value, class AllocatorOrContainer>
        -:  470:struct select_container_type<Value, AllocatorOrContainer, false>
        -:  471:{
        -:  472:   typedef boost::container::vector<Value, typename real_allocator<Value, AllocatorOrContainer>::type> type;
        -:  473:};
        -:  474:
        -:  475:
        -:  476:///////////////////////////////////////
        -:  477://
        -:  478://          flat_tree
        -:  479://
        -:  480:///////////////////////////////////////
        -:  481:template <class Value, class KeyOfValue,
        -:  482:          class Compare, class AllocatorOrContainer>
        -:  483:class flat_tree
        -:  484:{
        -:  485:   public:
        -:  486:   typedef typename select_container_type<Value, AllocatorOrContainer>::type container_type;
        -:  487:   typedef container_type sequence_type;  //For backwards compatibility
        -:  488:
        -:  489:   private:
        -:  490:   typedef typename container_type::allocator_type        allocator_t;
        -:  491:   typedef allocator_traits<allocator_t>                 allocator_traits_type;
        -:  492:
        -:  493:   public:
        -:  494:   typedef flat_tree_value_compare<Compare, Value, KeyOfValue> value_compare;
        -:  495:
        -:  496:   private:
        -:  497:   
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE4DataD2Ev called 4 returned 100% blocks executed 100%
        -:  498:   struct Data
        -:  499:      //Inherit from value_compare to do EBO
        -:  500:      : public value_compare
        -:  501:   {
        -:  502:      BOOST_COPYABLE_AND_MOVABLE(Data)
        -:  503:
        -:  504:      public:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE4DataC2Ev called 4 returned 100% blocks executed 100%
        4:  505:      inline Data()
        4:  506:         : value_compare(), m_seq()
        4:  507:      {}
        4:  507-block  0
        -:  508:
        -:  509:      inline explicit Data(const allocator_t &alloc)
        -:  510:         : value_compare(), m_seq(alloc)
        -:  511:      {}
        -:  512:
        -:  513:      inline explicit Data(const Compare &comp)
        -:  514:         : value_compare(comp), m_seq()
        -:  515:      {}
        -:  516:
        -:  517:      inline Data(const Compare &comp, const allocator_t &alloc)
        -:  518:         : value_compare(comp), m_seq(alloc)
        -:  519:      {}
        -:  520:
        -:  521:      inline explicit Data(const Data &d)
        -:  522:         : value_compare(static_cast<const value_compare&>(d)), m_seq(d.m_seq)
        -:  523:      {}
        -:  524:
        -:  525:      inline Data(BOOST_RV_REF(Data) d)
        -:  526:         : value_compare(boost::move(static_cast<value_compare&>(d))), m_seq(boost::move(d.m_seq))
        -:  527:      {}
        -:  528:
        -:  529:      inline Data(const Data &d, const allocator_t &a)
        -:  530:         : value_compare(static_cast<const value_compare&>(d)), m_seq(d.m_seq, a)
        -:  531:      {}
        -:  532:
        -:  533:      inline Data(BOOST_RV_REF(Data) d, const allocator_t &a)
        -:  534:         : value_compare(boost::move(static_cast<value_compare&>(d))), m_seq(boost::move(d.m_seq), a)
        -:  535:      {}
        -:  536:
        -:  537:      Data& operator=(BOOST_COPY_ASSIGN_REF(Data) d)
        -:  538:      {
        -:  539:         this->value_compare::operator=(d);
        -:  540:         m_seq = d.m_seq;
        -:  541:         return *this;
        -:  542:      }
        -:  543:
        -:  544:      Data& operator=(BOOST_RV_REF(Data) d)
        -:  545:      {
        -:  546:         this->value_compare::operator=(boost::move(static_cast<value_compare &>(d)));
        -:  547:         m_seq = boost::move(d.m_seq);
        -:  548:         return *this;
        -:  549:      }
        -:  550:
        -:  551:      void swap(Data &d)
        -:  552:      {
        -:  553:         value_compare& mycomp    = *this, & othercomp = d;
        -:  554:         boost::adl_move_swap(mycomp, othercomp);
        -:  555:         this->m_seq.swap(d.m_seq);
        -:  556:      }
        -:  557:
        -:  558:      container_type m_seq;
        -:  559:   };
        -:  560:
        -:  561:   Data m_data;
        -:  562:   BOOST_COPYABLE_AND_MOVABLE(flat_tree)
        -:  563:
        -:  564:   public:
        -:  565:
        -:  566:   typedef typename container_type::value_type               value_type;
        -:  567:   typedef typename container_type::pointer                  pointer;
        -:  568:   typedef typename container_type::const_pointer            const_pointer;
        -:  569:   typedef typename container_type::reference                reference;
        -:  570:   typedef typename container_type::const_reference          const_reference;
        -:  571:   typedef typename KeyOfValue::type                        key_type;
        -:  572:   typedef Compare                                          key_compare;
        -:  573:   typedef typename container_type::allocator_type           allocator_type;
        -:  574:   typedef typename container_type::size_type                size_type;
        -:  575:   typedef typename container_type::difference_type          difference_type;
        -:  576:   typedef typename container_type::iterator                 iterator;
        -:  577:   typedef typename container_type::const_iterator           const_iterator;
        -:  578:   typedef typename container_type::reverse_iterator         reverse_iterator;
        -:  579:   typedef typename container_type::const_reverse_iterator   const_reverse_iterator;
        -:  580:
        -:  581:   //!Standard extension
        -:  582:   typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT
        -:  583:      (boost::container::dtl::, container_type
        -:  584:      ,stored_allocator_type, allocator_type)               stored_allocator_type;
        -:  585:
        -:  586:   static const bool has_stored_allocator_type =
        -:  587:      BOOST_INTRUSIVE_HAS_TYPE(boost::container::dtl::, container_type, stored_allocator_type);
        -:  588:
        -:  589:   private:
        -:  590:   typedef allocator_traits<stored_allocator_type> stored_allocator_traits;
        -:  591:
        -:  592:   public:
        -:  593:   typedef typename dtl::if_c
        -:  594:      <has_stored_allocator_type, const stored_allocator_type &, allocator_type>::type get_stored_allocator_const_return_t;
        -:  595:
        -:  596:   typedef typename dtl::if_c
        -:  597:      <has_stored_allocator_type, stored_allocator_type &, allocator_type>::type get_stored_allocator_noconst_return_t;
        -:  598:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEEC2Ev called 4 returned 100% blocks executed 100%
        4:  599:   inline flat_tree()
        4:  600:      : m_data()
        4:  601:   { }
        4:  601-block  0
        -:  602:
        -:  603:   inline explicit flat_tree(const Compare& comp)
        -:  604:      : m_data(comp)
        -:  605:   { }
        -:  606:
        -:  607:   inline explicit flat_tree(const allocator_type& a)
        -:  608:      : m_data(a)
        -:  609:   { }
        -:  610:
        -:  611:   inline flat_tree(const Compare& comp, const allocator_type& a)
        -:  612:      : m_data(comp, a)
        -:  613:   { }
        -:  614:
        -:  615:   inline flat_tree(const flat_tree& x)
        -:  616:      :  m_data(x.m_data)
        -:  617:   { }
        -:  618:
        -:  619:   inline flat_tree(BOOST_RV_REF(flat_tree) x)
        -:  620:      BOOST_NOEXCEPT_IF(boost::container::dtl::is_nothrow_move_constructible<Compare>::value)
        -:  621:      :  m_data(boost::move(x.m_data))
        -:  622:   { }
        -:  623:
        -:  624:   inline flat_tree(const flat_tree& x, const allocator_type &a)
        -:  625:      :  m_data(x.m_data, a)
        -:  626:   { }
        -:  627:
        -:  628:   inline flat_tree(BOOST_RV_REF(flat_tree) x, const allocator_type &a)
        -:  629:      :  m_data(boost::move(x.m_data), a)
        -:  630:   { }
        -:  631:
        -:  632:   template <class InputIterator>
        -:  633:   inline
        -:  634:   flat_tree( ordered_range_t, InputIterator first, InputIterator last)
        -:  635:      : m_data()
        -:  636:   {
        -:  637:      this->m_data.m_seq.insert(this->m_data.m_seq.end(), first, last);
        -:  638:      BOOST_ASSERT((is_sorted)(this->m_data.m_seq.cbegin(), this->m_data.m_seq.cend(), this->priv_value_comp()));
        -:  639:   }
        -:  640:
        -:  641:   template <class InputIterator>
        -:  642:   inline
        -:  643:   flat_tree( ordered_range_t, InputIterator first, InputIterator last, const Compare& comp)
        -:  644:      : m_data(comp)
        -:  645:   {
        -:  646:      this->m_data.m_seq.insert(this->m_data.m_seq.end(), first, last);
        -:  647:      BOOST_ASSERT((is_sorted)(this->m_data.m_seq.cbegin(), this->m_data.m_seq.cend(), this->priv_value_comp()));
        -:  648:   }
        -:  649:
        -:  650:   template <class InputIterator>
        -:  651:   inline
        -:  652:   flat_tree( ordered_range_t, InputIterator first, InputIterator last, const Compare& comp, const allocator_type& a)
        -:  653:      : m_data(comp, a)
        -:  654:   {
        -:  655:      this->m_data.m_seq.insert(this->m_data.m_seq.end(), first, last);
        -:  656:      BOOST_ASSERT((is_sorted)(this->m_data.m_seq.cbegin(), this->m_data.m_seq.cend(), this->priv_value_comp()));
        -:  657:   }
        -:  658:
        -:  659:   template <class InputIterator>
        -:  660:   inline
        -:  661:   flat_tree( ordered_unique_range_t, InputIterator first, InputIterator last)
        -:  662:      : m_data()
        -:  663:   {
        -:  664:      this->m_data.m_seq.insert(this->m_data.m_seq.end(), first, last);
        -:  665:      BOOST_ASSERT((is_sorted_and_unique)(this->m_data.m_seq.cbegin(), this->m_data.m_seq.cend(), this->priv_value_comp()));
        -:  666:   }
        -:  667:
        -:  668:   template <class InputIterator>
        -:  669:   inline
        -:  670:   flat_tree( ordered_unique_range_t, InputIterator first, InputIterator last, const Compare& comp)
        -:  671:      : m_data(comp)
        -:  672:   {
        -:  673:      this->m_data.m_seq.insert(this->m_data.m_seq.end(), first, last);
        -:  674:      BOOST_ASSERT((is_sorted_and_unique)(this->m_data.m_seq.cbegin(), this->m_data.m_seq.cend(), this->priv_value_comp()));
        -:  675:   }
        -:  676:
        -:  677:   template <class InputIterator>
        -:  678:   inline
        -:  679:   flat_tree( ordered_unique_range_t, InputIterator first, InputIterator last, const Compare& comp, const allocator_type& a)
        -:  680:      : m_data(comp, a)
        -:  681:   {
        -:  682:      this->m_data.m_seq.insert(this->m_data.m_seq.end(), first, last);
        -:  683:      BOOST_ASSERT((is_sorted_and_unique)(this->m_data.m_seq.cbegin(), this->m_data.m_seq.cend(), this->priv_value_comp()));
        -:  684:   }
        -:  685:
        -:  686:   template <class InputIterator>
        -:  687:   inline
        -:  688:   flat_tree( bool unique_insertion, InputIterator first, InputIterator last)
        -:  689:      : m_data()
        -:  690:   {
        -:  691:      this->priv_range_insertion_construct(unique_insertion, first, last);
        -:  692:   }
        -:  693:
        -:  694:   template <class InputIterator>
        -:  695:   inline
        -:  696:   flat_tree( bool unique_insertion, InputIterator first, InputIterator last
        -:  697:            , const Compare& comp)
        -:  698:      : m_data(comp)
        -:  699:   {
        -:  700:      this->priv_range_insertion_construct(unique_insertion, first, last);
        -:  701:   }
        -:  702:
        -:  703:   template <class InputIterator>
        -:  704:   inline
        -:  705:   flat_tree( bool unique_insertion, InputIterator first, InputIterator last
        -:  706:            , const allocator_type& a)
        -:  707:      : m_data(a)
        -:  708:   {
        -:  709:      this->priv_range_insertion_construct(unique_insertion, first, last);
        -:  710:   }
        -:  711:
        -:  712:   template <class InputIterator>
        -:  713:   inline
        -:  714:   flat_tree( bool unique_insertion, InputIterator first, InputIterator last
        -:  715:            , const Compare& comp, const allocator_type& a)
        -:  716:      : m_data(comp, a)
        -:  717:   {
        -:  718:      this->priv_range_insertion_construct(unique_insertion, first, last);
        -:  719:   }
        -:  720:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEED2Ev called 4 returned 100% blocks executed 100%
        4:  721:   inline ~flat_tree()
        4:  722:   {}
        4:  722-block  0
        -:  723:
        -:  724:   inline flat_tree&  operator=(BOOST_COPY_ASSIGN_REF(flat_tree) x)
        -:  725:   {  m_data = x.m_data;   return *this;  }
        -:  726:
        -:  727:   inline flat_tree&  operator=(BOOST_RV_REF(flat_tree) x)
        -:  728:      BOOST_NOEXCEPT_IF( (allocator_traits_type::propagate_on_container_move_assignment::value ||
        -:  729:                          allocator_traits_type::is_always_equal::value) &&
        -:  730:                           boost::container::dtl::is_nothrow_move_assignable<Compare>::value)
        -:  731:   {  m_data = boost::move(x.m_data); return *this;  }
        -:  732:
        -:  733:   inline const value_compare &priv_value_comp() const
        -:  734:   { return static_cast<const value_compare &>(this->m_data); }
        -:  735:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE15priv_value_compEv called 4 returned 100% blocks executed 100%
        4:  736:   inline value_compare &priv_value_comp()
        4:  737:   { return static_cast<value_compare &>(this->m_data); }
        4:  737-block  0
        -:  738:
        -:  739:   inline const key_compare &priv_key_comp() const
        -:  740:   { return this->priv_value_comp().get_comp(); }
        -:  741:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE13priv_key_compEv called 4 returned 100% blocks executed 100%
        4:  742:   inline key_compare &priv_key_comp()
        4:  743:   { return this->priv_value_comp().get_comp(); }
        4:  743-block  0
        -:  744:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE18insert_commit_dataC2Ev called 4 returned 100% blocks executed 100%
        -:  745:   struct insert_commit_data
        -:  746:   {
        -:  747:      const_iterator position;
        -:  748:   };
        -:  749:
        -:  750:   public:
        -:  751:   // accessors:
        -:  752:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE8key_compEv called 0 returned 0% blocks executed 0%
    #####:  753:      Compare key_comp() const
    #####:  754:   { return this->m_data.get_comp(); }
    $$$$$:  754-block  0
        -:  755:
        -:  756:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  757:      value_compare value_comp() const
        -:  758:   { return this->m_data; }
        -:  759:
        -:  760:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  761:      allocator_type get_allocator() const
        -:  762:   { return this->m_data.m_seq.get_allocator(); }
        -:  763:
        -:  764:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  765:      get_stored_allocator_const_return_t get_stored_allocator() const
        -:  766:   {
        -:  767:      return flat_tree_get_stored_allocator(this->m_data.m_seq, dtl::bool_<has_stored_allocator_type>());
        -:  768:   }
        -:  769:
        -:  770:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE20get_stored_allocatorEv called 4 returned 100% blocks executed 100%
        4:  771:      get_stored_allocator_noconst_return_t get_stored_allocator()
        -:  772:   {
        4:  773:      return flat_tree_get_stored_allocator(this->m_data.m_seq, dtl::bool_<has_stored_allocator_type>());
        4:  773-block  0
        -:  774:   }
        -:  775:
        -:  776:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE5beginEv called 4 returned 100% blocks executed 100%
        4:  777:      iterator begin()
        4:  778:   { return this->m_data.m_seq.begin(); }
        4:  778-block  0
        -:  779:
        -:  780:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE5beginEv called 5 returned 100% blocks executed 100%
        5:  781:      const_iterator begin() const
        5:  782:   { return this->cbegin(); }
        5:  782-block  0
        -:  783:
        -:  784:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE6cbeginEv called 13 returned 100% blocks executed 100%
       13:  785:      const_iterator cbegin() const
       13:  786:   { return this->m_data.m_seq.begin(); }
       13:  786-block  0
        -:  787:
        -:  788:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE3endEv called 8 returned 100% blocks executed 100%
        8:  789:      iterator end()
        8:  790:   { return this->m_data.m_seq.end(); }
        8:  790-block  0
        -:  791:
        -:  792:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE3endEv called 8 returned 100% blocks executed 100%
        8:  793:      const_iterator end() const
        8:  794:   { return this->cend(); }
        8:  794-block  0
        -:  795:
        -:  796:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE4cendEv called 21 returned 100% blocks executed 100%
       21:  797:      const_iterator cend() const
       21:  798:   { return this->m_data.m_seq.end(); }
       21:  798-block  0
        -:  799:
        -:  800:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  801:      reverse_iterator rbegin()
        -:  802:   { return reverse_iterator(this->end()); }
        -:  803:
        -:  804:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  805:      const_reverse_iterator rbegin() const
        -:  806:   {  return this->crbegin();  }
        -:  807:
        -:  808:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  809:      const_reverse_iterator crbegin() const
        -:  810:   {  return const_reverse_iterator(this->cend());  }
        -:  811:
        -:  812:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  813:      reverse_iterator rend()
        -:  814:   { return reverse_iterator(this->begin()); }
        -:  815:
        -:  816:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  817:      const_reverse_iterator rend() const
        -:  818:   { return this->crend(); }
        -:  819:
        -:  820:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  821:      const_reverse_iterator crend() const
        -:  822:   { return const_reverse_iterator(this->cbegin()); }
        -:  823:
        -:  824:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  825:      bool empty() const
        -:  826:   { return this->m_data.m_seq.empty(); }
        -:  827:
        -:  828:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  829:      size_type size() const
        -:  830:   { return this->m_data.m_seq.size(); }
        -:  831:
        -:  832:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -:  833:      size_type max_size() const
        -:  834:   { return this->m_data.m_seq.max_size(); }
        -:  835:
        -:  836:   inline void swap(flat_tree& other)
        -:  837:      BOOST_NOEXCEPT_IF(  allocator_traits_type::is_always_equal::value
        -:  838:                                 && boost::container::dtl::is_nothrow_swappable<Compare>::value )
        -:  839:   {  this->m_data.swap(other.m_data);  }
        -:  840:
        -:  841:   public:
        -:  842:   // insert/erase
        -:  843:   std::pair<iterator,bool> insert_unique(const value_type& val)
        -:  844:   {
        -:  845:      std::pair<iterator,bool> ret;
        -:  846:      insert_commit_data data;
        -:  847:      ret.second = this->priv_insert_unique_prepare(KeyOfValue()(val), data);
        -:  848:      ret.first = ret.second ? this->priv_insert_commit(data, val)
        -:  849:                             : this->begin() + (data.position - this->cbegin());
        -:  850:                             //: iterator(vector_iterator_get_ptr(data.position));
        -:  851:      return ret;
        -:  852:   }
        -:  853:
        -:  854:   std::pair<iterator,bool> insert_unique(BOOST_RV_REF(value_type) val)
        -:  855:   {
        -:  856:      std::pair<iterator,bool> ret;
        -:  857:      insert_commit_data data;
        -:  858:      ret.second = this->priv_insert_unique_prepare(KeyOfValue()(val), data);
        -:  859:      ret.first = ret.second ? this->priv_insert_commit(data, boost::move(val))
        -:  860:                             : this->begin() + (data.position - this->cbegin());
        -:  861:                             //: iterator(vector_iterator_get_ptr(data.position));
        -:  862:      return ret;
        -:  863:   }
        -:  864:
        -:  865:   iterator insert_equal(const value_type& val)
        -:  866:   {
        -:  867:      iterator i = this->upper_bound(KeyOfValue()(val));
        -:  868:      i = this->m_data.m_seq.insert(i, val);
        -:  869:      return i;
        -:  870:   }
        -:  871:
        -:  872:   iterator insert_equal(BOOST_RV_REF(value_type) mval)
        -:  873:   {
        -:  874:      iterator i = this->upper_bound(KeyOfValue()(mval));
        -:  875:      i = this->m_data.m_seq.insert(i, boost::move(mval));
        -:  876:      return i;
        -:  877:   }
        -:  878:
        -:  879:   iterator insert_unique(const_iterator hint, const value_type& val)
        -:  880:   {
        -:  881:      BOOST_ASSERT(this->priv_in_range_or_end(hint));
        -:  882:      insert_commit_data data;
        -:  883:      return this->priv_insert_unique_prepare(hint, KeyOfValue()(val), data)
        -:  884:            ? this->priv_insert_commit(data, val)
        -:  885:            : this->begin() + (data.position - this->cbegin());
        -:  886:            //: iterator(vector_iterator_get_ptr(data.position));
        -:  887:   }
        -:  888:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE13insert_uniqueENS0_12vec_iteratorIPSF_Lb1EEEOSF_ called 4 returned 100% blocks executed 62%
        4:  889:   iterator insert_unique(const_iterator hint, BOOST_RV_REF(value_type) val)
        -:  890:   {
        4:  891:      BOOST_ASSERT(this->priv_in_range_or_end(hint));
        4:  891-block  0
branch  0 taken 4
branch  1 taken 0
        4:  891-block  1
    $$$$$:  891-block  2
    $$$$$:  891-block  3
        4:  892:      insert_commit_data data;
        4:  893:      return this->priv_insert_unique_prepare(hint, KeyOfValue()(val), data)
        4:  893-block  0
branch  0 taken 4
branch  1 taken 0
        4:  893-block  1
    $$$$$:  893-block  2
        4:  893-block  3
        4:  894:         ? this->priv_insert_commit(data, boost::move(val))
    #####:  895:         : this->begin() + (data.position - this->cbegin());
        -:  896:         //: iterator(vector_iterator_get_ptr(data.position));
        -:  897:   }
        -:  898:
        -:  899:   iterator insert_equal(const_iterator hint, const value_type& val)
        -:  900:   {
        -:  901:      BOOST_ASSERT(this->priv_in_range_or_end(hint));
        -:  902:      insert_commit_data data;
        -:  903:      this->priv_insert_equal_prepare(hint, val, data);
        -:  904:      return this->priv_insert_commit(data, val);
        -:  905:   }
        -:  906:
        -:  907:   iterator insert_equal(const_iterator hint, BOOST_RV_REF(value_type) mval)
        -:  908:   {
        -:  909:      BOOST_ASSERT(this->priv_in_range_or_end(hint));
        -:  910:      insert_commit_data data;
        -:  911:      this->priv_insert_equal_prepare(hint, mval, data);
        -:  912:      return this->priv_insert_commit(data, boost::move(mval));
        -:  913:   }
        -:  914:
        -:  915:   template <class InIt>
        -:  916:   void insert_unique(InIt first, InIt last)
        -:  917:   {
        -:  918:      dtl::bool_<is_contiguous_container<container_type>::value> contiguous_tag;
        -:  919:      container_type &seq = this->m_data.m_seq;
        -:  920:      value_compare &val_cmp = this->priv_value_comp();
        -:  921:
        -:  922:      //Step 1: put new elements in the back
        -:  923:      typename container_type::iterator const it = seq.insert(seq.cend(), first, last);
        -:  924:
        -:  925:      //Step 2: sort them
        -:  926:      boost::movelib::pdqsort(it, seq.end(), val_cmp);
        -:  927:
        -:  928:      //Step 3: only left unique values from the back not already present in the original range
        -:  929:      typename container_type::iterator const e = boost::movelib::inplace_set_unique_difference
        -:  930:         (it, seq.end(), seq.begin(), it, val_cmp);
        -:  931:
        -:  932:      seq.erase(e, seq.cend());
        -:  933:      //it might be invalidated by erasing [e, seq.end) if e == it
        -:  934:      if (it != e)
        -:  935:      {
        -:  936:         //Step 4: merge both ranges
        -:  937:         (flat_tree_container_inplace_merge)(seq, it, this->priv_value_comp(), contiguous_tag);
        -:  938:      }
        -:  939:   }
        -:  940:
        -:  941:   template <class InIt>
        -:  942:   void insert_equal(InIt first, InIt last)
        -:  943:   {
        -:  944:      if (first != last) {
        -:  945:         dtl::bool_<is_contiguous_container<container_type>::value> contiguous_tag;
        -:  946:         container_type &seq = this->m_data.m_seq;
        -:  947:         typename container_type::iterator const it = seq.insert(seq.cend(), first, last);
        -:  948:         (flat_tree_container_inplace_sort_ending)(seq, it, this->priv_value_comp(), contiguous_tag);
        -:  949:         (flat_tree_container_inplace_merge)      (seq, it, this->priv_value_comp(), contiguous_tag);
        -:  950:      }
        -:  951:   }
        -:  952:
        -:  953:   //Ordered
        -:  954:
        -:  955:   template <class InIt>
        -:  956:   void insert_equal(ordered_range_t, InIt first, InIt last)
        -:  957:   {
        -:  958:      const bool value = boost::container::dtl::
        -:  959:         has_member_function_callable_with_merge_unique<container_type, InIt, InIt, value_compare>::value;
        -:  960:      (flat_tree_merge_equal)(this->m_data.m_seq, first, last, this->priv_value_comp(), dtl::bool_<value>());
        -:  961:   }
        -:  962:
        -:  963:   template <class InIt>
        -:  964:   void insert_unique(ordered_unique_range_t, InIt first, InIt last)
        -:  965:   {
        -:  966:      const bool value = boost::container::dtl::
        -:  967:         has_member_function_callable_with_merge_unique<container_type, InIt, InIt, value_compare>::value;
        -:  968:      (flat_tree_merge_unique)(this->m_data.m_seq, first, last, this->priv_value_comp(), dtl::bool_<value>());
        -:  969:   }
        -:  970:
        -:  971:   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  972:
        -:  973:   template <class... Args>
        -:  974:   std::pair<iterator, bool> emplace_unique(BOOST_FWD_REF(Args)... args)
        -:  975:   {
        -:  976:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;
        -:  977:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();
        -:  978:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v), ::boost::forward<Args>(args)... );
        -:  979:      value_type *pval = move_detail::force_ptr<value_type *>(&v);
        -:  980:      value_destructor<stored_allocator_type, value_type> d(a, *pval);
        -:  981:      return this->insert_unique(::boost::move(*pval));
        -:  982:   }
        -:  983:
        -:  984:   template <class... Args>
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE19emplace_hint_uniqueIJSF_EEENS0_12vec_iteratorIPSF_Lb0EEENSO_ISP_Lb1EEEDpOT_ called 4 returned 100% blocks executed 50%
        4:  985:   iterator emplace_hint_unique(const_iterator hint, BOOST_FWD_REF(Args)... args)
        -:  986:   {
        -:  987:      //hint checked in insert_unique
        -:  988:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;
        4:  989:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();
        4:  990:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v), ::boost::forward<Args>(args)... );
        4:  991:      value_type *pval = move_detail::force_ptr<value_type *>(&v);
        4:  992:      value_destructor<stored_allocator_type, value_type> d(a, *pval);
        4:  993:      return this->insert_unique(hint, ::boost::move(*pval));
        4:  993-block  0
branch  0 taken 4
branch  1 taken 0
        4:  994:   }
        4:  994-block  0
    $$$$$:  994-block  1
    $$$$$:  994-block  2
        -:  995:
        -:  996:   template <class... Args>
        -:  997:   iterator emplace_equal(BOOST_FWD_REF(Args)... args)
        -:  998:   {
        -:  999:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;
        -: 1000:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();
        -: 1001:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v), ::boost::forward<Args>(args)... );
        -: 1002:      value_type *pval = move_detail::force_ptr<value_type *>(&v);
        -: 1003:      value_destructor<stored_allocator_type, value_type> d(a, *pval);
        -: 1004:      return this->insert_equal(::boost::move(*pval));
        -: 1005:   }
        -: 1006:
        -: 1007:   template <class... Args>
        -: 1008:   iterator emplace_hint_equal(const_iterator hint, BOOST_FWD_REF(Args)... args)
        -: 1009:   {
        -: 1010:      //hint checked in insert_equal
        -: 1011:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;
        -: 1012:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();
        -: 1013:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v), ::boost::forward<Args>(args)... );
        -: 1014:      value_type *pval = move_detail::force_ptr<value_type *>(&v);
        -: 1015:      value_destructor<stored_allocator_type, value_type> d(a, *pval);
        -: 1016:      return this->insert_equal(hint, ::boost::move(*pval));
        -: 1017:   }
        -: 1018:
        -: 1019:   template <class KeyType, class... Args>
        -: 1020:   inline std::pair<iterator, bool> try_emplace
        -: 1021:      (const_iterator hint, BOOST_FWD_REF(KeyType) key, BOOST_FWD_REF(Args)... args)
        -: 1022:   {
        -: 1023:      std::pair<iterator,bool> ret;
        -: 1024:      insert_commit_data data;
        -: 1025:      const key_type & k = key;
        -: 1026:      ret.second = hint == const_iterator()
        -: 1027:         ? this->priv_insert_unique_prepare(k, data)
        -: 1028:         : this->priv_insert_unique_prepare(hint, k, data);
        -: 1029:
        -: 1030:      if(!ret.second){
        -: 1031:         ret.first  = this->nth(size_type(data.position - this->cbegin()));
        -: 1032:      }
        -: 1033:      else{
        -: 1034:         ret.first = this->m_data.m_seq.emplace(data.position, try_emplace_t(), ::boost::forward<KeyType>(key), ::boost::forward<Args>(args)...);
        -: 1035:      }
        -: 1036:      return ret;
        -: 1037:   }
        -: 1038:
        -: 1039:   #else // !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -: 1040:
        -: 1041:   #define BOOST_CONTAINER_FLAT_TREE_EMPLACE_CODE(N) \
        -: 1042:   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \
        -: 1043:   std::pair<iterator, bool> emplace_unique(BOOST_MOVE_UREF##N)\
        -: 1044:   {\
        -: 1045:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;\
        -: 1046:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();\
        -: 1047:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v) BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\
        -: 1048:      value_type *pval = move_detail::force_ptr<value_type *>(&v);\
        -: 1049:      value_destructor<stored_allocator_type, value_type> d(a, *pval);\
        -: 1050:      return this->insert_unique(::boost::move(*pval));\
        -: 1051:   }\
        -: 1052:   \
        -: 1053:   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \
        -: 1054:   iterator emplace_hint_unique(const_iterator hint BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -: 1055:   {\
        -: 1056:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;\
        -: 1057:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();\
        -: 1058:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v) BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\
        -: 1059:      value_type *pval = move_detail::force_ptr<value_type *>(&v);\
        -: 1060:      value_destructor<stored_allocator_type, value_type> d(a, *pval);\
        -: 1061:      return this->insert_unique(hint, ::boost::move(*pval));\
        -: 1062:   }\
        -: 1063:   \
        -: 1064:   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \
        -: 1065:   iterator emplace_equal(BOOST_MOVE_UREF##N)\
        -: 1066:   {\
        -: 1067:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;\
        -: 1068:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();\
        -: 1069:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v) BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\
        -: 1070:      value_type *pval = move_detail::force_ptr<value_type *>(&v);\
        -: 1071:      value_destructor<stored_allocator_type, value_type> d(a, *pval);\
        -: 1072:      return this->insert_equal(::boost::move(*pval));\
        -: 1073:   }\
        -: 1074:   \
        -: 1075:   BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N \
        -: 1076:   iterator emplace_hint_equal(const_iterator hint BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -: 1077:   {\
        -: 1078:      typename dtl::aligned_storage <sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;\
        -: 1079:      get_stored_allocator_noconst_return_t a = this->get_stored_allocator();\
        -: 1080:      stored_allocator_traits::construct(a, move_detail::force_ptr<value_type *>(&v) BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\
        -: 1081:      value_type *pval = move_detail::force_ptr<value_type *>(&v);\
        -: 1082:      value_destructor<stored_allocator_type, value_type> d(a, *pval);\
        -: 1083:      return this->insert_equal(hint, ::boost::move(*pval));\
        -: 1084:   }\
        -: 1085:   template <class KeyType BOOST_MOVE_I##N BOOST_MOVE_CLASS##N>\
        -: 1086:   inline std::pair<iterator, bool>\
        -: 1087:      try_emplace(const_iterator hint, BOOST_FWD_REF(KeyType) key BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -: 1088:   {\
        -: 1089:      std::pair<iterator,bool> ret;\
        -: 1090:      insert_commit_data data;\
        -: 1091:      const key_type & k = key;\
        -: 1092:      ret.second = hint == const_iterator()\
        -: 1093:         ? this->priv_insert_unique_prepare(k, data)\
        -: 1094:         : this->priv_insert_unique_prepare(hint, k, data);\
        -: 1095:      \
        -: 1096:      if(!ret.second){\
        -: 1097:         ret.first  = this->nth(size_type(data.position - this->cbegin()));\
        -: 1098:      }\
        -: 1099:      else{\
        -: 1100:         ret.first = this->m_data.m_seq.emplace(data.position, try_emplace_t(), ::boost::forward<KeyType>(key) BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\
        -: 1101:      }\
        -: 1102:      return ret;\
        -: 1103:   }\
        -: 1104:   //
        -: 1105:   BOOST_MOVE_ITERATE_0TO7(BOOST_CONTAINER_FLAT_TREE_EMPLACE_CODE)
        -: 1106:   #undef BOOST_CONTAINER_FLAT_TREE_EMPLACE_CODE
        -: 1107:
        -: 1108:   #endif   // !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -: 1109:
        -: 1110:   template<class KeyType, class M>
        -: 1111:   std::pair<iterator, bool> insert_or_assign(const_iterator hint, BOOST_FWD_REF(KeyType) key, BOOST_FWD_REF(M) obj)
        -: 1112:   {
        -: 1113:      const key_type& k = key;
        -: 1114:      std::pair<iterator,bool> ret;
        -: 1115:      insert_commit_data data;
        -: 1116:      ret.second = hint == const_iterator()
        -: 1117:         ? this->priv_insert_unique_prepare(k, data)
        -: 1118:         : this->priv_insert_unique_prepare(hint, k, data);
        -: 1119:      if(!ret.second){
        -: 1120:         ret.first  = this->nth(size_type(data.position - this->cbegin()));
        -: 1121:         ret.first->second = boost::forward<M>(obj);
        -: 1122:      }
        -: 1123:      else{
        -: 1124:         ret.first = this->m_data.m_seq.emplace(data.position, boost::forward<KeyType>(key), boost::forward<M>(obj));
        -: 1125:      }
        -: 1126:      return ret;
        -: 1127:   }
        -: 1128:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE5eraseENS0_12vec_iteratorIPSF_Lb1EEE called 1 returned 100% blocks executed 100%
        1: 1129:   inline iterator erase(const_iterator position)
        1: 1130:   {  return this->m_data.m_seq.erase(position);  }
        1: 1130-block  0
        -: 1131:
        -: 1132:   size_type erase(const key_type& k)
        -: 1133:   {
        -: 1134:      std::pair<iterator,iterator > itp = this->equal_range(k);
        -: 1135:      size_type ret = static_cast<size_type>(itp.second-itp.first);
        -: 1136:      if (ret){
        -: 1137:         this->m_data.m_seq.erase(itp.first, itp.second);
        -: 1138:      }
        -: 1139:      return ret;
        -: 1140:   }
        -: 1141:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE12erase_uniqueERKS9_ called 1 returned 100% blocks executed 100%
        1: 1142:   size_type erase_unique(const key_type& k)
        -: 1143:   {
        1: 1144:      const_iterator i = static_cast<const flat_tree &>(*this).find(k);
        1: 1145:      size_type ret = static_cast<size_type>(i != this->cend());
        1: 1146:      if (ret)
        1: 1146-block  0
branch  0 taken 0
branch  1 taken 1
        1: 1147:         this->erase(i);
        1: 1147-block  0
        1: 1148:      return ret;
        1: 1148-block  0
        -: 1149:   }
        -: 1150:
        -: 1151:   inline iterator erase(const_iterator first, const_iterator last)
        -: 1152:   {  return this->m_data.m_seq.erase(first, last);  }
        -: 1153:
        -: 1154:   inline void clear()
        -: 1155:   {  this->m_data.m_seq.clear();  }
        -: 1156:
        -: 1157:   //! <b>Effects</b>: Tries to deallocate the excess of memory created
        -: 1158:   //    with previous allocations. The size of the vector is unchanged
        -: 1159:   //!
        -: 1160:   //! <b>Throws</b>: If memory allocation throws, or T's copy constructor throws.
        -: 1161:   //!
        -: 1162:   //! <b>Complexity</b>: Linear to size().
        -: 1163:   inline void shrink_to_fit()
        -: 1164:   {  this->m_data.m_seq.shrink_to_fit();  }
        -: 1165:
        -: 1166:   inline iterator nth(size_type n) BOOST_NOEXCEPT_OR_NOTHROW
        -: 1167:   {
        -: 1168:      const bool value = boost::container::dtl::
        -: 1169:         has_member_function_callable_with_nth<container_type, size_type>::value;
        -: 1170:      return flat_tree_nth<iterator>(this->m_data.m_seq, n, dtl::bool_<value>());
        -: 1171:   }
        -: 1172:
        -: 1173:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1174:      const_iterator nth(size_type n) const BOOST_NOEXCEPT_OR_NOTHROW
        -: 1175:   {
        -: 1176:      const bool value = boost::container::dtl::
        -: 1177:         has_member_function_callable_with_nth<container_type, size_type>::value;
        -: 1178:      return flat_tree_nth<const_iterator>(this->m_data.m_seq, n, dtl::bool_<value>());
        -: 1179:   }
        -: 1180:
        -: 1181:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1182:      size_type index_of(iterator p) BOOST_NOEXCEPT_OR_NOTHROW
        -: 1183:   {
        -: 1184:      const bool value = boost::container::dtl::
        -: 1185:         has_member_function_callable_with_index_of<container_type, iterator>::value;
        -: 1186:      return flat_tree_index_of(this->m_data.m_seq, p, dtl::bool_<value>());
        -: 1187:   }
        -: 1188:
        -: 1189:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1190:      size_type index_of(const_iterator p) const BOOST_NOEXCEPT_OR_NOTHROW
        -: 1191:   {
        -: 1192:      const bool value = boost::container::dtl::
        -: 1193:         has_member_function_callable_with_index_of<container_type, const_iterator>::value;
        -: 1194:      return flat_tree_index_of(this->m_data.m_seq, p, dtl::bool_<value>());
        -: 1195:   }
        -: 1196:
        -: 1197:   // set operations:
        -: 1198:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD
        -: 1199:      iterator find(const key_type& k)
        -: 1200:   {
        -: 1201:      iterator i = this->lower_bound(k);
        -: 1202:      iterator end_it = this->end();
        -: 1203:      if (i != end_it && this->m_data.get_comp()(k, KeyOfValue()(*i))){
        -: 1204:         i = end_it;
        -: 1205:      }
        -: 1206:      return i;
        -: 1207:   }
        -: 1208:
        -: 1209:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE4findERKS9_ called 4 returned 100% blocks executed 80%
        4: 1210:   const_iterator find(const key_type& k) const
        -: 1211:   {
        4: 1212:      const_iterator i = this->lower_bound(k);
        -: 1213:
        4: 1214:      const_iterator end_it = this->cend();
        4: 1215:      if (i != end_it && this->m_data.get_comp()(k, KeyOfValue()(*i))){
        4: 1215-block  0
branch  0 taken 1
branch  1 taken 3
        3: 1215-block  1
        4: 1215-block  2
branch  2 taken 4
branch  3 taken 0
    #####: 1216:         i = end_it;
    #####: 1217:      }
    $$$$$: 1217-block  0
        4: 1218:      return i;
        4: 1218-block  0
        -: 1219:   }
        -: 1220:
        -: 1221:   template<class K>
        -: 1222:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD
        -: 1223:      typename dtl::enable_if_transparent<key_compare, K, iterator>::type
        -: 1224:      find(const K& k)
        -: 1225:   {
        -: 1226:      iterator i = this->lower_bound(k);
        -: 1227:      iterator end_it = this->end();
        -: 1228:      if (i != end_it && this->m_data.get_comp()(k, KeyOfValue()(*i))){
        -: 1229:         i = end_it;
        -: 1230:      }
        -: 1231:      return i;
        -: 1232:   }
        -: 1233:
        -: 1234:   template<class K>
        -: 1235:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD
        -: 1236:      typename dtl::enable_if_transparent<key_compare, K, const_iterator>::type
        -: 1237:      find(const K& k) const
        -: 1238:   {
        -: 1239:      const_iterator i = this->lower_bound(k);
        -: 1240:
        -: 1241:      const_iterator end_it = this->cend();
        -: 1242:      if (i != end_it && this->m_data.get_comp()(k, KeyOfValue()(*i))){
        -: 1243:         i = end_it;
        -: 1244:      }
        -: 1245:      return i;
        -: 1246:   }
        -: 1247:
        -: 1248:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD
        -: 1249:      size_type count(const key_type& k) const
        -: 1250:   {
        -: 1251:      std::pair<const_iterator, const_iterator> p = this->equal_range(k);
        -: 1252:      size_type n = size_type(p.second - p.first);
        -: 1253:      return n;
        -: 1254:   }
        -: 1255:
        -: 1256:   template<class K>
        -: 1257:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD
        -: 1258:      typename dtl::enable_if_transparent<key_compare, K, size_type>::type
        -: 1259:      count(const K& k) const
        -: 1260:   {
        -: 1261:      std::pair<const_iterator, const_iterator> p = this->equal_range(k);
        -: 1262:      size_type n = size_type(p.second - p.first);
        -: 1263:      return n;
        -: 1264:   }
        -: 1265:
        -: 1266:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline bool contains(const key_type& x) const
        -: 1267:   {  return this->find(x) != this->cend();  }
        -: 1268:
        -: 1269:   template<typename K>
        -: 1270:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1271:      typename dtl::enable_if_transparent<key_compare, K, bool>::type
        -: 1272:         contains(const K& x) const
        -: 1273:   {  return this->find(x) != this->cend();  }
        -: 1274:
        -: 1275:   template<class C2>
        -: 1276:   inline void merge_unique(flat_tree<Value, KeyOfValue, C2, AllocatorOrContainer>& source)
        -: 1277:   {
        -: 1278:      this->insert_unique( boost::make_move_iterator(source.begin())
        -: 1279:                         , boost::make_move_iterator(source.end()));
        -: 1280:   }
        -: 1281:
        -: 1282:   template<class C2>
        -: 1283:   inline void merge_equal(flat_tree<Value, KeyOfValue, C2, AllocatorOrContainer>& source)
        -: 1284:   {
        -: 1285:      this->insert_equal( boost::make_move_iterator(source.begin())
        -: 1286:                        , boost::make_move_iterator(source.end()));
        -: 1287:   }
        -: 1288:
        -: 1289:   inline void merge_unique(flat_tree& source)
        -: 1290:   {
        -: 1291:      const bool value = boost::container::dtl::
        -: 1292:         has_member_function_callable_with_merge_unique<container_type, iterator, iterator, value_compare>::value;
        -: 1293:      (flat_tree_merge_unique)
        -: 1294:         ( this->m_data.m_seq
        -: 1295:         , boost::make_move_iterator(source.m_data.m_seq.begin())
        -: 1296:         , boost::make_move_iterator(source.m_data.m_seq.end())
        -: 1297:         , this->priv_value_comp()
        -: 1298:         , dtl::bool_<value>());
        -: 1299:   }
        -: 1300:
        -: 1301:   inline void merge_equal(flat_tree& source)
        -: 1302:   {
        -: 1303:      const bool value = boost::container::dtl::
        -: 1304:         has_member_function_callable_with_merge<container_type, iterator, iterator, value_compare>::value;
        -: 1305:      (flat_tree_merge_equal)
        -: 1306:         ( this->m_data.m_seq
        -: 1307:         , boost::make_move_iterator(source.m_data.m_seq.begin())
        -: 1308:         , boost::make_move_iterator(source.m_data.m_seq.end())
        -: 1309:         , this->priv_value_comp()
        -: 1310:         , dtl::bool_<value>());
        -: 1311:   }
        -: 1312:
        -: 1313:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE11lower_boundERKS9_ called 4 returned 100% blocks executed 100%
        4: 1314:      iterator lower_bound(const key_type& k)
        4: 1315:   {  return this->priv_lower_bound(this->begin(), this->end(), k);  }
        4: 1315-block  0
        -: 1316:
        -: 1317:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE11lower_boundERKS9_ called 4 returned 100% blocks executed 100%
        4: 1318:      const_iterator lower_bound(const key_type& k) const
        4: 1319:   {  return this->priv_lower_bound(this->cbegin(), this->cend(), k);  }
        4: 1319-block  0
        -: 1320:
        -: 1321:   template<class K>
        -: 1322:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline 
        -: 1323:      typename dtl::enable_if_transparent<key_compare, K, iterator>::type
        -: 1324:         lower_bound(const K& k)
        -: 1325:   {  return this->priv_lower_bound(this->begin(), this->end(), k);  }
        -: 1326:
        -: 1327:   template<class K>
        -: 1328:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline 
        -: 1329:      typename dtl::enable_if_transparent<key_compare, K, const_iterator>::type
        -: 1330:         lower_bound(const K& k) const
        -: 1331:   {  return this->priv_lower_bound(this->cbegin(), this->cend(), k);  }
        -: 1332:
        -: 1333:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1334:      iterator upper_bound(const key_type& k)
        -: 1335:   {  return this->priv_upper_bound(this->begin(), this->end(), k);  }
        -: 1336:
        -: 1337:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline 
        -: 1338:      const_iterator upper_bound(const key_type& k) const
        -: 1339:   {  return this->priv_upper_bound(this->cbegin(), this->cend(), k);  }
        -: 1340:
        -: 1341:   template<class K>
        -: 1342:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1343:      typename dtl::enable_if_transparent<key_compare, K,iterator>::type
        -: 1344:   upper_bound(const K& k)
        -: 1345:   {  return this->priv_upper_bound(this->begin(), this->end(), k);  }
        -: 1346:
        -: 1347:   template<class K>
        -: 1348:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1349:      typename dtl::enable_if_transparent<key_compare, K,const_iterator>::type
        -: 1350:         upper_bound(const K& k) const
        -: 1351:   {  return this->priv_upper_bound(this->cbegin(), this->cend(), k);  }
        -: 1352:
        -: 1353:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1354:      std::pair<iterator,iterator> equal_range(const key_type& k)
        -: 1355:   {  return this->priv_equal_range(this->begin(), this->end(), k);  }
        -: 1356:
        -: 1357:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1358:      std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const
        -: 1359:   {  return this->priv_equal_range(this->cbegin(), this->cend(), k);  }
        -: 1360:
        -: 1361:   template<class K>
        -: 1362:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1363:      typename dtl::enable_if_transparent<key_compare, K, std::pair<iterator,iterator> >::type
        -: 1364:         equal_range(const K& k)
        -: 1365:   {  return this->priv_equal_range(this->begin(), this->end(), k);  }
        -: 1366:
        -: 1367:   template<class K>
        -: 1368:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1369:      typename dtl::enable_if_transparent<key_compare, K,std::pair<const_iterator,const_iterator> >::type
        -: 1370:         equal_range(const K& k) const
        -: 1371:   {  return this->priv_equal_range(this->cbegin(), this->cend(), k);  }
        -: 1372:
        -: 1373:
        -: 1374:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1375:      std::pair<iterator, iterator> lower_bound_range(const key_type& k)
        -: 1376:   {  return this->priv_lower_bound_range(this->begin(), this->end(), k);  }
        -: 1377:
        -: 1378:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1379:      std::pair<const_iterator, const_iterator> lower_bound_range(const key_type& k) const
        -: 1380:   {  return this->priv_lower_bound_range(this->cbegin(), this->cend(), k);  }
        -: 1381:
        -: 1382:   template<class K>
        -: 1383:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1384:      typename dtl::enable_if_transparent<key_compare, K,std::pair<iterator,iterator> >::type
        -: 1385:         lower_bound_range(const K& k)
        -: 1386:   {  return this->priv_lower_bound_range(this->begin(), this->end(), k);  }
        -: 1387:
        -: 1388:   template<class K>
        -: 1389:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1390:      typename dtl::enable_if_transparent<key_compare, K,std::pair<const_iterator,const_iterator> >::type
        -: 1391:         lower_bound_range(const K& k) const
        -: 1392:   {  return this->priv_lower_bound_range(this->cbegin(), this->cend(), k);  }
        -: 1393:
        -: 1394:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1395:      size_type capacity() const
        -: 1396:   {
        -: 1397:      const bool value = boost::container::dtl::
        -: 1398:         has_member_function_callable_with_capacity<container_type>::value;
        -: 1399:      return (flat_tree_capacity)(this->m_data.m_seq, dtl::bool_<value>());
        -: 1400:   }
        -: 1401:
        -: 1402:   inline
        -: 1403:      void reserve(size_type cnt)
        -: 1404:   {
        -: 1405:      const bool value = boost::container::dtl::
        -: 1406:         has_member_function_callable_with_reserve<container_type, size_type>::value;
        -: 1407:      (flat_tree_reserve)(this->m_data.m_seq, cnt, dtl::bool_<value>());
        -: 1408:   }
        -: 1409:
        -: 1410:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1411:      container_type extract_sequence()
        -: 1412:   {  return boost::move(m_data.m_seq);   }
        -: 1413:
        -: 1414:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1415:      container_type &get_sequence_ref()
        -: 1416:   {  return m_data.m_seq; }
        -: 1417:
        -: 1418:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1419:      const container_type &get_sequence_cref() const
        -: 1420:   {  return m_data.m_seq; }
        -: 1421:
        -: 1422:   inline void adopt_sequence_equal(BOOST_RV_REF(container_type) seq)
        -: 1423:   {
        -: 1424:      (flat_tree_adopt_sequence_equal)( m_data.m_seq, boost::move(seq), this->priv_value_comp()
        -: 1425:         , dtl::bool_<is_contiguous_container<container_type>::value>());
        -: 1426:   }
        -: 1427:
        -: 1428:   inline void adopt_sequence_unique(BOOST_RV_REF(container_type) seq)
        -: 1429:   {
        -: 1430:      (flat_tree_adopt_sequence_unique)(m_data.m_seq, boost::move(seq), this->priv_value_comp()
        -: 1431:         , dtl::bool_<is_contiguous_container<container_type>::value>());
        -: 1432:   }
        -: 1433:
        -: 1434:   void adopt_sequence_equal(ordered_range_t, BOOST_RV_REF(container_type) seq)
        -: 1435:   {
        -: 1436:      BOOST_ASSERT((is_sorted)(seq.cbegin(), seq.cend(), this->priv_value_comp()));
        -: 1437:      m_data.m_seq = boost::move(seq);
        -: 1438:   }
        -: 1439:
        -: 1440:   void adopt_sequence_unique(ordered_unique_range_t, BOOST_RV_REF(container_type) seq)
        -: 1441:   {
        -: 1442:      BOOST_ASSERT((is_sorted_and_unique)(seq.cbegin(), seq.cend(), this->priv_value_comp()));
        -: 1443:      m_data.m_seq = boost::move(seq);
        -: 1444:   }
        -: 1445:
        -: 1446:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1447:      friend bool operator==(const flat_tree& x, const flat_tree& y)
        -: 1448:   {
        -: 1449:      return x.size() == y.size() && ::boost::container::algo_equal(x.begin(), x.end(), y.begin());
        -: 1450:   }
        -: 1451:
        -: 1452:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1453:      friend bool operator<(const flat_tree& x, const flat_tree& y)
        -: 1454:   {
        -: 1455:      return ::boost::container::algo_lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
        -: 1456:   }
        -: 1457:
        -: 1458:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1459:      friend bool operator!=(const flat_tree& x, const flat_tree& y)
        -: 1460:      {  return !(x == y); }
        -: 1461:
        -: 1462:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1463:      friend bool operator>(const flat_tree& x, const flat_tree& y)
        -: 1464:      {  return y < x;  }
        -: 1465:
        -: 1466:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1467:      friend bool operator<=(const flat_tree& x, const flat_tree& y)
        -: 1468:      {  return !(y < x);  }
        -: 1469:
        -: 1470:   BOOST_CONTAINER_ATTRIBUTE_NODISCARD inline
        -: 1471:      friend bool operator>=(const flat_tree& x, const flat_tree& y)
        -: 1472:      {  return !(x < y);  }
        -: 1473:
        -: 1474:   inline friend void swap(flat_tree& x, flat_tree& y)
        -: 1475:          BOOST_NOEXCEPT_IF(BOOST_NOEXCEPT(x.swap(y)))
        -: 1476:      {  x.swap(y);  }
        -: 1477:
        -: 1478:   private:
        -: 1479:
        -: 1480:   template <class InputIterator>
        -: 1481:   void priv_range_insertion_construct( bool unique_insertion, InputIterator first, InputIterator last)
        -: 1482:   {
        -: 1483:      //Use cend() as hint to achieve linear time for
        -: 1484:      //ordered ranges as required by the standard
        -: 1485:      //for the constructor
        -: 1486:      //Call end() every iteration as reallocation might have invalidated iterators
        -: 1487:      if(unique_insertion){
        -: 1488:         this->insert_unique(first, last);
        -: 1489:      }
        -: 1490:      else{
        -: 1491:         this->insert_equal (first, last);
        -: 1492:      }
        -: 1493:   }
        -: 1494:
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE20priv_in_range_or_endENS0_12vec_iteratorIPSF_Lb1EEE called 4 returned 100% blocks executed 100%
        4: 1495:   inline bool priv_in_range_or_end(const_iterator pos) const
        -: 1496:   {
        4: 1497:      return (this->begin() <= pos) && (pos <= this->end());
        4: 1497-block  0
branch  0 taken 0
branch  1 taken 4
        4: 1497-block  1
        4: 1497-block  2
        -: 1498:   }
        -: 1499:
        -: 1500:   // insert/erase
        -: 1501:   void priv_insert_equal_prepare
        -: 1502:      (const_iterator pos, const value_type& val, insert_commit_data &data)
        -: 1503:   {
        -: 1504:      // N1780
        -: 1505:      //   To insert val at pos:
        -: 1506:      //   if pos == end || val <= *pos
        -: 1507:      //      if pos == begin || val >= *(pos-1)
        -: 1508:      //         insert val before pos
        -: 1509:      //      else
        -: 1510:      //         insert val before upper_bound(val)
        -: 1511:      //   else
        -: 1512:      //      insert val before lower_bound(val)
        -: 1513:      const value_compare &val_cmp = this->m_data;
        -: 1514:
        -: 1515:      if(pos == this->cend() || !val_cmp(*pos, val)){
        -: 1516:         if (pos == this->cbegin() || !val_cmp(val, pos[-1])){
        -: 1517:            data.position = pos;
        -: 1518:         }
        -: 1519:         else{
        -: 1520:            data.position =
        -: 1521:               this->priv_upper_bound(this->cbegin(), pos, KeyOfValue()(val));
        -: 1522:         }
        -: 1523:      }
        -: 1524:      else{
        -: 1525:         data.position =
        -: 1526:            this->priv_lower_bound(pos, this->cend(), KeyOfValue()(val));
        -: 1527:      }
        -: 1528:   }
        -: 1529:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE26priv_insert_unique_prepareENS0_12vec_iteratorIPSF_Lb1EEESP_RKS9_RNSM_18insert_commit_dataE called 0 returned 0% blocks executed 0%
    #####: 1530:   bool priv_insert_unique_prepare
        -: 1531:      (const_iterator b, const_iterator e, const key_type& k, insert_commit_data &commit_data)
        -: 1532:   {
    #####: 1533:      const key_compare &key_cmp  = this->priv_key_comp();
    #####: 1534:      commit_data.position = this->priv_lower_bound(b, e, k);
    #####: 1535:      return commit_data.position == e || key_cmp(k, KeyOfValue()(*commit_data.position));
    $$$$$: 1535-block  0
branch  0 never executed
branch  1 never executed
    $$$$$: 1535-block  1
    $$$$$: 1535-block  2
        -: 1536:   }
        -: 1537:
        -: 1538:   inline bool priv_insert_unique_prepare
        -: 1539:      (const key_type& k, insert_commit_data &commit_data)
        -: 1540:   {  return this->priv_insert_unique_prepare(this->cbegin(), this->cend(), k, commit_data);   }
        -: 1541:
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE26priv_insert_unique_prepareENS0_12vec_iteratorIPSF_Lb1EEERKS9_RNSM_18insert_commit_dataE called 4 returned 100% blocks executed 41%
        4: 1542:   bool priv_insert_unique_prepare
        -: 1543:      (const_iterator pos, const key_type& k, insert_commit_data &commit_data)
        -: 1544:   {
        -: 1545:      //N1780. Props to Howard Hinnant!
        -: 1546:      //To insert k at pos:
        -: 1547:      //if pos == end || k <= *pos
        -: 1548:      //   if pos == begin || k >= *(pos-1)
        -: 1549:      //      insert k before pos
        -: 1550:      //   else
        -: 1551:      //      insert k before upper_bound(k)
        -: 1552:      //else if pos+1 == end || k <= *(pos+1)
        -: 1553:      //   insert k after pos
        -: 1554:      //else
        -: 1555:      //   insert k before lower_bound(k)
        4: 1556:      const key_compare &key_cmp = this->priv_key_comp();
        4: 1557:      const const_iterator cend_it = this->cend();
        4: 1558:      if(pos == cend_it || key_cmp(k, KeyOfValue()(*pos))){ //Check if k should go before end
        4: 1558-block  0
branch  0 taken 4
branch  1 taken 0
    $$$$$: 1558-block  1
        4: 1558-block  2
branch  2 taken 4
branch  3 taken 0
        4: 1559:         const const_iterator cbeg = this->cbegin();
        4: 1560:         commit_data.position = pos;
        4: 1561:         if(pos == cbeg){  //If container is empty then insert it in the beginning
        4: 1561-block  0
branch  0 taken 4
branch  1 taken 0
        4: 1562:            return true;
        4: 1562-block  0
        -: 1563:         }
    #####: 1564:         const_iterator prev(pos);
    #####: 1565:         --prev;
    #####: 1566:         if(key_cmp(KeyOfValue()(*prev), k)){   //If previous element was less, then it should go between prev and pos
    $$$$$: 1566-block  0
branch  0 never executed
branch  1 never executed
    #####: 1567:            return true;
    $$$$$: 1567-block  0
        -: 1568:         }
    #####: 1569:         else if(!key_cmp(k, KeyOfValue()(*prev))){   //If previous was equal then insertion should fail
    $$$$$: 1569-block  0
branch  0 never executed
branch  1 never executed
    #####: 1570:            commit_data.position = prev;
    #####: 1571:            return false;
    $$$$$: 1571-block  0
        -: 1572:         }
        -: 1573:         else{ //Previous was bigger so insertion hint was pointless, dispatch to hintless insertion
        -: 1574:               //but reduce the search between beg and prev as prev is bigger than k
    #####: 1575:            return this->priv_insert_unique_prepare(cbeg, prev, k, commit_data);
    $$$$$: 1575-block  0
        -: 1576:         }
        -: 1577:      }
        -: 1578:      else{
        -: 1579:         //The hint is before the insertion position, so insert it
        -: 1580:         //in the remaining range [pos, end)
    #####: 1581:         return this->priv_insert_unique_prepare(pos, cend_it, k, commit_data);
    $$$$$: 1581-block  0
        -: 1582:      }
        4: 1583:   }
        4: 1583-block  0
        -: 1584:
        -: 1585:   template<class Convertible>
function _ZN5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE18priv_insert_commitISF_EENS0_12vec_iteratorIPSF_Lb0EEERNSM_18insert_commit_dataEOT_ called 4 returned 100% blocks executed 100%
        4: 1586:   inline iterator priv_insert_commit
        -: 1587:      (insert_commit_data &commit_data, BOOST_FWD_REF(Convertible) convertible)
        -: 1588:   {
        8: 1589:      return this->m_data.m_seq.insert
        4: 1589-block  0
        4: 1589-block  1
        4: 1590:         ( commit_data.position
        4: 1591:         , boost::forward<Convertible>(convertible));
        -: 1592:   }
        -: 1593:
        -: 1594:   template <class RanIt, class K>
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE16priv_lower_boundINS0_12vec_iteratorIPSF_Lb0EEES9_EET_SR_SR_RKT0_ called 4 returned 100% blocks executed 42%
function _ZNK5boost9container3dtl9flat_treeINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEENS1_9select1stIS9_EESt4lessIS9_ENS0_13new_allocatorISF_EEE16priv_lower_boundINS0_12vec_iteratorIPSF_Lb1EEES9_EET_SR_SR_RKT0_ called 4 returned 100% blocks executed 85%
        8: 1595:   RanIt priv_lower_bound(RanIt first, const RanIt last,
        -: 1596:                          const K & key) const
        -: 1597:   {
        8: 1598:      const Compare &key_cmp = this->m_data.get_comp();
        -: 1599:      KeyOfValue key_extract;
        8: 1600:      size_type len = static_cast<size_type>(last - first);
        8: 1601:      RanIt middle;
        -: 1602:
       11: 1603:      while (len) {
        4: 1603-block  0
        4: 1603-block  1
branch  0 taken 0
branch  1 taken 4
    $$$$$: 1603-block  2
        4: 1603-block  3
        7: 1603-block  4
branch  2 taken 3
branch  3 taken 4
        3: 1603-block  5
        3: 1604:         size_type step = len >> 1;
        3: 1605:         middle = first;
        3: 1606:         middle += difference_type(step);
        -: 1607:
        3: 1608:         if (key_cmp(key_extract(*middle), key)) {
    $$$$$: 1608-block  0
branch  0 never executed
branch  1 never executed
        3: 1608-block  1
branch  2 taken 0
branch  3 taken 3
    #####: 1609:            first = ++middle;
    #####: 1610:            len -= step + 1;
    #####: 1611:         }
    $$$$$: 1611-block  0
    $$$$$: 1611-block  1
        -: 1612:         else{
        3: 1613:            len = step;
    $$$$$: 1613-block  0
        3: 1613-block  1
        -: 1614:         }
        -: 1615:      }
        8: 1616:      return first;
        4: 1616-block  0
        4: 1616-block  1
        -: 1617:   }
        -: 1618:
        -: 1619:   template <class RanIt, class K>
        -: 1620:   RanIt priv_upper_bound
        -: 1621:      (RanIt first, const RanIt last,const K & key) const
        -: 1622:   {
        -: 1623:      const Compare &key_cmp = this->m_data.get_comp();
        -: 1624:      KeyOfValue key_extract;
        -: 1625:      size_type len = static_cast<size_type>(last - first);
        -: 1626:      RanIt middle;
        -: 1627:
        -: 1628:      while (len) {
        -: 1629:         size_type step = len >> 1;
        -: 1630:         middle = first;
        -: 1631:         middle += difference_type(step);
        -: 1632:
        -: 1633:         if (key_cmp(key, key_extract(*middle))) {
        -: 1634:            len = step;
        -: 1635:         }
        -: 1636:         else{
        -: 1637:            first = ++middle;
        -: 1638:            len -= step + 1;
        -: 1639:         }
        -: 1640:      }
        -: 1641:      return first;
        -: 1642:   }
        -: 1643:
        -: 1644:   template <class RanIt, class K>
        -: 1645:   std::pair<RanIt, RanIt>
        -: 1646:      priv_equal_range(RanIt first, RanIt last, const K& key) const
        -: 1647:   {
        -: 1648:      const Compare &key_cmp = this->m_data.get_comp();
        -: 1649:      KeyOfValue key_extract;
        -: 1650:      size_type len = static_cast<size_type>(last - first);
        -: 1651:      RanIt middle;
        -: 1652:
        -: 1653:      while (len) {
        -: 1654:         size_type step = len >> 1;
        -: 1655:         middle = first;
        -: 1656:         middle += difference_type(step);
        -: 1657:
        -: 1658:         if (key_cmp(key_extract(*middle), key)){
        -: 1659:            first = ++middle;
        -: 1660:            len -= step + 1;
        -: 1661:         }
        -: 1662:         else if (key_cmp(key, key_extract(*middle))){
        -: 1663:            len = step;
        -: 1664:         }
        -: 1665:         else {
        -: 1666:            //Middle is equal to key
        -: 1667:            last = first;
        -: 1668:            last += difference_type(len);
        -: 1669:            RanIt const first_ret = this->priv_lower_bound(first, middle, key);
        -: 1670:            return std::pair<RanIt, RanIt>
        -: 1671:               ( first_ret, this->priv_upper_bound(++middle, last, key));
        -: 1672:         }
        -: 1673:      }
        -: 1674:      return std::pair<RanIt, RanIt>(first, first);
        -: 1675:   }
        -: 1676:
        -: 1677:   template<class RanIt, class K>
        -: 1678:   std::pair<RanIt, RanIt> priv_lower_bound_range(RanIt first, RanIt last, const K& k) const
        -: 1679:   {
        -: 1680:      const Compare &key_cmp = this->m_data.get_comp();
        -: 1681:      KeyOfValue key_extract;
        -: 1682:      RanIt lb(this->priv_lower_bound(first, last, k)), ub(lb);
        -: 1683:      if(lb != last && !key_cmp(k, key_extract(*lb))){
        -: 1684:         ++ub;
        -: 1685:      }
        -: 1686:      return std::pair<RanIt, RanIt>(lb, ub);
        -: 1687:   }
        -: 1688:};
        -: 1689:
        -: 1690:}  //namespace dtl {
        -: 1691:
        -: 1692:}  //namespace container {
        -: 1693:
        -: 1694://!has_trivial_destructor_after_move<> == true_type
        -: 1695://!specialization for optimizations
        -: 1696:template <class T, class KeyOfValue,
        -: 1697:class Compare, class AllocatorOrContainer>
        -: 1698:struct has_trivial_destructor_after_move<boost::container::dtl::flat_tree<T, KeyOfValue, Compare, AllocatorOrContainer> >
        -: 1699:{
        -: 1700:   typedef boost::container::dtl::flat_tree<T, KeyOfValue, Compare, AllocatorOrContainer> flat_tree;
        -: 1701:   typedef typename flat_tree::container_type container_type;
        -: 1702:   typedef typename flat_tree::key_compare key_compare;
        -: 1703:   static const bool value = ::boost::has_trivial_destructor_after_move<container_type>::value &&
        -: 1704:                             ::boost::has_trivial_destructor_after_move<key_compare>::value;
        -: 1705:};
        -: 1706:
        -: 1707:}  //namespace boost {
        -: 1708:
        -: 1709:#include <boost/container/detail/config_end.hpp>
        -: 1710:
        -: 1711:#endif // BOOST_CONTAINER_FLAT_TREE_HPP
