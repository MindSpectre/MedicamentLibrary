        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/boost/container/detail/advanced_insert_int.hpp
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Patient_Base.dir/patient/test_patient_base.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Patient_Base.dir/patient/test_patient_base.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3:// (C) Copyright Ion Gaztanaga 2008-2013. Distributed under the Boost
        -:    4:// Software License, Version 1.0. (See accompanying file
        -:    5:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    6://
        -:    7:// See http://www.boost.org/libs/container for documentation.
        -:    8://
        -:    9://////////////////////////////////////////////////////////////////////////////
        -:   10:
        -:   11:#ifndef BOOST_CONTAINER_ADVANCED_INSERT_INT_HPP
        -:   12:#define BOOST_CONTAINER_ADVANCED_INSERT_INT_HPP
        -:   13:
        -:   14:#ifndef BOOST_CONFIG_HPP
        -:   15:#  include <boost/config.hpp>
        -:   16:#endif
        -:   17:
        -:   18:#if defined(BOOST_HAS_PRAGMA_ONCE)
        -:   19:#  pragma once
        -:   20:#endif
        -:   21:
        -:   22:#include <boost/container/detail/config_begin.hpp>
        -:   23:#include <boost/container/detail/workaround.hpp>
        -:   24:
        -:   25:// container
        -:   26:#include <boost/container/allocator_traits.hpp>
        -:   27:// container/detail
        -:   28:#include <boost/container/detail/copy_move_algo.hpp>
        -:   29:#include <boost/container/detail/destroyers.hpp>
        -:   30:#include <boost/container/detail/mpl.hpp>
        -:   31:#include <boost/container/detail/type_traits.hpp>
        -:   32:#include <boost/container/detail/iterator.hpp>
        -:   33:#include <boost/container/detail/iterators.hpp>
        -:   34:#include <boost/move/detail/iterator_to_raw_pointer.hpp>
        -:   35:#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:   36:#include <boost/move/detail/fwd_macros.hpp>
        -:   37:#endif
        -:   38:// move
        -:   39:
        -:   40:#include <boost/move/utility_core.hpp>
        -:   41:#include <boost/move/detail/force_ptr.hpp>
        -:   42:// other
        -:   43:#include <boost/assert.hpp>
        -:   44:
        -:   45:namespace boost { namespace container { namespace dtl {
        -:   46:
        -:   47:template<class Allocator, class FwdIt>
        -:   48:struct move_insert_range_proxy
        -:   49:{
        -:   50:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -:   51:
        -:   52:   inline explicit move_insert_range_proxy(FwdIt first)
        -:   53:      :  first_(first)
        -:   54:   {}
        -:   55:
        -:   56:   template<class Iterator>
        -:   57:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n)
        -:   58:   {
        -:   59:      this->first_ = ::boost::container::uninitialized_move_alloc_n_source
        -:   60:         (a, this->first_, n, p);
        -:   61:   }
        -:   62:
        -:   63:   template<class Iterator>
        -:   64:   inline void copy_n_and_update(Allocator &, Iterator p, std::size_t n)
        -:   65:   {
        -:   66:      this->first_ = ::boost::container::move_n_source(this->first_, n, p);
        -:   67:   }
        -:   68:
        -:   69:   FwdIt first_;
        -:   70:};
        -:   71:
        -:   72:
        -:   73:template<class Allocator, class FwdIt>
        -:   74:struct insert_range_proxy
        -:   75:{
        -:   76:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -:   77:
        -:   78:   inline explicit insert_range_proxy(FwdIt first)
        -:   79:      :  first_(first)
        -:   80:   {}
        -:   81:
        -:   82:   template<class Iterator>
        -:   83:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n)
        -:   84:   {
        -:   85:      this->first_ = ::boost::container::uninitialized_copy_alloc_n_source(a, this->first_, n, p);
        -:   86:   }
        -:   87:
        -:   88:   template<class Iterator>
        -:   89:   inline void copy_n_and_update(Allocator &, Iterator p, std::size_t n)
        -:   90:   {
        -:   91:      this->first_ = ::boost::container::copy_n_source(this->first_, n, p);
        -:   92:   }
        -:   93:
        -:   94:   FwdIt first_;
        -:   95:};
        -:   96:
        -:   97:
        -:   98:template<class Allocator>
        -:   99:struct insert_n_copies_proxy
        -:  100:{
        -:  101:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -:  102:
        -:  103:   inline explicit insert_n_copies_proxy(const value_type &v)
        -:  104:      :  v_(v)
        -:  105:   {}
        -:  106:
        -:  107:   template<class Iterator>
        -:  108:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n) const
        -:  109:   {  boost::container::uninitialized_fill_alloc_n(a, v_, n, p);  }
        -:  110:
        -:  111:   template<class Iterator>
        -:  112:   inline void copy_n_and_update(Allocator &, Iterator p, std::size_t n) const
        -:  113:   {
        -:  114:      while (n){
        -:  115:         --n;
        -:  116:         *p = v_;
        -:  117:         ++p;
        -:  118:      }
        -:  119:   }
        -:  120:
        -:  121:   const value_type &v_;
        -:  122:};
        -:  123:
        -:  124:template<class Allocator>
        -:  125:struct insert_value_initialized_n_proxy
        -:  126:{
        -:  127:   typedef ::boost::container::allocator_traits<Allocator> alloc_traits;
        -:  128:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -:  129:   typedef typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type storage_t;
        -:  130:
        -:  131:   template<class Iterator>
        -:  132:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n) const
        -:  133:   {  boost::container::uninitialized_value_init_alloc_n(a, n, p);  }
        -:  134:
        -:  135:   template<class Iterator>
        -:  136:   void copy_n_and_update(Allocator &a, Iterator p, std::size_t n) const
        -:  137:   {
        -:  138:      while (n){
        -:  139:         --n;
        -:  140:         storage_t v;
        -:  141:         alloc_traits::construct(a, move_detail::force_ptr<value_type *>(&v));
        -:  142:         value_type *vp = move_detail::force_ptr<value_type *>(&v);
        -:  143:         value_destructor<Allocator> on_exit(a, *vp); (void)on_exit;
        -:  144:         *p = ::boost::move(*vp);
        -:  145:         ++p;
        -:  146:      }
        -:  147:   }
        -:  148:};
        -:  149:
        -:  150:template<class Allocator>
        -:  151:struct insert_default_initialized_n_proxy
        -:  152:{
        -:  153:   typedef ::boost::container::allocator_traits<Allocator> alloc_traits;
        -:  154:   typedef typename allocator_traits<Allocator>::value_type value_type;
        -:  155:   typedef typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type storage_t;
        -:  156:
        -:  157:   template<class Iterator>
        -:  158:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n) const
        -:  159:   {  boost::container::uninitialized_default_init_alloc_n(a, n, p);  }
        -:  160:
        -:  161:   template<class Iterator>
        -:  162:   void copy_n_and_update(Allocator &a, Iterator p, std::size_t n) const
        -:  163:   {
        -:  164:      if(!is_pod<value_type>::value){
        -:  165:         while (n){
        -:  166:            --n;
        -:  167:            typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;
        -:  168:            alloc_traits::construct(a, move_detail::force_ptr<value_type *>(&v), default_init);
        -:  169:            value_type *vp = move_detail::force_ptr<value_type *>(&v);
        -:  170:            value_destructor<Allocator> on_exit(a, *vp); (void)on_exit;
        -:  171:            *p = ::boost::move(*vp);
        -:  172:            ++p;
        -:  173:         }
        -:  174:      }
        -:  175:   }
        -:  176:};
        -:  177:
        -:  178:template<class Allocator>
        -:  179:struct insert_copy_proxy
        -:  180:{
        -:  181:   typedef boost::container::allocator_traits<Allocator> alloc_traits;
        -:  182:   typedef typename alloc_traits::value_type value_type;
        -:  183:
        -:  184:   static const bool single_value = true;
        -:  185:
        -:  186:   inline explicit insert_copy_proxy(const value_type &v)
        -:  187:      :  v_(v)
        -:  188:   {}
        -:  189:
        -:  190:   template<class Iterator>
        -:  191:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n) const
        -:  192:   {
        -:  193:      BOOST_ASSERT(n == 1);  (void)n;
        -:  194:      alloc_traits::construct( a, boost::movelib::iterator_to_raw_pointer(p), v_);
        -:  195:   }
        -:  196:
        -:  197:   template<class Iterator>
        -:  198:   inline void copy_n_and_update(Allocator &, Iterator p, std::size_t n) const
        -:  199:   {
        -:  200:      BOOST_ASSERT(n == 1);  (void)n;
        -:  201:      *p = v_;
        -:  202:   }
        -:  203:
        -:  204:   const value_type &v_;
        -:  205:};
        -:  206:
        -:  207:
        -:  208:template<class Allocator>
        -:  209:struct insert_move_proxy
        -:  210:{
        -:  211:   typedef boost::container::allocator_traits<Allocator> alloc_traits;
        -:  212:   typedef typename alloc_traits::value_type value_type;
        -:  213:
        -:  214:   static const bool single_value = true;
        -:  215:
function _ZN5boost9container3dtl17insert_move_proxyINS0_13new_allocatorINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEEC2ERSG_ called 0 returned 0% blocks executed 0%
    #####:  216:   inline explicit insert_move_proxy(value_type &v)
    #####:  217:      :  v_(v)
    #####:  218:   {}
    $$$$$:  218-block  0
        -:  219:
        -:  220:   template<class Iterator>
function _ZNK5boost9container3dtl17insert_move_proxyINS0_13new_allocatorINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE31uninitialized_copy_n_and_updateIPSG_EEvRSH_T_m called 0 returned 0% blocks executed 0%
    #####:  221:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n) const
        -:  222:   {
    #####:  223:      BOOST_ASSERT(n == 1);  (void)n;
    $$$$$:  223-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  223-block  1
    $$$$$:  223-block  2
    $$$$$:  223-block  3
    #####:  224:      alloc_traits::construct( a, boost::movelib::iterator_to_raw_pointer(p), ::boost::move(v_) );
    #####:  225:   }
    $$$$$:  225-block  0
        -:  226:
        -:  227:   template<class Iterator>
function _ZNK5boost9container3dtl17insert_move_proxyINS0_13new_allocatorINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE17copy_n_and_updateIPSG_EEvRSH_T_m called 0 returned 0% blocks executed 0%
    #####:  228:   inline void copy_n_and_update(Allocator &, Iterator p, std::size_t n) const
        -:  229:   {
    #####:  230:      BOOST_ASSERT(n == 1);  (void)n;
    $$$$$:  230-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  230-block  1
    $$$$$:  230-block  2
    $$$$$:  230-block  3
    #####:  231:      *p = ::boost::move(v_);
    #####:  232:   }
    $$$$$:  232-block  0
        -:  233:
        -:  234:   value_type &v_;
        -:  235:};
        -:  236:
        -:  237:template<class It, class Allocator>
        -:  238:inline insert_move_proxy<Allocator> get_insert_value_proxy(BOOST_RV_REF(typename boost::container::iterator_traits<It>::value_type) v)
        -:  239:{
        -:  240:   return insert_move_proxy<Allocator>(v);
        -:  241:}
        -:  242:
        -:  243:template<class It, class Allocator>
        -:  244:inline insert_copy_proxy<Allocator> get_insert_value_proxy(const typename boost::container::iterator_traits<It>::value_type &v)
        -:  245:{
        -:  246:   return insert_copy_proxy<Allocator>(v);
        -:  247:}
        -:  248:
        -:  249:}}}   //namespace boost { namespace container { namespace dtl {
        -:  250:
        -:  251:#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  252:
        -:  253:#include <boost/container/detail/variadic_templates_tools.hpp>
        -:  254:#include <boost/move/utility_core.hpp>
        -:  255:
        -:  256:namespace boost {
        -:  257:namespace container {
        -:  258:namespace dtl {
        -:  259:
        -:  260:template<class Allocator, class ...Args>
        -:  261:struct insert_nonmovable_emplace_proxy
        -:  262:{
        -:  263:   typedef boost::container::allocator_traits<Allocator>   alloc_traits;
        -:  264:   typedef typename alloc_traits::value_type       value_type;
        -:  265:   typedef typename build_number_seq<sizeof...(Args)>::type index_tuple_t;
        -:  266:
        -:  267:   static const bool single_value = true;
        -:  268:
        -:  269:   inline explicit insert_nonmovable_emplace_proxy(BOOST_FWD_REF(Args)... args)
        -:  270:      : args_(args...)
        -:  271:   {}
        -:  272:
        -:  273:   template<class Iterator>
        -:  274:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n)
        -:  275:   {  this->priv_uninitialized_copy_some_and_update(a, index_tuple_t(), p, n);  }
        -:  276:
        -:  277:   private:
        -:  278:   template<std::size_t ...IdxPack, class Iterator>
        -:  279:   inline void priv_uninitialized_copy_some_and_update(Allocator &a, const index_tuple<IdxPack...>&, Iterator p, std::size_t n)
        -:  280:   {
        -:  281:      BOOST_ASSERT(n == 1); (void)n;
        -:  282:      alloc_traits::construct( a, boost::movelib::iterator_to_raw_pointer(p), ::boost::forward<Args>(get<IdxPack>(this->args_))... );
        -:  283:   }
        -:  284:
        -:  285:   protected:
        -:  286:   tuple<Args&...> args_;
        -:  287:};
        -:  288:
        -:  289:template<class Allocator, class ...Args>
        -:  290:struct insert_emplace_proxy
        -:  291:   :  public insert_nonmovable_emplace_proxy<Allocator, Args...>
        -:  292:{
        -:  293:   typedef insert_nonmovable_emplace_proxy<Allocator, Args...> base_t;
        -:  294:   typedef boost::container::allocator_traits<Allocator>   alloc_traits;
        -:  295:   typedef typename base_t::value_type             value_type;
        -:  296:   typedef typename base_t::index_tuple_t          index_tuple_t;
        -:  297:
        -:  298:   static const bool single_value = true;
        -:  299:
        -:  300:   inline explicit insert_emplace_proxy(BOOST_FWD_REF(Args)... args)
        -:  301:      : base_t(::boost::forward<Args>(args)...)
        -:  302:   {}
        -:  303:
        -:  304:   template<class Iterator>
        -:  305:   inline void copy_n_and_update(Allocator &a, Iterator p, std::size_t n)
        -:  306:   {  this->priv_copy_some_and_update(a, index_tuple_t(), p, n);  }
        -:  307:
        -:  308:   private:
        -:  309:
        -:  310:   template<std::size_t ...IdxPack, class Iterator>
        -:  311:   inline void priv_copy_some_and_update(Allocator &a, const index_tuple<IdxPack...>&, Iterator p, std::size_t n)
        -:  312:   {
        -:  313:      BOOST_ASSERT(n ==1); (void)n;
        -:  314:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;
        -:  315:      alloc_traits::construct(a, move_detail::force_ptr<value_type *>(&v), ::boost::forward<Args>(get<IdxPack>(this->args_))...);
        -:  316:      value_type *vp = move_detail::force_ptr<value_type *>(&v);
        -:  317:      BOOST_CONTAINER_TRY{
        -:  318:         *p = ::boost::move(*vp);
        -:  319:      }
        -:  320:      BOOST_CONTAINER_CATCH(...){
        -:  321:         alloc_traits::destroy(a, vp);
        -:  322:         BOOST_CONTAINER_RETHROW
        -:  323:      }
        -:  324:      BOOST_CONTAINER_CATCH_END
        -:  325:      alloc_traits::destroy(a, vp);
        -:  326:   }
        -:  327:};
        -:  328:
        -:  329://Specializations to avoid an unneeded temporary when emplacing from a single argument o type value_type
        -:  330:template<class Allocator>
        -:  331:struct insert_emplace_proxy<Allocator, typename boost::container::allocator_traits<Allocator>::value_type>
        -:  332:   : public insert_move_proxy<Allocator>
        -:  333:{
        -:  334:   static const bool single_value = true;
        -:  335:
function _ZN5boost9container3dtl20insert_emplace_proxyINS0_13new_allocatorINS1_4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEJSG_EEC2EOSG_ called 0 returned 0% blocks executed 0%
    #####:  336:   inline explicit insert_emplace_proxy(typename boost::container::allocator_traits<Allocator>::value_type &&v)
    #####:  337:   : insert_move_proxy<Allocator>(v)
    #####:  338:   {}
    $$$$$:  338-block  0
        -:  339:};
        -:  340:
        -:  341://We use "add_const" here as adding "const" only confuses MSVC12(and maybe later) provoking
        -:  342://compiler error C2752 ("more than one partial specialization matches").
        -:  343://Any problem is solvable with an extra layer of indirection? ;-)
        -:  344:template<class Allocator>
        -:  345:struct insert_emplace_proxy<Allocator
        -:  346:   , typename boost::container::dtl::add_const<typename boost::container::allocator_traits<Allocator>::value_type>::type
        -:  347:   >
        -:  348:   : public insert_copy_proxy<Allocator>
        -:  349:{
        -:  350:
        -:  351:   static const bool single_value = true;
        -:  352:
        -:  353:   inline explicit insert_emplace_proxy(const typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  354:   : insert_copy_proxy<Allocator>(v)
        -:  355:   {}
        -:  356:};
        -:  357:
        -:  358:template<class Allocator>
        -:  359:struct insert_emplace_proxy<Allocator, typename boost::container::allocator_traits<Allocator>::value_type &>
        -:  360:   : public insert_copy_proxy<Allocator>
        -:  361:{
        -:  362:   static const bool single_value = true;
        -:  363:
        -:  364:   inline explicit insert_emplace_proxy(const typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  365:   : insert_copy_proxy<Allocator>(v)
        -:  366:   {}
        -:  367:};
        -:  368:
        -:  369:template<class Allocator>
        -:  370:struct insert_emplace_proxy<Allocator
        -:  371:   , typename boost::container::dtl::add_const<typename boost::container::allocator_traits<Allocator>::value_type>::type &
        -:  372:   >
        -:  373:   : public insert_copy_proxy<Allocator>
        -:  374:{
        -:  375:   static const bool single_value = true;
        -:  376:
        -:  377:   inline explicit insert_emplace_proxy(const typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  378:   : insert_copy_proxy<Allocator>(v)
        -:  379:   {}
        -:  380:};
        -:  381:
        -:  382:}}}   //namespace boost { namespace container { namespace dtl {
        -:  383:
        -:  384:#else // !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  385:
        -:  386:#include <boost/container/detail/value_init.hpp>
        -:  387:
        -:  388:namespace boost {
        -:  389:namespace container {
        -:  390:namespace dtl {
        -:  391:
        -:  392:#define BOOST_CONTAINER_ADVANCED_INSERT_INT_CODE(N) \
        -:  393:template< class Allocator BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  394:struct insert_nonmovable_emplace_proxy##N\
        -:  395:{\
        -:  396:   typedef boost::container::allocator_traits<Allocator> alloc_traits;\
        -:  397:   typedef typename alloc_traits::value_type value_type;\
        -:  398:   \
        -:  399:   static const bool single_value = true;\
        -:  400:   \
        -:  401:   inline explicit insert_nonmovable_emplace_proxy##N(BOOST_MOVE_UREF##N)\
        -:  402:      BOOST_MOVE_COLON##N BOOST_MOVE_FWD_INIT##N {}\
        -:  403:   \
        -:  404:   template<class Iterator>\
        -:  405:   inline void uninitialized_copy_n_and_update(Allocator &a, Iterator p, std::size_t n)\
        -:  406:   {\
        -:  407:      BOOST_ASSERT(n == 1); (void)n;\
        -:  408:      alloc_traits::construct(a, boost::movelib::iterator_to_raw_pointer(p) BOOST_MOVE_I##N BOOST_MOVE_MFWD##N);\
        -:  409:   }\
        -:  410:   \
        -:  411:   template<class Iterator>\
        -:  412:   inline void copy_n_and_update(Allocator &, Iterator, std::size_t)\
        -:  413:   {  BOOST_ASSERT(false);   }\
        -:  414:   \
        -:  415:   protected:\
        -:  416:   BOOST_MOVE_MREF##N\
        -:  417:};\
        -:  418:\
        -:  419:template< class Allocator BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  420:struct insert_emplace_proxy_arg##N\
        -:  421:   : insert_nonmovable_emplace_proxy##N< Allocator BOOST_MOVE_I##N BOOST_MOVE_TARG##N >\
        -:  422:{\
        -:  423:   typedef insert_nonmovable_emplace_proxy##N\
        -:  424:      < Allocator BOOST_MOVE_I##N BOOST_MOVE_TARG##N > base_t;\
        -:  425:   typedef typename base_t::value_type value_type;\
        -:  426:   typedef boost::container::allocator_traits<Allocator> alloc_traits;\
        -:  427:   \
        -:  428:   static const bool single_value = true;\
        -:  429:   \
        -:  430:   inline explicit insert_emplace_proxy_arg##N(BOOST_MOVE_UREF##N)\
        -:  431:      : base_t(BOOST_MOVE_FWD##N){}\
        -:  432:   \
        -:  433:   template<class Iterator>\
        -:  434:   inline void copy_n_and_update(Allocator &a, Iterator p, std::size_t n)\
        -:  435:   {\
        -:  436:      BOOST_ASSERT(n == 1); (void)n;\
        -:  437:      typename dtl::aligned_storage<sizeof(value_type), dtl::alignment_of<value_type>::value>::type v;\
        -:  438:      alloc_traits::construct(a, move_detail::force_ptr<value_type *>(&v) BOOST_MOVE_I##N BOOST_MOVE_MFWD##N);\
        -:  439:      value_type *vp = move_detail::force_ptr<value_type *>(&v);\
        -:  440:      BOOST_CONTAINER_TRY{\
        -:  441:         *p = ::boost::move(*vp);\
        -:  442:      }\
        -:  443:      BOOST_CONTAINER_CATCH(...){\
        -:  444:         alloc_traits::destroy(a, vp);\
        -:  445:         BOOST_CONTAINER_RETHROW\
        -:  446:      }\
        -:  447:      BOOST_CONTAINER_CATCH_END\
        -:  448:      alloc_traits::destroy(a, vp);\
        -:  449:   }\
        -:  450:};\
        -:  451://
        -:  452:BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_ADVANCED_INSERT_INT_CODE)
        -:  453:#undef BOOST_CONTAINER_ADVANCED_INSERT_INT_CODE
        -:  454:
        -:  455:#if defined(BOOST_NO_CXX11_RVALUE_REFERENCES)
        -:  456:
        -:  457://Specializations to avoid an unneeded temporary when emplacing from a single argument o type value_type
        -:  458:template<class Allocator>
        -:  459:struct insert_emplace_proxy_arg1<Allocator, ::boost::rv<typename boost::container::allocator_traits<Allocator>::value_type> >
        -:  460:   : public insert_move_proxy<Allocator>
        -:  461:{
        -:  462:   static const bool single_value = true;
        -:  463:
        -:  464:   inline explicit insert_emplace_proxy_arg1(typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  465:   : insert_move_proxy<Allocator>(v)
        -:  466:   {}
        -:  467:};
        -:  468:
        -:  469:template<class Allocator>
        -:  470:struct insert_emplace_proxy_arg1<Allocator, typename boost::container::allocator_traits<Allocator>::value_type>
        -:  471:   : public insert_copy_proxy<Allocator>
        -:  472:{
        -:  473:   static const bool single_value = true;
        -:  474:
        -:  475:   inline explicit insert_emplace_proxy_arg1(const typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  476:   : insert_copy_proxy<Allocator>(v)
        -:  477:   {}
        -:  478:};
        -:  479:
        -:  480:#else //e.g. MSVC10 & MSVC11
        -:  481:
        -:  482://Specializations to avoid an unneeded temporary when emplacing from a single argument o type value_type
        -:  483:template<class Allocator>
        -:  484:struct insert_emplace_proxy_arg1<Allocator, typename boost::container::allocator_traits<Allocator>::value_type>
        -:  485:   : public insert_move_proxy<Allocator>
        -:  486:{
        -:  487:   static const bool single_value = true;
        -:  488:
        -:  489:   inline explicit insert_emplace_proxy_arg1(typename boost::container::allocator_traits<Allocator>::value_type &&v)
        -:  490:   : insert_move_proxy<Allocator>(v)
        -:  491:   {}
        -:  492:};
        -:  493:
        -:  494://We use "add_const" here as adding "const" only confuses MSVC10&11 provoking
        -:  495://compiler error C2752 ("more than one partial specialization matches").
        -:  496://Any problem is solvable with an extra layer of indirection? ;-)
        -:  497:template<class Allocator>
        -:  498:struct insert_emplace_proxy_arg1<Allocator
        -:  499:   , typename boost::container::dtl::add_const<typename boost::container::allocator_traits<Allocator>::value_type>::type
        -:  500:   >
        -:  501:   : public insert_copy_proxy<Allocator>
        -:  502:{
        -:  503:   static const bool single_value = true;
        -:  504:
        -:  505:   inline explicit insert_emplace_proxy_arg1(const typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  506:   : insert_copy_proxy<Allocator>(v)
        -:  507:   {}
        -:  508:};
        -:  509:
        -:  510:template<class Allocator>
        -:  511:struct insert_emplace_proxy_arg1<Allocator, typename boost::container::allocator_traits<Allocator>::value_type &>
        -:  512:   : public insert_copy_proxy<Allocator>
        -:  513:{
        -:  514:   static const bool single_value = true;
        -:  515:
        -:  516:   inline explicit insert_emplace_proxy_arg1(const typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  517:   : insert_copy_proxy<Allocator>(v)
        -:  518:   {}
        -:  519:};
        -:  520:
        -:  521:template<class Allocator>
        -:  522:struct insert_emplace_proxy_arg1<Allocator
        -:  523:   , typename boost::container::dtl::add_const<typename boost::container::allocator_traits<Allocator>::value_type>::type &
        -:  524:   >
        -:  525:   : public insert_copy_proxy<Allocator>
        -:  526:{
        -:  527:   static const bool single_value = true;
        -:  528:
        -:  529:   inline explicit insert_emplace_proxy_arg1(const typename boost::container::allocator_traits<Allocator>::value_type &v)
        -:  530:   : insert_copy_proxy<Allocator>(v)
        -:  531:   {}
        -:  532:};
        -:  533:
        -:  534:#endif
        -:  535:
        -:  536:}}}   //namespace boost { namespace container { namespace dtl {
        -:  537:
        -:  538:#endif   // !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  539:
        -:  540:#include <boost/container/detail/config_end.hpp>
        -:  541:
        -:  542:#endif //#ifndef BOOST_CONTAINER_ADVANCED_INSERT_INT_HPP
