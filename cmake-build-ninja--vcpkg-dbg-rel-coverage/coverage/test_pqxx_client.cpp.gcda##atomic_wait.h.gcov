        -:    0:Source:/usr/include/c++/12/bits/atomic_wait.h
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/CMakeFiles/DrugLib_Tests_Unit_PqxxClient.dir/unit_tests/pqxx_client/test_pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/CMakeFiles/DrugLib_Tests_Unit_PqxxClient.dir/unit_tests/pqxx_client/test_pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*- header.
        -:    2:
        -:    3:// Copyright (C) 2020-2022 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file bits/atomic_wait.h
        -:   26: *  This is an internal header file, included by other library headers.
        -:   27: *  Do not attempt to use it directly. @headername{atomic}
        -:   28: */
        -:   29:
        -:   30:#ifndef _GLIBCXX_ATOMIC_WAIT_H
        -:   31:#define _GLIBCXX_ATOMIC_WAIT_H 1
        -:   32:
        -:   33:#pragma GCC system_header
        -:   34:
        -:   35:#include <bits/c++config.h>
        -:   36:#if defined _GLIBCXX_HAS_GTHREADS || defined _GLIBCXX_HAVE_LINUX_FUTEX
        -:   37:#include <bits/functional_hash.h>
        -:   38:#include <bits/gthr.h>
        -:   39:#include <ext/numeric_traits.h>
        -:   40:
        -:   41:#ifdef _GLIBCXX_HAVE_LINUX_FUTEX
        -:   42:# include <cerrno>
        -:   43:# include <climits>
        -:   44:# include <unistd.h>
        -:   45:# include <syscall.h>
        -:   46:# include <bits/functexcept.h>
        -:   47:#endif
        -:   48:
        -:   49:# include <bits/std_mutex.h>  // std::mutex, std::__condvar
        -:   50:
        -:   51:#define __cpp_lib_atomic_wait 201907L
        -:   52:
        -:   53:namespace std _GLIBCXX_VISIBILITY(default)
        -:   54:{
        -:   55:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   56:  namespace __detail
        -:   57:  {
        -:   58:#ifdef _GLIBCXX_HAVE_LINUX_FUTEX
        -:   59:#define _GLIBCXX_HAVE_PLATFORM_WAIT 1
        -:   60:    using __platform_wait_t = int;
        -:   61:    inline constexpr size_t __platform_wait_alignment = 4;
        -:   62:#else
        -:   63:// define _GLIBCX_HAVE_PLATFORM_WAIT and implement __platform_wait()
        -:   64:// and __platform_notify() if there is a more efficient primitive supported
        -:   65:// by the platform (e.g. __ulock_wait()/__ulock_wake()) which is better than
        -:   66:// a mutex/condvar based wait.
        -:   67:    using __platform_wait_t = uint64_t;
        -:   68:    inline constexpr size_t __platform_wait_alignment
        -:   69:      = __alignof__(__platform_wait_t);
        -:   70:#endif
        -:   71:  } // namespace __detail
        -:   72:
        -:   73:  template<typename _Tp>
        -:   74:    inline constexpr bool __platform_wait_uses_type
        -:   75:#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT
        -:   76:      = is_scalar_v<_Tp>
        -:   77:	&& ((sizeof(_Tp) == sizeof(__detail::__platform_wait_t))
        -:   78:	&& (alignof(_Tp*) >= __detail::__platform_wait_alignment));
        -:   79:#else
        -:   80:      = false;
        -:   81:#endif
        -:   82:
        -:   83:  namespace __detail
        -:   84:  {
        -:   85:#ifdef _GLIBCXX_HAVE_LINUX_FUTEX
        -:   86:    enum class __futex_wait_flags : int
        -:   87:    {
        -:   88:#ifdef _GLIBCXX_HAVE_LINUX_FUTEX_PRIVATE
        -:   89:      __private_flag = 128,
        -:   90:#else
        -:   91:      __private_flag = 0,
        -:   92:#endif
        -:   93:      __wait = 0,
        -:   94:      __wake = 1,
        -:   95:      __wait_bitset = 9,
        -:   96:      __wake_bitset = 10,
        -:   97:      __wait_private = __wait | __private_flag,
        -:   98:      __wake_private = __wake | __private_flag,
        -:   99:      __wait_bitset_private = __wait_bitset | __private_flag,
        -:  100:      __wake_bitset_private = __wake_bitset | __private_flag,
        -:  101:      __bitset_match_any = -1
        -:  102:    };
        -:  103:
        -:  104:    template<typename _Tp>
        -:  105:      void
function _ZNSt8__detail15__platform_waitIiEEvPKT_i called 0 returned 0% blocks executed 0%
    #####:  106:      __platform_wait(const _Tp* __addr, __platform_wait_t __val) noexcept
        -:  107:      {
    #####:  108:	auto __e = syscall (SYS_futex, static_cast<const void*>(__addr),
        -:  109:			    static_cast<int>(__futex_wait_flags::__wait_private),
    #####:  110:			    __val, nullptr);
    #####:  111:	if (!__e || errno == EAGAIN)
    $$$$$:  111-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  111-block  1
branch  2 never executed
branch  3 never executed
    #####:  112:	  return;
    $$$$$:  112-block  0
    #####:  113:	if (errno != EINTR)
    $$$$$:  113-block  0
branch  0 never executed
branch  1 never executed
    #####:  114:	  __throw_system_error(errno);
    $$$$$:  114-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  114-block  1
    $$$$$:  114-block  2
    #####:  115:      }
    $$$$$:  115-block  0
        -:  116:
        -:  117:    template<typename _Tp>
        -:  118:      void
function _ZNSt8__detail17__platform_notifyIiEEvPKT_b called 1 returned 100% blocks executed 100%
        1:  119:      __platform_notify(const _Tp* __addr, bool __all) noexcept
        -:  120:      {
        2:  121:	syscall (SYS_futex, static_cast<const void*>(__addr),
        -:  122:		 static_cast<int>(__futex_wait_flags::__wake_private),
        1:  123:		 __all ? INT_MAX : 1);
        1:  124:      }
        1:  124-block  0
        -:  125:#endif
        -:  126:
        -:  127:    inline void
function _ZNSt8__detail14__thread_yieldEv called 0 returned 0% blocks executed 0%
    #####:  128:    __thread_yield() noexcept
        -:  129:    {
        -:  130:#if defined _GLIBCXX_HAS_GTHREADS && defined _GLIBCXX_USE_SCHED_YIELD
    #####:  131:     __gthread_yield();
    $$$$$:  131-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  131-block  1
        -:  132:#endif
    #####:  133:    }
    $$$$$:  133-block  0
        -:  134:
        -:  135:    inline void
function _ZNSt8__detail14__thread_relaxEv called 0 returned 0% blocks executed 0%
    #####:  136:    __thread_relax() noexcept
        -:  137:    {
        -:  138:#if defined __i386__ || defined __x86_64__
    #####:  139:      __builtin_ia32_pause();
        -:  140:#else
        -:  141:      __thread_yield();
        -:  142:#endif
    #####:  143:    }
    $$$$$:  143-block  0
        -:  144:
        -:  145:    inline constexpr auto __atomic_spin_count_relax = 12;
        -:  146:    inline constexpr auto __atomic_spin_count = 16;
        -:  147:
        -:  148:    struct __default_spin_policy
        -:  149:    {
        -:  150:      bool
function _ZNKSt8__detail21__default_spin_policyclEv called 0 returned 0% blocks executed 0%
    #####:  151:      operator()() const noexcept
    #####:  152:      { return false; }
    $$$$$:  152-block  0
        -:  153:    };
        -:  154:
        -:  155:    template<typename _Pred,
        -:  156:	     typename _Spin = __default_spin_policy>
        -:  157:      bool
function _ZNSt8__detail13__atomic_spinIZNKSt14__tree_barrierISt18__empty_completionE4waitEOSt17__barrier_phase_tEUlvE_NS_21__default_spin_policyEEEbRT_T0_ called 2 returned 100% blocks executed 31%
        2:  158:      __atomic_spin(_Pred& __pred, _Spin __spin = _Spin{ }) noexcept
        -:  159:      {
        2:  160:	for (auto __i = 0; __i < __atomic_spin_count; ++__i)
        2:  160-block  0
        2:  160-block  1
branch  0 taken 2
branch  1 taken 0
    $$$$$:  160-block  2
        -:  161:	  {
        2:  162:	    if (__pred())
        2:  162-block  0
branch  0 taken 2
branch  1 taken 0
        2:  162-block  1
branch  2 taken 2
branch  3 taken 0
    $$$$$:  162-block  2
        2:  163:	      return true;
        2:  163-block  0
        -:  164:
    #####:  165:	    if (__i < __atomic_spin_count_relax)
    $$$$$:  165-block  0
branch  0 never executed
branch  1 never executed
    #####:  166:	      __detail::__thread_relax();
    $$$$$:  166-block  0
        -:  167:	    else
    #####:  168:	      __detail::__thread_yield();
    $$$$$:  168-block  0
    #####:  169:	  }
    $$$$$:  169-block  0
        -:  170:
    #####:  171:	while (__spin())
    $$$$$:  171-block  0
    $$$$$:  171-block  1
branch  0 never executed
branch  1 never executed
    $$$$$:  171-block  2
        -:  172:	  {
    #####:  173:	    if (__pred())
    $$$$$:  173-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  173-block  1
branch  2 never executed
branch  3 never executed
    #####:  174:	      return true;
    $$$$$:  174-block  0
        -:  175:	  }
        -:  176:
    #####:  177:	return false;
    $$$$$:  177-block  0
        2:  178:      }
        2:  178-block  0
        -:  179:
        -:  180:    // return true if equal
        -:  181:    template<typename _Tp>
        -:  182:      bool __atomic_compare(const _Tp& __a, const _Tp& __b)
        -:  183:      {
        -:  184:	// TODO make this do the correct padding bit ignoring comparison
        -:  185:	return __builtin_memcmp(&__a, &__b, sizeof(_Tp)) == 0;
        -:  186:      }
        -:  187:
        -:  188:    struct __waiter_pool_base
        -:  189:    {
        -:  190:      // Don't use std::hardware_destructive_interference_size here because we
        -:  191:      // don't want the layout of library types to depend on compiler options.
        -:  192:      static constexpr auto _S_align = 64;
        -:  193:
        -:  194:      alignas(_S_align) __platform_wait_t _M_wait = 0;
        -:  195:
        -:  196:#ifndef _GLIBCXX_HAVE_PLATFORM_WAIT
        -:  197:      mutex _M_mtx;
        -:  198:#endif
        -:  199:
        -:  200:      alignas(_S_align) __platform_wait_t _M_ver = 0;
        -:  201:
        -:  202:#ifndef _GLIBCXX_HAVE_PLATFORM_WAIT
        -:  203:      __condvar _M_cv;
        -:  204:#endif
        -:  205:      __waiter_pool_base() = default;
        -:  206:
        -:  207:      void
function _ZNSt8__detail18__waiter_pool_base13_M_enter_waitEv called 2 returned 100% blocks executed 100%
        2:  208:      _M_enter_wait() noexcept
        2:  209:      { __atomic_fetch_add(&_M_wait, 1, __ATOMIC_SEQ_CST); }
        2:  209-block  0
        -:  210:
        -:  211:      void
function _ZNSt8__detail18__waiter_pool_base13_M_leave_waitEv called 2 returned 100% blocks executed 100%
        2:  212:      _M_leave_wait() noexcept
        2:  213:      { __atomic_fetch_sub(&_M_wait, 1, __ATOMIC_RELEASE); }
        2:  213-block  0
        -:  214:
        -:  215:      bool
function _ZNKSt8__detail18__waiter_pool_base10_M_waitingEv called 1 returned 100% blocks executed 100%
        1:  216:      _M_waiting() const noexcept
        -:  217:      {
        -:  218:	__platform_wait_t __res;
        1:  219:	__atomic_load(&_M_wait, &__res, __ATOMIC_SEQ_CST);
        1:  220:	return __res != 0;
        1:  220-block  0
        -:  221:      }
        -:  222:
        -:  223:      void
function _ZNSt8__detail18__waiter_pool_base9_M_notifyEPibb called 1 returned 100% blocks executed 100%
        1:  224:      _M_notify(__platform_wait_t* __addr, [[maybe_unused]] bool __all,
        -:  225:		bool __bare) noexcept
        -:  226:      {
        -:  227:#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT
        1:  228:	if (__addr == &_M_ver)
        1:  228-block  0
branch  0 taken 0
branch  1 taken 1
        -:  229:	  {
        1:  230:	    __atomic_fetch_add(__addr, 1, __ATOMIC_SEQ_CST);
        1:  231:	    __all = true;
        1:  232:	  }
        1:  232-block  0
        -:  233:
        1:  234:	if (__bare || _M_waiting())
        1:  234-block  0
branch  0 taken 1
branch  1 taken 0
        1:  234-block  1
branch  2 taken 0
branch  3 taken 1
        1:  235:	  __platform_notify(__addr, __all);
        1:  235-block  0
        -:  236:#else
        -:  237:	{
        -:  238:	  lock_guard<mutex> __l(_M_mtx);
        -:  239:	  __atomic_fetch_add(__addr, 1, __ATOMIC_RELAXED);
        -:  240:	}
        -:  241:	if (__bare || _M_waiting())
        -:  242:	  _M_cv.notify_all();
        -:  243:#endif
        1:  244:      }
        1:  244-block  0
        -:  245:
        -:  246:      static __waiter_pool_base&
function _ZNSt8__detail18__waiter_pool_base6_S_forEPKv called 3 returned 100% blocks executed 100%
        3:  247:      _S_for(const void* __addr) noexcept
        -:  248:      {
        3:  249:	constexpr uintptr_t __ct = 16;
        -:  250:	static __waiter_pool_base __w[__ct];
        3:  251:	auto __key = (uintptr_t(__addr) >> 2) % __ct;
        3:  252:	return __w[__key];
        3:  252-block  0
        -:  253:      }
        -:  254:    };
        -:  255:
        -:  256:    struct __waiter_pool : __waiter_pool_base
        -:  257:    {
        -:  258:      void
function _ZNSt8__detail13__waiter_pool10_M_do_waitEPKii called 0 returned 0% blocks executed 0%
    #####:  259:      _M_do_wait(const __platform_wait_t* __addr, __platform_wait_t __old) noexcept
        -:  260:      {
        -:  261:#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT
    #####:  262:	__platform_wait(__addr, __old);
        -:  263:#else
        -:  264:	__platform_wait_t __val;
        -:  265:	__atomic_load(__addr, &__val, __ATOMIC_SEQ_CST);
        -:  266:	if (__val == __old)
        -:  267:	  {
        -:  268:	    lock_guard<mutex> __l(_M_mtx);
        -:  269:	    __atomic_load(__addr, &__val, __ATOMIC_RELAXED);
        -:  270:	    if (__val == __old)
        -:  271:	      _M_cv.wait(_M_mtx);
        -:  272:	  }
        -:  273:#endif // __GLIBCXX_HAVE_PLATFORM_WAIT
    #####:  274:      }
    $$$$$:  274-block  0
        -:  275:    };
        -:  276:
        -:  277:    template<typename _Tp>
        -:  278:      struct __waiter_base
        -:  279:      {
        -:  280:	using __waiter_type = _Tp;
        -:  281:
        -:  282:	__waiter_type& _M_w;
        -:  283:	__platform_wait_t* _M_addr;
        -:  284:
        -:  285:	template<typename _Up>
        -:  286:	  static __platform_wait_t*
function _ZNSt8__detail13__waiter_baseINS_13__waiter_poolEE12_S_wait_addrISt17__barrier_phase_tEEPiPKT_S5_ called 3 returned 100% blocks executed 100%
        3:  287:	  _S_wait_addr(const _Up* __a, __platform_wait_t* __b)
        -:  288:	  {
        -:  289:	    if constexpr (__platform_wait_uses_type<_Up>)
        -:  290:	      return reinterpret_cast<__platform_wait_t*>(const_cast<_Up*>(__a));
        -:  291:	    else
        3:  292:	      return __b;
        3:  292-block  0
        -:  293:	  }
        -:  294:
        -:  295:	static __waiter_type&
function _ZNSt8__detail13__waiter_baseINS_13__waiter_poolEE6_S_forEPKv called 3 returned 100% blocks executed 100%
        3:  296:	_S_for(const void* __addr) noexcept
        -:  297:	{
        -:  298:	  static_assert(sizeof(__waiter_type) == sizeof(__waiter_pool_base));
        3:  299:	  auto& res = __waiter_pool_base::_S_for(__addr);
        3:  300:	  return reinterpret_cast<__waiter_type&>(res);
        3:  300-block  0
        -:  301:	}
        -:  302:
        -:  303:	template<typename _Up>
function _ZNSt8__detail13__waiter_baseINS_13__waiter_poolEEC2ISt17__barrier_phase_tEEPKT_ called 3 returned 100% blocks executed 66%
        3:  304:	  explicit __waiter_base(const _Up* __addr) noexcept
        3:  305:	    : _M_w(_S_for(__addr))
        3:  306:	    , _M_addr(_S_wait_addr(__addr, &_M_w._M_ver))
        3:  306-block  0
branch  0 taken 3
branch  1 taken 0
    $$$$$:  306-block  1
        3:  307:	  { }
        3:  307-block  0
        -:  308:
        -:  309:	void
function _ZNSt8__detail13__waiter_baseINS_13__waiter_poolEE9_M_notifyEbb called 1 returned 100% blocks executed 100%
        1:  310:	_M_notify(bool __all, bool __bare = false) noexcept
        1:  311:	{ _M_w._M_notify(_M_addr, __all, __bare); }
        1:  311-block  0
        -:  312:
        -:  313:	template<typename _Up, typename _ValFn,
        -:  314:		 typename _Spin = __default_spin_policy>
        -:  315:	  static bool
        -:  316:	  _S_do_spin_v(__platform_wait_t* __addr,
        -:  317:		       const _Up& __old, _ValFn __vfn,
        -:  318:		       __platform_wait_t& __val,
        -:  319:		       _Spin __spin = _Spin{ })
        -:  320:	  {
        -:  321:	    auto const __pred = [=]
        -:  322:	      { return !__detail::__atomic_compare(__old, __vfn()); };
        -:  323:
        -:  324:	    if constexpr (__platform_wait_uses_type<_Up>)
        -:  325:	      {
        -:  326:		__builtin_memcpy(&__val, &__old, sizeof(__val));
        -:  327:	      }
        -:  328:	    else
        -:  329:	      {
        -:  330:		__atomic_load(__addr, &__val, __ATOMIC_ACQUIRE);
        -:  331:	      }
        -:  332:	    return __atomic_spin(__pred, __spin);
        -:  333:	  }
        -:  334:
        -:  335:	template<typename _Up, typename _ValFn,
        -:  336:		 typename _Spin = __default_spin_policy>
        -:  337:	  bool
        -:  338:	  _M_do_spin_v(const _Up& __old, _ValFn __vfn,
        -:  339:		       __platform_wait_t& __val,
        -:  340:		       _Spin __spin = _Spin{ })
        -:  341:	  { return _S_do_spin_v(_M_addr, __old, __vfn, __val, __spin); }
        -:  342:
        -:  343:	template<typename _Pred,
        -:  344:		 typename _Spin = __default_spin_policy>
        -:  345:	  static bool
function _ZNSt8__detail13__waiter_baseINS_13__waiter_poolEE10_S_do_spinIZNKSt14__tree_barrierISt18__empty_completionE4waitEOSt17__barrier_phase_tEUlvE_NS_21__default_spin_policyEEEbPKiT_RiT0_ called 2 returned 100% blocks executed 100%
        2:  346:	  _S_do_spin(const __platform_wait_t* __addr,
        -:  347:		     _Pred __pred,
        -:  348:		     __platform_wait_t& __val,
        -:  349:		     _Spin __spin = _Spin{ })
        -:  350:	  {
        2:  351:	    __atomic_load(__addr, &__val, __ATOMIC_ACQUIRE);
        2:  352:	    return __atomic_spin(__pred, __spin);
        2:  352-block  0
        -:  353:	  }
        -:  354:
        -:  355:	template<typename _Pred,
        -:  356:		 typename _Spin = __default_spin_policy>
        -:  357:	  bool
function _ZNSt8__detail13__waiter_baseINS_13__waiter_poolEE10_M_do_spinIZNKSt14__tree_barrierISt18__empty_completionE4waitEOSt17__barrier_phase_tEUlvE_NS_21__default_spin_policyEEEbT_RiT0_ called 2 returned 100% blocks executed 100%
        2:  358:	  _M_do_spin(_Pred __pred, __platform_wait_t& __val,
        -:  359:		     _Spin __spin = _Spin{ })
        2:  360:	  { return _S_do_spin(_M_addr, __pred, __val, __spin); }
        2:  360-block  0
        -:  361:      };
        -:  362:
        -:  363:    template<typename _EntersWait>
        -:  364:      struct __waiter : __waiter_base<__waiter_pool>
        -:  365:      {
        -:  366:	using __base_type = __waiter_base<__waiter_pool>;
        -:  367:
        -:  368:	template<typename _Tp>
function _ZNSt8__detail8__waiterISt17integral_constantIbLb1EEEC2ISt17__barrier_phase_tEEPKT_ called 2 returned 100% blocks executed 100%
function _ZNSt8__detail8__waiterISt17integral_constantIbLb0EEEC2ISt17__barrier_phase_tEEPKT_ called 1 returned 100% blocks executed 100%
        3:  369:	  explicit __waiter(const _Tp* __addr) noexcept
        3:  370:	    : __base_type(__addr)
        -:  371:	  {
        -:  372:	    if constexpr (_EntersWait::value)
        2:  373:	      _M_w._M_enter_wait();
        3:  374:	  }
        2:  374-block  0
        1:  374-block  1
        -:  375:
function _ZNSt8__detail8__waiterISt17integral_constantIbLb1EEED2Ev called 2 returned 100% blocks executed 100%
function _ZNSt8__detail8__waiterISt17integral_constantIbLb0EEED2Ev called 1 returned 100% blocks executed 100%
        3:  376:	~__waiter()
        -:  377:	{
        -:  378:	  if constexpr (_EntersWait::value)
        2:  379:	    _M_w._M_leave_wait();
        3:  380:	}
        2:  380-block  0
        1:  380-block  1
        -:  381:
        -:  382:	template<typename _Tp, typename _ValFn>
        -:  383:	  void
        -:  384:	  _M_do_wait_v(_Tp __old, _ValFn __vfn)
        -:  385:	  {
        -:  386:	    do
        -:  387:	      {
        -:  388:		__platform_wait_t __val;
        -:  389:		if (__base_type::_M_do_spin_v(__old, __vfn, __val))
        -:  390:		  return;
        -:  391:		__base_type::_M_w._M_do_wait(__base_type::_M_addr, __val);
        -:  392:	      }
        -:  393:	    while (__detail::__atomic_compare(__old, __vfn()));
        -:  394:	  }
        -:  395:
        -:  396:	template<typename _Pred>
        -:  397:	  void
function _ZNSt8__detail8__waiterISt17integral_constantIbLb1EEE10_M_do_waitIZNKSt14__tree_barrierISt18__empty_completionE4waitEOSt17__barrier_phase_tEUlvE_EEvT_ called 2 returned 100% blocks executed 55%
        2:  398:	  _M_do_wait(_Pred __pred) noexcept
        -:  399:	  {
        2:  400:	    do
        2:  400-block  0
        -:  401:	      {
        -:  402:		__platform_wait_t __val;
        2:  403:		if (__base_type::_M_do_spin(__pred, __val))
        2:  403-block  0
branch  0 taken 2
branch  1 taken 0
        2:  403-block  1
branch  2 taken 2
branch  3 taken 0
    $$$$$:  403-block  2
        2:  404:		  return;
        2:  404-block  0
    #####:  405:		__base_type::_M_w._M_do_wait(__base_type::_M_addr, __val);
    #####:  406:	      }
    $$$$$:  406-block  0
    $$$$$:  406-block  1
branch  0 never executed
branch  1 never executed
    #####:  407:	    while (!__pred());
    $$$$$:  407-block  0
branch  0 never executed
branch  1 never executed
        2:  408:	  }
        2:  408-block  0
        -:  409:      };
        -:  410:
        -:  411:    using __enters_wait = __waiter<std::true_type>;
        -:  412:    using __bare_wait = __waiter<std::false_type>;
        -:  413:  } // namespace __detail
        -:  414:
        -:  415:  template<typename _Tp, typename _ValFn>
        -:  416:    void
        -:  417:    __atomic_wait_address_v(const _Tp* __addr, _Tp __old,
        -:  418:			    _ValFn __vfn) noexcept
        -:  419:    {
        -:  420:      __detail::__enters_wait __w(__addr);
        -:  421:      __w._M_do_wait_v(__old, __vfn);
        -:  422:    }
        -:  423:
        -:  424:  template<typename _Tp, typename _Pred>
        -:  425:    void
function _ZSt21__atomic_wait_addressISt17__barrier_phase_tZNKSt14__tree_barrierISt18__empty_completionE4waitEOS0_EUlvE_EvPKT_T0_ called 2 returned 100% blocks executed 100%
        2:  426:    __atomic_wait_address(const _Tp* __addr, _Pred __pred) noexcept
        -:  427:    {
        2:  428:      __detail::__enters_wait __w(__addr);
        2:  429:      __w._M_do_wait(__pred);
        2:  430:    }
        2:  430-block  0
        -:  431:
        -:  432:  // This call is to be used by atomic types which track contention externally
        -:  433:  template<typename _Pred>
        -:  434:    void
        -:  435:    __atomic_wait_address_bare(const __detail::__platform_wait_t* __addr,
        -:  436:			       _Pred __pred) noexcept
        -:  437:    {
        -:  438:#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT
        -:  439:      do
        -:  440:	{
        -:  441:	  __detail::__platform_wait_t __val;
        -:  442:	  if (__detail::__bare_wait::_S_do_spin(__addr, __pred, __val))
        -:  443:	    return;
        -:  444:	  __detail::__platform_wait(__addr, __val);
        -:  445:	}
        -:  446:      while (!__pred());
        -:  447:#else // !_GLIBCXX_HAVE_PLATFORM_WAIT
        -:  448:      __detail::__bare_wait __w(__addr);
        -:  449:      __w._M_do_wait(__pred);
        -:  450:#endif
        -:  451:    }
        -:  452:
        -:  453:  template<typename _Tp>
        -:  454:    void
function _ZSt23__atomic_notify_addressISt17__barrier_phase_tEvPKT_b called 1 returned 100% blocks executed 100%
        1:  455:    __atomic_notify_address(const _Tp* __addr, bool __all) noexcept
        -:  456:    {
        1:  457:      __detail::__bare_wait __w(__addr);
        1:  458:      __w._M_notify(__all);
        1:  459:    }
        1:  459-block  0
        -:  460:
        -:  461:  // This call is to be used by atomic types which track contention externally
        -:  462:  inline void
        -:  463:  __atomic_notify_address_bare(const __detail::__platform_wait_t* __addr,
        -:  464:			       bool __all) noexcept
        -:  465:  {
        -:  466:#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT
        -:  467:    __detail::__platform_notify(__addr, __all);
        -:  468:#else
        -:  469:    __detail::__bare_wait __w(__addr);
        -:  470:    __w._M_notify(__all, true);
        -:  471:#endif
        -:  472:  }
        -:  473:_GLIBCXX_END_NAMESPACE_VERSION
        -:  474:} // namespace std
        -:  475:#endif // GTHREADS || LINUX_FUTEX
        -:  476:#endif // _GLIBCXX_ATOMIC_WAIT_H
