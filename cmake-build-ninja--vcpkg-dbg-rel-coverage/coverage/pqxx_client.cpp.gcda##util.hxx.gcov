        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/pqxx/util.hxx
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Various utility definitions for libpqxx.
        -:    2: *
        -:    3: * DO NOT INCLUDE THIS FILE DIRECTLY; include pqxx/util instead.
        -:    4: *
        -:    5: * Copyright (c) 2000-2024, Jeroen T. Vermeulen.
        -:    6: *
        -:    7: * See COPYING for copyright license.  If you did not receive a file called
        -:    8: * COPYING with this source code, please notify the distributor of this
        -:    9: * mistake, or contact the author.
        -:   10: */
        -:   11:#ifndef PQXX_H_UTIL
        -:   12:#define PQXX_H_UTIL
        -:   13:
        -:   14:#if !defined(PQXX_HEADER_PRE)
        -:   15:#  error "Include libpqxx headers as <pqxx/header>, not <pqxx/header.hxx>."
        -:   16:#endif
        -:   17:
        -:   18:#include <cassert>
        -:   19:#include <cctype>
        -:   20:#include <cerrno>
        -:   21:#include <cstdio>
        -:   22:#include <cstring>
        -:   23:#include <functional>
        -:   24:#include <iterator>
        -:   25:#include <limits>
        -:   26:#include <memory>
        -:   27:#include <stdexcept>
        -:   28:#include <string>
        -:   29:#include <string_view>
        -:   30:#include <type_traits>
        -:   31:#include <typeinfo>
        -:   32:#include <utility>
        -:   33:#include <vector>
        -:   34:
        -:   35:#include "pqxx/except.hxx"
        -:   36:#include "pqxx/types.hxx"
        -:   37:#include "pqxx/version.hxx"
        -:   38:
        -:   39:
        -:   40:/// The home of all libpqxx classes, functions, templates, etc.
        -:   41:namespace pqxx
        -:   42:{}
        -:   43:
        -:   44:#include <pqxx/internal/libpq-forward.hxx>
        -:   45:
        -:   46:
        -:   47:// C++23: Retire wrapper.
        -:   48:// PQXX_UNREACHABLE: equivalent to `std::unreachable()` if available.
        -:   49:#if !defined(__cpp_lib_unreachable)
        -:   50:#  define PQXX_UNREACHABLE assert(false)
        -:   51:#elif !__cpp_lib_unreachable
        -:   52:#  define PQXX_UNREACHABLE assert(false)
        -:   53:#else
        -:   54:#  define PQXX_UNREACHABLE std::unreachable()
        -:   55:#endif
        -:   56:
        -:   57:
        -:   58:/// Internal items for libpqxx' own use.  Do not use these yourself.
        -:   59:namespace pqxx::internal
        -:   60:{
        -:   61:
        -:   62:// C++20: Retire wrapper.
        -:   63:/// Same as `std::cmp_less`, or a workaround where that's not available.
        -:   64:template<typename LEFT, typename RIGHT>
function _ZN4pqxx8internal8cmp_lessImlEEbT_T0_ called 43 returned 100% blocks executed 75%
       43:   65:inline constexpr bool cmp_less(LEFT lhs, RIGHT rhs) noexcept
        -:   66:{
        -:   67:#if defined(PQXX_HAVE_CMP)
        -:   68:  return std::cmp_less(lhs, rhs);
        -:   69:#else
        -:   70:  // We need a variable just because lgtm.com gives off a false positive
        -:   71:  // warning when we compare the values directly.  It considers that a
        -:   72:  // "self-comparison."
       43:   73:  constexpr bool left_signed{std::is_signed_v<LEFT>};
        -:   74:  if constexpr (left_signed == std::is_signed_v<RIGHT>)
        -:   75:    return lhs < rhs;
        -:   76:  else if constexpr (std::is_signed_v<LEFT>)
        -:   77:    return (lhs <= 0) ? true : (std::make_unsigned_t<LEFT>(lhs) < rhs);
        -:   78:  else
       43:   79:    return (rhs <= 0) ? false : (lhs < std::make_unsigned_t<RIGHT>(rhs));
       43:   79-block  0
branch  0 taken 0
branch  1 taken 43
    $$$$$:   79-block  1
       43:   79-block  2
       43:   79-block  3
        -:   80:#endif
        -:   81:}
        -:   82:
        -:   83:
        -:   84:// C++20: Retire wrapper.
        -:   85:/// C++20 std::cmp_greater, or workaround if not available.
        -:   86:template<typename LEFT, typename RIGHT>
        -:   87:inline constexpr bool cmp_greater(LEFT lhs, RIGHT rhs) noexcept
        -:   88:{
        -:   89:#if defined(PQXX_HAVE_CMP)
        -:   90:  return std::cmp_greater(lhs, rhs);
        -:   91:#else
        -:   92:  return cmp_less(rhs, lhs);
        -:   93:#endif
        -:   94:}
        -:   95:
        -:   96:
        -:   97:// C++20: Retire wrapper.
        -:   98:/// C++20 std::cmp_less_equal, or workaround if not available.
        -:   99:template<typename LEFT, typename RIGHT>
        -:  100:inline constexpr bool cmp_less_equal(LEFT lhs, RIGHT rhs) noexcept
        -:  101:{
        -:  102:#if defined(PQXX_HAVE_CMP)
        -:  103:  return std::cmp_less_equal(lhs, rhs);
        -:  104:#else
        -:  105:  return not cmp_less(rhs, lhs);
        -:  106:#endif
        -:  107:}
        -:  108:
        -:  109:
        -:  110:// C++20: Retire wrapper.
        -:  111:/// C++20 std::cmp_greater_equal, or workaround if not available.
        -:  112:template<typename LEFT, typename RIGHT>
function _ZN4pqxx8internal17cmp_greater_equalImlEEbT_T0_ called 43 returned 100% blocks executed 100%
       43:  113:inline constexpr bool cmp_greater_equal(LEFT lhs, RIGHT rhs) noexcept
        -:  114:{
        -:  115:#if defined(PQXX_HAVE_CMP)
        -:  116:  return std::cmp_greater_equal(lhs, rhs);
        -:  117:#else
       43:  118:  return not cmp_less(lhs, rhs);
       43:  118-block  0
        -:  119:#endif
        -:  120:}
        -:  121:
        -:  122:
        -:  123:/// Efficiently concatenate two strings.
        -:  124:/** This is a special case of concatenate(), needed because dependency
        -:  125: * management does not let us use that function here.
        -:  126: */
        -:  127:[[nodiscard]] inline std::string cat2(std::string_view x, std::string_view y)
        -:  128:{
        -:  129:  std::string buf;
        -:  130:  auto const xs{std::size(x)}, ys{std::size(y)};
        -:  131:  buf.resize(xs + ys);
        -:  132:  x.copy(std::data(buf), xs);
        -:  133:  y.copy(std::data(buf) + xs, ys);
        -:  134:  return buf;
        -:  135:}
        -:  136:} // namespace pqxx::internal
        -:  137:
        -:  138:
        -:  139:namespace pqxx
        -:  140:{
        -:  141:using namespace std::literals;
        -:  142:
        -:  143:/// Suppress compiler warning about an unused item.
function _ZN4pqxx13ignore_unusedIJRKiEEEvDpOT_ called 20 returned 100% blocks executed 100%
       20:  144:template<typename... T> inline constexpr void ignore_unused(T &&...) noexcept
       20:  145:{}
       20:  145-block  0
        -:  146:
        -:  147:
        -:  148:/// Cast a numeric value to another type, or throw if it underflows/overflows.
        -:  149:/** Both types must be arithmetic types, and they must either be both integral
        -:  150: * or both floating-point types.
        -:  151: */
        -:  152:template<typename TO, typename FROM>
        -:  153:inline TO check_cast(FROM value, std::string_view description)
        -:  154:{
        -:  155:  static_assert(std::is_arithmetic_v<FROM>);
        -:  156:  static_assert(std::is_arithmetic_v<TO>);
        -:  157:  static_assert(std::is_integral_v<FROM> == std::is_integral_v<TO>);
        -:  158:
        -:  159:  // The rest of this code won't quite work for bool, but bool is trivially
        -:  160:  // convertible to other arithmetic types as far as I can see.
        -:  161:  if constexpr (std::is_same_v<FROM, bool>)
        -:  162:    return static_cast<TO>(value);
        -:  163:
        -:  164:  // Depending on our "if constexpr" conditions, this parameter may not be
        -:  165:  // needed.  Some compilers will warn.
        -:  166:  ignore_unused(description);
        -:  167:
        -:  168:  using from_limits = std::numeric_limits<decltype(value)>;
        -:  169:  using to_limits = std::numeric_limits<TO>;
        -:  170:  if constexpr (std::is_signed_v<FROM>)
        -:  171:  {
        -:  172:    if constexpr (std::is_signed_v<TO>)
        -:  173:    {
        -:  174:      if (value < to_limits::lowest())
        -:  175:        throw range_error{internal::cat2("Cast underflow: "sv, description)};
        -:  176:    }
        -:  177:    else
        -:  178:    {
        -:  179:      // FROM is signed, but TO is not.  Treat this as a special case, because
        -:  180:      // there may not be a good broader type in which the compiler can even
        -:  181:      // perform our check.
        -:  182:      if (value < 0)
        -:  183:        throw range_error{internal::cat2(
        -:  184:          "Casting negative value to unsigned type: "sv, description)};
        -:  185:    }
        -:  186:  }
        -:  187:  else
        -:  188:  {
        -:  189:    // No need to check: the value is unsigned so can't fall below the range
        -:  190:    // of the TO type.
        -:  191:  }
        -:  192:
        -:  193:  if constexpr (std::is_integral_v<FROM>)
        -:  194:  {
        -:  195:    using unsigned_from = std::make_unsigned_t<FROM>;
        -:  196:    using unsigned_to = std::make_unsigned_t<TO>;
        -:  197:    constexpr auto from_max{static_cast<unsigned_from>((from_limits::max)())};
        -:  198:    constexpr auto to_max{static_cast<unsigned_to>((to_limits::max)())};
        -:  199:    if constexpr (from_max > to_max)
        -:  200:    {
        -:  201:      if (internal::cmp_greater(value, to_max))
        -:  202:        throw range_error{internal::cat2("Cast overflow: "sv, description)};
        -:  203:    }
        -:  204:  }
        -:  205:  else if constexpr ((from_limits::max)() > (to_limits::max)())
        -:  206:  {
        -:  207:    if (value > (to_limits::max)())
        -:  208:      throw range_error{internal::cat2("Cast overflow: ", description)};
        -:  209:  }
        -:  210:
        -:  211:  return static_cast<TO>(value);
        -:  212:}
        -:  213:
        -:  214:
        -:  215:/** Check library version at link time.
        -:  216: *
        -:  217: * Ensures a failure when linking an application against a radically
        -:  218: * different libpqxx version than the one against which it was compiled.
        -:  219: *
        -:  220: * Sometimes application builds fail in unclear ways because they compile
        -:  221: * using headers from libpqxx version X, but then link against libpqxx
        -:  222: * binary version Y.  A typical scenario would be one where you're building
        -:  223: * against a libpqxx which you have built yourself, but a different version
        -:  224: * is installed on the system.
        -:  225: *
        -:  226: * The check_library_version template is declared for any library version,
        -:  227: * but only actually defined for the version of the libpqxx binary against
        -:  228: * which the code is linked.
        -:  229: *
        -:  230: * If the library binary is a different version than the one declared in
        -:  231: * these headers, then this call will fail to link: there will be no
        -:  232: * definition for the function with these exact template parameter values.
        -:  233: * There will be a definition, but the version in the parameter values will
        -:  234: * be different.
        -:  235: */
function _ZN4pqxx13check_versionEv called 20 returned 100% blocks executed 100%
       20:  236:inline PQXX_PRIVATE void check_version() noexcept
        -:  237:{
        -:  238:  // There is no particular reason to do this here in @ref connection, except
        -:  239:  // to ensure that every meaningful libpqxx client will execute it.  The call
        -:  240:  // must be in the execution path somewhere or the compiler won't try to link
        -:  241:  // it.  We can't use it to initialise a global or class-static variable,
        -:  242:  // because a smart compiler might resolve it at compile time.
        -:  243:  //
        -:  244:  // On the other hand, we don't want to make a useless function call too
        -:  245:  // often for performance reasons.  A local static variable is initialised
        -:  246:  // only on the definition's first execution.  Compilers will be well
        -:  247:  // optimised for this behaviour, so there's a minimal one-time cost.
       20:  248:  static auto const version_ok{internal::PQXX_VERSION_CHECK()};
       20:  248-block  0
branch  0 taken 1
branch  1 taken 19
        1:  248-block  1
branch  2 taken 0
branch  3 taken 1
        1:  248-block  2
       20:  249:  ignore_unused(version_ok);
       20:  250:}
       20:  250-block  0
        -:  251:
        -:  252:
        -:  253:/// Descriptor of library's thread-safety model.
        -:  254:/** This describes what the library knows about various risks to thread-safety.
        -:  255: */
        -:  256:struct PQXX_LIBEXPORT thread_safety_model
        -:  257:{
        -:  258:  /// Is the underlying libpq build thread-safe?
        -:  259:  bool safe_libpq = false;
        -:  260:
        -:  261:  /// Is Kerberos thread-safe?
        -:  262:  /** @warning Is currently always `false`.
        -:  263:   *
        -:  264:   * If your application uses Kerberos, all accesses to libpqxx or Kerberos
        -:  265:   * must be serialized.  Confine their use to a single thread, or protect it
        -:  266:   * with a global lock.
        -:  267:   */
        -:  268:  bool safe_kerberos = false;
        -:  269:
        -:  270:  /// A human-readable description of any thread-safety issues.
        -:  271:  std::string description;
        -:  272:};
        -:  273:
        -:  274:
        -:  275:/// Describe thread safety available in this build.
        -:  276:[[nodiscard]] PQXX_LIBEXPORT thread_safety_model describe_thread_safety();
        -:  277:
        -:  278:
        -:  279:#if defined(PQXX_HAVE_CONCEPTS)
        -:  280:#  define PQXX_POTENTIAL_BINARY_ARG pqxx::potential_binary
        -:  281:#else
        -:  282:#  define PQXX_POTENTIAL_BINARY_ARG typename
        -:  283:#endif
        -:  284:
        -:  285:/// Custom `std::char_trast` if the compiler does not provide one.
        -:  286:/** Needed if the standard library lacks a generic implementation or a
        -:  287: * specialisation for std::byte.  They aren't strictly required to provide
        -:  288: * either, and libc++ 19 removed its generic implementation.
        -:  289: */
        -:  290:struct byte_char_traits : std::char_traits<char>
        -:  291:{
        -:  292:  using char_type = std::byte;
        -:  293:
        -:  294:  static void assign(std::byte &a, const std::byte &b) noexcept { a = b; }
        -:  295:  static bool eq(std::byte a, std::byte b) { return a == b; }
        -:  296:  static bool lt(std::byte a, std::byte b) { return a < b; }
        -:  297:
        -:  298:  static int compare(const std::byte *a, const std::byte *b, std::size_t size)
        -:  299:  {
        -:  300:    return std::memcmp(a, b, size);
        -:  301:  }
        -:  302:
        -:  303:  /// Deliberately undefined: "guess" the length of an array of bytes.
        -:  304:  /* This is nonsense: we can't determine the length of a random sequence of
        -:  305:   * bytes.  There is no terminating zero like there is for C strings.
        -:  306:   *
        -:  307:   * But `std::char_traits` requires us to provide this function, so we
        -:  308:   * declare it without defining it.
        -:  309:   */
        -:  310:  static size_t length(const std::byte *data);
        -:  311:
        -:  312:  static const std::byte *
        -:  313:  find(const std::byte *data, std::size_t size, const std::byte &value)
        -:  314:  {
        -:  315:    return static_cast<const std::byte *>(
        -:  316:      std::memchr(data, static_cast<int>(value), size));
        -:  317:  }
        -:  318:
        -:  319:  static std::byte *
        -:  320:  move(std::byte *dest, const std::byte *src, std::size_t size)
        -:  321:  {
        -:  322:    return static_cast<std::byte *>(std::memmove(dest, src, size));
        -:  323:  }
        -:  324:
        -:  325:  static std::byte *
        -:  326:  copy(std::byte *dest, const std::byte *src, std::size_t size)
        -:  327:  {
        -:  328:    return static_cast<std::byte *>(std::memcpy(dest, src, size));
        -:  329:  }
        -:  330:
        -:  331:  static std::byte *assign(std::byte *dest, std::size_t size, std::byte value)
        -:  332:  {
        -:  333:    return static_cast<std::byte *>(
        -:  334:      std::memset(dest, static_cast<int>(value), size));
        -:  335:  }
        -:  336:
        -:  337:  /// Declared but not defined: makes no sense for binary data.
        -:  338:  static int_type not_eof(int_type value);
        -:  339:
        -:  340:  static std::byte to_char_type(int_type value) { return std::byte(value); }
        -:  341:
        -:  342:  static int_type to_int_type(std::byte value) { return int_type(value); }
        -:  343:
        -:  344:  static bool eq_int_type(int_type a, int_type b) { return a == b; }
        -:  345:
        -:  346:  /// Declared but not defined: makes no sense for binary data.
        -:  347:  static int_type eof();
        -:  348:};
        -:  349:
        -:  350:template<typename TYPE, typename = void>
        -:  351:struct has_generic_char_traits : std::false_type
        -:  352:{};
        -:  353:
        -:  354:template<typename TYPE>
        -:  355:struct has_generic_char_traits<
        -:  356:  TYPE, std::void_t<decltype(std::char_traits<TYPE>::eof)>> : std::true_type
        -:  357:{};
        -:  358:
        -:  359:inline constexpr bool has_generic_bytes_char_traits =
        -:  360:  has_generic_char_traits<std::byte>::value;
        -:  361:
        -:  362:// Supress warnings from potentially using a deprecated generic
        -:  363:// std::char_traits.
        -:  364:// Necessary for libc++ 18.
        -:  365:#include "pqxx/internal/ignore-deprecated-pre.hxx"
        -:  366:
        -:  367:// C++20: Change this type.
        -:  368:/// Type alias for a container containing bytes.
        -:  369:/* Required to support standard libraries without a generic implementation for
        -:  370: * `std::char_traits<std::byte>`.
        -:  371: * @warn Will change to `std::vector<std::byte>` in the next major release.
        -:  372: */
        -:  373:using bytes = std::conditional<
        -:  374:  has_generic_bytes_char_traits, std::basic_string<std::byte>,
        -:  375:  std::basic_string<std::byte, byte_char_traits>>::type;
        -:  376:
        -:  377:// C++20: Change this type.
        -:  378:/// Type alias for a view of bytes.
        -:  379:/* Required to support standard libraries without a generic implementation for
        -:  380: * `std::char_traits<std::byte>`.
        -:  381: * @warn Will change to `std::span<std::byte>` in the next major release.
        -:  382: */
        -:  383:using bytes_view = std::conditional<
        -:  384:  has_generic_bytes_char_traits, std::basic_string_view<std::byte>,
        -:  385:  std::basic_string_view<std::byte, byte_char_traits>>::type;
        -:  386:
        -:  387:#include "pqxx/internal/ignore-deprecated-post.hxx"
        -:  388:
        -:  389:
        -:  390:/// Cast binary data to a type that libpqxx will recognise as binary.
        -:  391:/** There are many different formats for storing binary data in memory.  You
        -:  392: * may have yours as a `std::string`, or a `std::vector<uchar_t>`, or one of
        -:  393: * many other types.
        -:  394: *
        -:  395: * But for libpqxx to recognise your data as binary, it needs to be a
        -:  396: * `pqxx::bytes`, or a `pqxx::bytes_view`; or in C++20 or better, any
        -:  397: * contiguous block of `std::byte`.
        -:  398: *
        -:  399: * Use `binary_cast` as a convenience helper to cast your data as a
        -:  400: * `pqxx::bytes_view`.
        -:  401: *
        -:  402: * @warning There are two things you should be aware of!  First, the data must
        -:  403: * be contiguous in memory.  In C++20 the compiler will enforce this, but in
        -:  404: * C++17 it's your own problem.  Second, you must keep the object where you
        -:  405: * store the actual data alive for as long as you might use this function's
        -:  406: * return value.
        -:  407: */
        -:  408:template<PQXX_POTENTIAL_BINARY_ARG TYPE>
        -:  409:bytes_view binary_cast(TYPE const &data)
        -:  410:{
        -:  411:  static_assert(sizeof(value_type<TYPE>) == 1);
        -:  412:  // C++20: Use std::as_bytes.
        -:  413:  return {
        -:  414:    reinterpret_cast<std::byte const *>(
        -:  415:      const_cast<strip_t<decltype(*std::data(data))> const *>(
        -:  416:        std::data(data))),
        -:  417:    std::size(data)};
        -:  418:}
        -:  419:
        -:  420:
        -:  421:#if defined(PQXX_HAVE_CONCEPTS)
        -:  422:template<typename CHAR>
        -:  423:concept char_sized = (sizeof(CHAR) == 1);
        -:  424:#  define PQXX_CHAR_SIZED_ARG char_sized
        -:  425:#else
        -:  426:#  define PQXX_CHAR_SIZED_ARG typename
        -:  427:#endif
        -:  428:
        -:  429:/// Construct a type that libpqxx will recognise as binary.
        -:  430:/** Takes a data pointer and a size, without being too strict about their
        -:  431: * types, and constructs a `pqxx::bytes_view` pointing to the same data.
        -:  432: *
        -:  433: * This makes it a little easier to turn binary data, in whatever form you
        -:  434: * happen to have it, into binary data as libpqxx understands it.
        -:  435: */
        -:  436:template<PQXX_CHAR_SIZED_ARG CHAR, typename SIZE>
        -:  437:bytes_view binary_cast(CHAR const *data, SIZE size)
        -:  438:{
        -:  439:  static_assert(sizeof(CHAR) == 1);
        -:  440:  return {
        -:  441:    reinterpret_cast<std::byte const *>(data),
        -:  442:    check_cast<std::size_t>(size, "binary data size")};
        -:  443:}
        -:  444:
        -:  445:
        -:  446:/// The "null" oid.
        -:  447:constexpr oid oid_none{0};
        -:  448:} // namespace pqxx
        -:  449:
        -:  450:
        -:  451:/// Private namespace for libpqxx's internal use; do not access.
        -:  452:/** This namespace hides definitions internal to libpqxx.  These are not
        -:  453: * supposed to be used by client programs, and they may change at any time
        -:  454: * without notice.
        -:  455: *
        -:  456: * Conversely, if you find something in this namespace tremendously useful, by
        -:  457: * all means do lodge a request for its publication.
        -:  458: *
        -:  459: * @warning Here be dragons!
        -:  460: */
        -:  461:namespace pqxx::internal
        -:  462:{
        -:  463:using namespace std::literals;
        -:  464:
        -:  465:
        -:  466:/// A safer and more generic replacement for `std::isdigit`.
        -:  467:/** Turns out `std::isdigit` isn't as easy to use as it sounds.  It takes an
        -:  468: * `int`, but requires it to be nonnegative.  Which means it's an outright
        -:  469: * liability on systems where `char` is signed.
        -:  470: */
        -:  471:template<typename CHAR> inline constexpr bool is_digit(CHAR c) noexcept
        -:  472:{
        -:  473:  return (c >= '0') and (c <= '9');
        -:  474:}
        -:  475:
        -:  476:
        -:  477:/// Describe an object for humans, based on class name and optional name.
        -:  478:/** Interprets an empty name as "no name given."
        -:  479: */
        -:  480:[[nodiscard]] std::string
        -:  481:describe_object(std::string_view class_name, std::string_view name);
        -:  482:
        -:  483:
        -:  484:/// Check validity of registering a new "guest" in a "host."
        -:  485:/** The host might be e.g. a connection, and the guest a transaction.  The
        -:  486: * host can only have one guest at a time, so it is an error to register a new
        -:  487: * guest while the host already has a guest.
        -:  488: *
        -:  489: * If the new registration is an error, this function throws a descriptive
        -:  490: * exception.
        -:  491: *
        -:  492: * Pass the old guest (if any) and the new guest (if any), for both, a type
        -:  493: * name (at least if the guest is not null), and optionally an object name
        -:  494: * (but which may be omitted if the caller did not assign one).
        -:  495: */
        -:  496:void check_unique_register(
        -:  497:  void const *old_guest, std::string_view old_class, std::string_view old_name,
        -:  498:  void const *new_guest, std::string_view new_class,
        -:  499:  std::string_view new_name);
        -:  500:
        -:  501:
        -:  502:/// Like @ref check_unique_register, but for un-registering a guest.
        -:  503:/** Pass the guest which was registered, as well as the guest which is being
        -:  504: * unregistered, so that the function can check that they are the same one.
        -:  505: */
        -:  506:void check_unique_unregister(
        -:  507:  void const *old_guest, std::string_view old_class, std::string_view old_name,
        -:  508:  void const *new_guest, std::string_view new_class,
        -:  509:  std::string_view new_name);
        -:  510:
        -:  511:
        -:  512:/// Compute buffer size needed to escape binary data for use as a BYTEA.
        -:  513:/** This uses the hex-escaping format.  The return value includes room for the
        -:  514: * "\x" prefix.
        -:  515: */
        -:  516:inline constexpr std::size_t size_esc_bin(std::size_t binary_bytes) noexcept
        -:  517:{
        -:  518:  return 2 + (2 * binary_bytes) + 1;
        -:  519:}
        -:  520:
        -:  521:
        -:  522:/// Compute binary size from the size of its escaped version.
        -:  523:/** Do not include a terminating zero in `escaped_bytes`.
        -:  524: */
        -:  525:inline constexpr std::size_t size_unesc_bin(std::size_t escaped_bytes) noexcept
        -:  526:{
        -:  527:  return (escaped_bytes - 2) / 2;
        -:  528:}
        -:  529:
        -:  530:
        -:  531:// TODO: Use actual binary type for "data".
        -:  532:/// Hex-escape binary data into a buffer.
        -:  533:/** The buffer must be able to accommodate
        -:  534: * `size_esc_bin(std::size(binary_data))` bytes, and the function will write
        -:  535: * exactly that number of bytes into the buffer.  This includes a trailing
        -:  536: * zero.
        -:  537: */
        -:  538:void PQXX_LIBEXPORT esc_bin(bytes_view binary_data, char buffer[]) noexcept;
        -:  539:
        -:  540:
        -:  541:/// Hex-escape binary data into a std::string.
        -:  542:std::string PQXX_LIBEXPORT esc_bin(bytes_view binary_data);
        -:  543:
        -:  544:
        -:  545:/// Reconstitute binary data from its escaped version.
        -:  546:void PQXX_LIBEXPORT
        -:  547:unesc_bin(std::string_view escaped_data, std::byte buffer[]);
        -:  548:
        -:  549:
        -:  550:/// Reconstitute binary data from its escaped version.
        -:  551:bytes PQXX_LIBEXPORT unesc_bin(std::string_view escaped_data);
        -:  552:
        -:  553:
        -:  554:/// Transitional: std::ssize(), or custom implementation if not available.
        -:  555:template<typename T> auto ssize(T const &c)
        -:  556:{
        -:  557:#if defined(PQXX_HAVE_SSIZE)
        -:  558:  return std::ssize(c);
        -:  559:#else
        -:  560:  using signed_t = std::make_signed_t<decltype(std::size(c))>;
        -:  561:  return static_cast<signed_t>(std::size(c));
        -:  562:#endif // PQXX_HAVE_SSIZe
        -:  563:}
        -:  564:
        -:  565:
        -:  566:/// Helper for determining a function's parameter types.
        -:  567:/** This function has no definition.  It's not meant to be actually called.
        -:  568: * It's just there for pattern-matching in the compiler, so we can use its
        -:  569: * hypothetical return value.
        -:  570: */
        -:  571:template<typename RETURN, typename... ARGS>
        -:  572:std::tuple<ARGS...> args_f(RETURN (&func)(ARGS...));
        -:  573:
        -:  574:
        -:  575:/// Helper for determining a `std::function`'s parameter types.
        -:  576:/** This function has no definition.  It's not meant to be actually called.
        -:  577: * It's just there for pattern-matching in the compiler, so we can use its
        -:  578: * hypothetical return value.
        -:  579: */
        -:  580:template<typename RETURN, typename... ARGS>
        -:  581:std::tuple<ARGS...> args_f(std::function<RETURN(ARGS...)> const &);
        -:  582:
        -:  583:
        -:  584:/// Helper for determining a member function's parameter types.
        -:  585:/** This function has no definition.  It's not meant to be actually called.
        -:  586: * It's just there for pattern-matching in the compiler, so we can use its
        -:  587: * hypothetical return value.
        -:  588: */
        -:  589:template<typename CLASS, typename RETURN, typename... ARGS>
        -:  590:std::tuple<ARGS...> member_args_f(RETURN (CLASS::*)(ARGS...));
        -:  591:
        -:  592:
        -:  593:/// Helper for determining a const member function's parameter types.
        -:  594:/** This function has no definition.  It's not meant to be actually called.
        -:  595: * It's just there for pattern-matching in the compiler, so we can use its
        -:  596: * hypothetical return value.
        -:  597: */
        -:  598:template<typename CLASS, typename RETURN, typename... ARGS>
        -:  599:std::tuple<ARGS...> member_args_f(RETURN (CLASS::*)(ARGS...) const);
        -:  600:
        -:  601:
        -:  602:/// Helper for determining a callable type's parameter types.
        -:  603:/** This specialisation should work for lambdas.
        -:  604: *
        -:  605: * This function has no definition.  It's not meant to be actually called.
        -:  606: * It's just there for pattern-matching in the compiler, so we can use its
        -:  607: * hypothetical return value.
        -:  608: */
        -:  609:template<typename CALLABLE>
        -:  610:auto args_f(CALLABLE const &f)
        -:  611:  -> decltype(member_args_f(&CALLABLE::operator()));
        -:  612:
        -:  613:
        -:  614:/// A callable's parameter types, as a tuple.
        -:  615:template<typename CALLABLE>
        -:  616:using args_t = decltype(args_f(std::declval<CALLABLE>()));
        -:  617:
        -:  618:
        -:  619:/// Helper: Apply `strip_t` to each of a tuple type's component types.
        -:  620:/** This function has no definition.  It is not meant to be called, only to be
        -:  621: * used to deduce the right types.
        -:  622: */
        -:  623:template<typename... TYPES>
        -:  624:std::tuple<strip_t<TYPES>...> strip_types(std::tuple<TYPES...> const &);
        -:  625:
        -:  626:
        -:  627:/// Take a tuple type and apply @ref strip_t to its component types.
        -:  628:template<typename... TYPES>
        -:  629:using strip_types_t = decltype(strip_types(std::declval<TYPES...>()));
        -:  630:
        -:  631:
        -:  632:/// Return original byte for escaped character.
        -:  633:inline constexpr char unescape_char(char escaped) noexcept
        -:  634:{
        -:  635:  switch (escaped)
        -:  636:  {
        -:  637:  case 'b': // Backspace.
        -:  638:    PQXX_UNLIKELY return '\b';
        -:  639:  case 'f': // Form feed
        -:  640:    PQXX_UNLIKELY return '\f';
        -:  641:  case 'n': // Line feed.
        -:  642:    return '\n';
        -:  643:  case 'r': // Carriage return.
        -:  644:    return '\r';
        -:  645:  case 't': // Horizontal tab.
        -:  646:    return '\t';
        -:  647:  case 'v': // Vertical tab.
        -:  648:    return '\v';
        -:  649:  default: break;
        -:  650:  }
        -:  651:  // Regular character ("self-escaped").
        -:  652:  return escaped;
        -:  653:}
        -:  654:
        -:  655:
        -:  656:// C++20: std::span?
        -:  657:/// Get error string for a given @c errno value.
        -:  658:template<std::size_t BYTES>
        -:  659:char const *PQXX_COLD
        -:  660:error_string(int err_num, std::array<char, BYTES> &buffer)
        -:  661:{
        -:  662:  // Not entirely clear whether strerror_s will be in std or global namespace.
        -:  663:  using namespace std;
        -:  664:
        -:  665:#if defined(PQXX_HAVE_STERROR_S) || defined(PQXX_HAVE_STRERROR_R)
        -:  666:#  if defined(PQXX_HAVE_STRERROR_S)
        -:  667:  auto const err_result{strerror_s(std::data(buffer), BYTES, err_num)};
        -:  668:#  else
        -:  669:  auto const err_result{strerror_r(err_num, std::data(buffer), BYTES)};
        -:  670:#  endif
        -:  671:  if constexpr (std::is_same_v<pqxx::strip_t<decltype(err_result)>, char *>)
        -:  672:  {
        -:  673:    // GNU version of strerror_r; returns the error string, which may or may
        -:  674:    // not reside within buffer.
        -:  675:    return err_result;
        -:  676:  }
        -:  677:  else
        -:  678:  {
        -:  679:    // Either strerror_s or POSIX strerror_r; returns an error code.
        -:  680:    // Sorry for being lazy here: Not reporting error string for the case
        -:  681:    // where we can't retrieve an error string.
        -:  682:    if (err_result == 0)
        -:  683:      return std::data(buffer);
        -:  684:    else
        -:  685:      return "Compound errors.";
        -:  686:  }
        -:  687:
        -:  688:#else
        -:  689:  // Fallback case, hopefully for no actual platforms out there.
        -:  690:  pqxx::ignore_unused(err_num, buffer);
        -:  691:  return "(No error information available.)";
        -:  692:#endif
        -:  693:}
        -:  694:} // namespace pqxx::internal
        -:  695:
        -:  696:
        -:  697:namespace pqxx::internal::pq
        -:  698:{
        -:  699:/// Wrapper for `PQfreemem()`, with C++ linkage.
        -:  700:PQXX_LIBEXPORT void pqfreemem(void const *) noexcept;
        -:  701:} // namespace pqxx::internal::pq
        -:  702:#endif
