        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/boost/container/allocator_traits.hpp
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Medicament_Properties.dir/medicament/properties/properties_test.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/tests/unit_tests/objects/CMakeFiles/DrugLib_Tests_Unit_Objects_Medicament_Properties.dir/medicament/properties/properties_test.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3:// (C) Copyright Pablo Halpern 2009. Distributed under the Boost
        -:    4:// Software License, Version 1.0. (See accompanying file
        -:    5:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    6://
        -:    7://////////////////////////////////////////////////////////////////////////////
        -:    8://
        -:    9:// (C) Copyright Ion Gaztanaga 2011-2013. Distributed under the Boost
        -:   10:// Software License, Version 1.0. (See accompanying file
        -:   11:// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:   12://
        -:   13:// See http://www.boost.org/libs/container for documentation.
        -:   14://
        -:   15://////////////////////////////////////////////////////////////////////////////
        -:   16:#ifndef BOOST_CONTAINER_ALLOCATOR_ALLOCATOR_TRAITS_HPP
        -:   17:#define BOOST_CONTAINER_ALLOCATOR_ALLOCATOR_TRAITS_HPP
        -:   18:
        -:   19:#ifndef BOOST_CONFIG_HPP
        -:   20:#  include <boost/config.hpp>
        -:   21:#endif
        -:   22:
        -:   23:#if defined(BOOST_HAS_PRAGMA_ONCE)
        -:   24:#  pragma once
        -:   25:#endif
        -:   26:
        -:   27:#include <boost/container/detail/config_begin.hpp>
        -:   28:#include <boost/container/detail/workaround.hpp>
        -:   29:
        -:   30:// container
        -:   31:#include <boost/container/container_fwd.hpp>
        -:   32:#include <boost/container/detail/mpl.hpp>
        -:   33:#include <boost/container/detail/type_traits.hpp>  //is_empty
        -:   34:#include <boost/container/detail/placement_new.hpp>
        -:   35:#ifndef BOOST_CONTAINER_DETAIL_STD_FWD_HPP
        -:   36:#include <boost/container/detail/std_fwd.hpp>
        -:   37:#endif
        -:   38:// intrusive
        -:   39:#include <boost/intrusive/pointer_traits.hpp>
        -:   40:#include <boost/intrusive/detail/mpl.hpp>
        -:   41:// move
        -:   42:#include <boost/move/utility_core.hpp>
        -:   43:// move/detail
        -:   44:#if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:   45:#include <boost/move/detail/fwd_macros.hpp>
        -:   46:#endif
        -:   47:
        -:   48:#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:   49:
        -:   50:#if defined(BOOST_GCC) && (BOOST_GCC >= 40600)
        -:   51:#pragma GCC diagnostic push
        -:   52:#pragma GCC diagnostic ignored "-Wunused-result"
        -:   53:#endif
        -:   54:
        -:   55:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME allocate
        -:   56:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   57:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   58:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 2
        -:   59:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 2
        -:   60:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   61:
        -:   62:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME destroy
        -:   63:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   64:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   65:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 1
        -:   66:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 1
        -:   67:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   68:
        -:   69:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME construct
        -:   70:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_BEG namespace boost { namespace container { namespace dtl {
        -:   71:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_NS_END   }}}
        -:   72:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MIN 1
        -:   73:#define BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_MAX 9
        -:   74:#include <boost/intrusive/detail/has_member_function_callable_with.hpp>
        -:   75:
        -:   76:#if defined(BOOST_GCC) && (BOOST_GCC >= 40600)
        -:   77:#pragma GCC diagnostic pop
        -:   78:#endif
        -:   79:
        -:   80:#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:   81:
        -:   82:namespace boost {
        -:   83:namespace container {
        -:   84:
        -:   85:#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:   86:
        -:   87:template<class T, class VoidAllocator, class Options>
        -:   88:class small_vector_allocator;
        -:   89:
        -:   90:namespace allocator_traits_detail {
        -:   91:
        -:   92:BOOST_INTRUSIVE_HAS_STATIC_MEMBER_FUNC_SIGNATURE(has_max_size, max_size)
        -:   93:BOOST_INTRUSIVE_HAS_STATIC_MEMBER_FUNC_SIGNATURE(has_select_on_container_copy_construction, select_on_container_copy_construction)
        -:   94:
        -:   95:}  //namespace allocator_traits_detail {
        -:   96:
        -:   97:namespace dtl {
        -:   98:
        -:   99://workaround needed for C++03 compilers with no construct()
        -:  100://supporting rvalue references
        -:  101:template<class Allocator>
        -:  102:struct is_std_allocator
        -:  103:{  static const bool value = false; };
        -:  104:
        -:  105:template<class T>
        -:  106:struct is_std_allocator< std::allocator<T> >
        -:  107:{  static const bool value = true; };
        -:  108:
        -:  109:template<class T, class Options>
        -:  110:struct is_std_allocator< small_vector_allocator<T, std::allocator<T>, Options > >
        -:  111:{  static const bool value = true; };
        -:  112:
        -:  113:template<class Allocator>
        -:  114:struct is_not_std_allocator
        -:  115:{  static const bool value = !is_std_allocator<Allocator>::value; };
        -:  116:
        -:  117:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(pointer)
        -:  118:BOOST_INTRUSIVE_INSTANTIATE_EVAL_DEFAULT_TYPE_TMPLT(const_pointer)
        -:  119:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(reference)
        -:  120:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(const_reference)
        -:  121:BOOST_INTRUSIVE_INSTANTIATE_EVAL_DEFAULT_TYPE_TMPLT(void_pointer)
        -:  122:BOOST_INTRUSIVE_INSTANTIATE_EVAL_DEFAULT_TYPE_TMPLT(const_void_pointer)
        -:  123:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(size_type)
        -:  124:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(propagate_on_container_copy_assignment)
        -:  125:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(propagate_on_container_move_assignment)
        -:  126:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(propagate_on_container_swap)
        -:  127:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(is_always_equal)
        -:  128:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(difference_type)
        -:  129:BOOST_INTRUSIVE_INSTANTIATE_DEFAULT_TYPE_TMPLT(is_partially_propagable)
        -:  130:
        -:  131:}  //namespace dtl {
        -:  132:
        -:  133:#endif   //#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED
        -:  134:
        -:  135://! The class template allocator_traits supplies a uniform interface to all allocator types.
        -:  136://! This class is a C++03-compatible implementation of std::allocator_traits
        -:  137:template <typename Allocator>
        -:  138:struct allocator_traits
        -:  139:{
        -:  140:   //allocator_type
        -:  141:   typedef Allocator allocator_type;
        -:  142:   //value_type
        -:  143:   typedef typename allocator_type::value_type value_type;
        -:  144:
        -:  145:   #if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  146:      //! Allocator::pointer if such a type exists; otherwise, value_type*
        -:  147:      //!
        -:  148:      typedef unspecified pointer;
        -:  149:      //! Allocator::const_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<const
        -:  150:      //!
        -:  151:      typedef see_documentation const_pointer;
        -:  152:      //! Non-standard extension
        -:  153:      //! Allocator::reference if such a type exists; otherwise, value_type&
        -:  154:      typedef see_documentation reference;
        -:  155:      //! Non-standard extension
        -:  156:      //! Allocator::const_reference if such a type exists ; otherwise, const value_type&
        -:  157:      typedef see_documentation const_reference;
        -:  158:      //! Allocator::void_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<void>.
        -:  159:      //!
        -:  160:      typedef see_documentation void_pointer;
        -:  161:      //! Allocator::const_void_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<const
        -:  162:      //!
        -:  163:      typedef see_documentation const_void_pointer;
        -:  164:      //! Allocator::difference_type if such a type exists ; otherwise, pointer_traits<pointer>::difference_type.
        -:  165:      //!
        -:  166:      typedef see_documentation difference_type;
        -:  167:      //! Allocator::size_type if such a type exists ; otherwise, make_unsigned<difference_type>::type
        -:  168:      //!
        -:  169:      typedef see_documentation size_type;
        -:  170:      //! Allocator::propagate_on_container_copy_assignment if such a type exists, otherwise a type
        -:  171:      //! with an internal constant static boolean member <code>value</code> == false.
        -:  172:      typedef see_documentation propagate_on_container_copy_assignment;
        -:  173:      //! Allocator::propagate_on_container_move_assignment if such a type exists, otherwise a type
        -:  174:      //! with an internal constant static boolean member <code>value</code> == false.
        -:  175:      typedef see_documentation propagate_on_container_move_assignment;
        -:  176:      //! Allocator::propagate_on_container_swap if such a type exists, otherwise a type
        -:  177:      //! with an internal constant static boolean member <code>value</code> == false.
        -:  178:      typedef see_documentation propagate_on_container_swap;
        -:  179:      //! Allocator::is_always_equal if such a type exists, otherwise a type
        -:  180:      //! with an internal constant static boolean member <code>value</code> == is_empty<Allocator>::value
        -:  181:      typedef see_documentation is_always_equal;
        -:  182:      //! Allocator::is_partially_propagable if such a type exists, otherwise a type
        -:  183:      //! with an internal constant static boolean member <code>value</code> == false
        -:  184:      //! <b>Note</b>: Non-standard extension used to implement `small_vector_allocator`.
        -:  185:      typedef see_documentation is_partially_propagable;
        -:  186:      //! Defines an allocator: Allocator::rebind<T>::other if such a type exists; otherwise, Allocator<T, Args>
        -:  187:      //! if Allocator is a class template instantiation of the form Allocator<U, Args>, where Args is zero or
        -:  188:      //! more type arguments ; otherwise, the instantiation of rebind_alloc is ill-formed.
        -:  189:      //!
        -:  190:      //! In C++03 compilers <code>rebind_alloc</code> is a struct derived from an allocator
        -:  191:      //! deduced by previously detailed rules.
        -:  192:      template <class T> using rebind_alloc = see_documentation;
        -:  193:
        -:  194:      //! In C++03 compilers <code>rebind_traits</code> is a struct derived from
        -:  195:      //! <code>allocator_traits<OtherAlloc></code>, where <code>OtherAlloc</code> is
        -:  196:      //! the allocator deduced by rules explained in <code>rebind_alloc</code>.
        -:  197:      template <class T> using rebind_traits = allocator_traits<rebind_alloc<T> >;
        -:  198:
        -:  199:      //! Non-standard extension: Portable allocator rebind for C++03 and C++11 compilers.
        -:  200:      //! <code>type</code> is an allocator related to Allocator deduced deduced by rules explained in <code>rebind_alloc</code>.
        -:  201:      template <class T>
        -:  202:      struct portable_rebind_alloc
        -:  203:      {  typedef see_documentation type;  };
        -:  204:   #else
        -:  205:      //pointer
        -:  206:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  207:         pointer, value_type*)
        -:  208:            pointer;
        -:  209:      //const_pointer
        -:  210:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_EVAL_DEFAULT(boost::container::dtl::, Allocator,
        -:  211:         const_pointer, typename boost::intrusive::pointer_traits<pointer>::template
        -:  212:            rebind_pointer<const value_type>)
        -:  213:               const_pointer;
        -:  214:      //reference
        -:  215:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  216:         reference, typename dtl::unvoid_ref<value_type>::type)
        -:  217:            reference;
        -:  218:      //const_reference
        -:  219:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  220:         const_reference, typename dtl::unvoid_ref<const value_type>::type)
        -:  221:               const_reference;
        -:  222:      //void_pointer
        -:  223:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_EVAL_DEFAULT(boost::container::dtl::, Allocator,
        -:  224:         void_pointer, typename boost::intrusive::pointer_traits<pointer>::template
        -:  225:            rebind_pointer<void>)
        -:  226:               void_pointer;
        -:  227:      //const_void_pointer
        -:  228:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_EVAL_DEFAULT(boost::container::dtl::, Allocator,
        -:  229:         const_void_pointer, typename boost::intrusive::pointer_traits<pointer>::template
        -:  230:            rebind_pointer<const void>)
        -:  231:               const_void_pointer;
        -:  232:      //difference_type
        -:  233:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  234:         difference_type, std::ptrdiff_t)
        -:  235:            difference_type;
        -:  236:      //size_type
        -:  237:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  238:         size_type, std::size_t)
        -:  239:            size_type;
        -:  240:      //propagate_on_container_copy_assignment
        -:  241:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  242:         propagate_on_container_copy_assignment, dtl::false_type)
        -:  243:            propagate_on_container_copy_assignment;
        -:  244:      //propagate_on_container_move_assignment
        -:  245:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  246:         propagate_on_container_move_assignment, dtl::false_type)
        -:  247:            propagate_on_container_move_assignment;
        -:  248:      //propagate_on_container_swap
        -:  249:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  250:         propagate_on_container_swap, dtl::false_type)
        -:  251:            propagate_on_container_swap;
        -:  252:      //is_always_equal
        -:  253:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  254:         is_always_equal, dtl::is_empty<Allocator>)
        -:  255:            is_always_equal;
        -:  256:      //is_partially_propagable
        -:  257:      typedef BOOST_INTRUSIVE_OBTAIN_TYPE_WITH_DEFAULT(boost::container::dtl::, Allocator,
        -:  258:         is_partially_propagable, dtl::false_type)
        -:  259:            is_partially_propagable;
        -:  260:
        -:  261:      //rebind_alloc & rebind_traits
        -:  262:      #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)
        -:  263:         //C++11
        -:  264:         template <typename T> using rebind_alloc  = typename boost::intrusive::pointer_rebind<Allocator, T>::type;
        -:  265:         template <typename T> using rebind_traits = allocator_traits< rebind_alloc<T> >;
        -:  266:      #else    // #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)
        -:  267:         //Some workaround for C++03 or C++11 compilers with no template aliases
        -:  268:         template <typename T>
        -:  269:         struct rebind_alloc : boost::intrusive::pointer_rebind<Allocator,T>::type
        -:  270:         {
        -:  271:            typedef typename boost::intrusive::pointer_rebind<Allocator,T>::type Base;
        -:  272:            #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  273:               template <typename... Args>
        -:  274:               rebind_alloc(BOOST_FWD_REF(Args)... args) : Base(boost::forward<Args>(args)...) {}
        -:  275:            #else    // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  276:               #define BOOST_CONTAINER_ALLOCATOR_TRAITS_REBIND_ALLOC(N) \
        -:  277:               BOOST_MOVE_TMPL_LT##N BOOST_MOVE_CLASS##N BOOST_MOVE_GT##N\
        -:  278:               explicit rebind_alloc(BOOST_MOVE_UREF##N) : Base(BOOST_MOVE_FWD##N){}\
        -:  279:               //
        -:  280:               BOOST_MOVE_ITERATE_0TO9(BOOST_CONTAINER_ALLOCATOR_TRAITS_REBIND_ALLOC)
        -:  281:               #undef BOOST_CONTAINER_ALLOCATOR_TRAITS_REBIND_ALLOC
        -:  282:            #endif   // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  283:         };
        -:  284:
        -:  285:         template <typename T>
        -:  286:         struct rebind_traits
        -:  287:            : allocator_traits<typename boost::intrusive::pointer_rebind<Allocator, T>::type>
        -:  288:         {};
        -:  289:      #endif   // #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)
        -:  290:
        -:  291:      //portable_rebind_alloc
        -:  292:      template <class T>
        -:  293:      struct portable_rebind_alloc
        -:  294:      {  typedef typename boost::intrusive::pointer_rebind<Allocator, T>::type type;  };
        -:  295:   #endif   //BOOST_CONTAINER_DOXYGEN_INVOKED
        -:  296:
        -:  297:   //! <b>Returns</b>: <code>a.allocate(n)</code>
        -:  298:   //!
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE8allocateERSH_m called 4 returned 100% blocks executed 100%
        4:  299:   inline static pointer allocate(Allocator &a, size_type n)
        4:  300:   {  return a.allocate(n);  }
        4:  300-block  0
        -:  301:
        -:  302:   //! <b>Returns</b>: <code>a.deallocate(p, n)</code>
        -:  303:   //!
        -:  304:   //! <b>Throws</b>: Nothing
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE10deallocateERSH_PSG_m called 4 returned 100% blocks executed 100%
        4:  305:   inline static void deallocate(Allocator &a, pointer p, size_type n)
        4:  306:   {  a.deallocate(p, n);  }
        4:  306-block  0
        -:  307:
        -:  308:   //! <b>Effects</b>: calls <code>a.allocate(n, p)</code> if that call is well-formed;
        -:  309:   //! otherwise, invokes <code>a.allocate(n)</code>
        -:  310:   inline static pointer allocate(Allocator &a, size_type n, const_void_pointer p)
        -:  311:   {
        -:  312:      const bool value = boost::container::dtl::
        -:  313:         has_member_function_callable_with_allocate
        -:  314:            <Allocator, const size_type, const const_void_pointer>::value;
        -:  315:      dtl::bool_<value> flag;
        -:  316:      return allocator_traits::priv_allocate(flag, a, n, p);
        -:  317:   }
        -:  318:
        -:  319:   //! <b>Effects</b>: calls <code>a.destroy(p)</code> if that call is well-formed;
        -:  320:   //! otherwise, invokes <code>p->~T()</code>.
        -:  321:   template<class T>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE7destroyISG_EEvRSH_PT_ called 8 returned 100% blocks executed 100%
        8:  322:   inline static void destroy(Allocator &a, T*p) BOOST_NOEXCEPT_OR_NOTHROW
        -:  323:   {
        -:  324:      typedef T* destroy_pointer;
        8:  325:      const bool value = boost::container::dtl::
        -:  326:         has_member_function_callable_with_destroy
        -:  327:            <Allocator, const destroy_pointer>::value;
        -:  328:      dtl::bool_<value> flag;
        8:  329:      allocator_traits::priv_destroy(flag, a, p);
        8:  330:   }
        8:  330-block  0
        -:  331:
        -:  332:   //! <b>Returns</b>: <code>a.max_size()</code> if that expression is well-formed; otherwise,
        -:  333:   //! <code>numeric_limits<size_type>::max()</code>.
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE8max_sizeERKSH_ called 8 returned 100% blocks executed 100%
        8:  334:   inline static size_type max_size(const Allocator &a) BOOST_NOEXCEPT_OR_NOTHROW
        -:  335:   {
        8:  336:      const bool value = allocator_traits_detail::has_max_size<Allocator, size_type (Allocator::*)() const>::value;
        -:  337:      dtl::bool_<value> flag;
        8:  338:      return allocator_traits::priv_max_size(flag, a);
        8:  338-block  0
        -:  339:   }
        -:  340:
        -:  341:   //! <b>Returns</b>: <code>a.select_on_container_copy_construction()</code> if that expression is well-formed;
        -:  342:   //! otherwise, a.
        -:  343:   inline static BOOST_CONTAINER_DOC1ST(Allocator,
        -:  344:      typename dtl::if_c
        -:  345:         < allocator_traits_detail::has_select_on_container_copy_construction<Allocator BOOST_MOVE_I Allocator (Allocator::*)() const>::value
        -:  346:         BOOST_MOVE_I Allocator BOOST_MOVE_I const Allocator & >::type)
        -:  347:   select_on_container_copy_construction(const Allocator &a)
        -:  348:   {
        -:  349:      const bool value = allocator_traits_detail::has_select_on_container_copy_construction
        -:  350:         <Allocator, Allocator (Allocator::*)() const>::value;
        -:  351:      dtl::bool_<value> flag;
        -:  352:      return allocator_traits::priv_select_on_container_copy_construction(flag, a);
        -:  353:   }
        -:  354:
        -:  355:   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  356:      //! <b>Effects</b>: calls <code>a.construct(p, std::forward<Args>(args)...)</code> if that call is well-formed;
        -:  357:      //! otherwise, invokes <code>`placement new` (static_cast<void*>(p)) T(std::forward<Args>(args)...)</code>
        -:  358:      template <class T, class ...Args>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE9constructISG_JSG_EEEvRSH_PT_DpOT0_ called 8 returned 100% blocks executed 100%
        8:  359:      inline static void construct(Allocator & a, T* p, BOOST_FWD_REF(Args)... args)
        -:  360:      {
        -:  361:         static const bool value = ::boost::move_detail::and_
        -:  362:            < dtl::is_not_std_allocator<Allocator>
        -:  363:            , boost::container::dtl::has_member_function_callable_with_construct
        -:  364:                  < Allocator, T*, Args... >
        -:  365:            >::value;
        -:  366:         dtl::bool_<value> flag;
        8:  367:         allocator_traits::priv_construct(flag, a, p, ::boost::forward<Args>(args)...);
        8:  368:      }
        8:  368-block  0
        -:  369:   #endif
        -:  370:
        -:  371:   //! <b>Returns</b>: <code>a.storage_is_unpropagable(p)</code> if is_partially_propagable::value is true; otherwise,
        -:  372:   //! <code>false</code>.
        -:  373:   inline static bool storage_is_unpropagable(const Allocator &a, pointer p) BOOST_NOEXCEPT_OR_NOTHROW
        -:  374:   {
        -:  375:      dtl::bool_<is_partially_propagable::value> flag;
        -:  376:      return allocator_traits::priv_storage_is_unpropagable(flag, a, p);
        -:  377:   }
        -:  378:
        -:  379:   //! <b>Returns</b>: <code>true</code> if <code>is_always_equal::value == true</code>, otherwise,
        -:  380:   //! <code>a == b</code>.
        -:  381:   inline static bool equal(const Allocator &a, const Allocator &b) BOOST_NOEXCEPT_OR_NOTHROW
        -:  382:   {
        -:  383:      dtl::bool_<is_always_equal::value> flag;
        -:  384:      return allocator_traits::priv_equal(flag, a, b);
        -:  385:   }
        -:  386:
        -:  387:   #if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  388:   private:
        -:  389:   inline static pointer priv_allocate(dtl::true_type, Allocator &a, size_type n, const_void_pointer p)
        -:  390:   {  return a.allocate(n, p);  }
        -:  391:
        -:  392:   inline static pointer priv_allocate(dtl::false_type, Allocator &a, size_type n, const_void_pointer)
        -:  393:   {  return a.allocate(n);  }
        -:  394:
        -:  395:   template<class T>
        -:  396:   inline static void priv_destroy(dtl::true_type, Allocator &a, T* p) BOOST_NOEXCEPT_OR_NOTHROW
        -:  397:   {  a.destroy(p);  }
        -:  398:
        -:  399:   template<class T>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE12priv_destroyISG_EEvNS_11move_detail17integral_constantIbLb0EEERSH_PT_ called 8 returned 100% blocks executed 100%
        8:  400:   inline static void priv_destroy(dtl::false_type, Allocator &, T* p) BOOST_NOEXCEPT_OR_NOTHROW
        8:  401:   {  p->~T(); (void)p;  }
        8:  401-block  0
        -:  402:
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE13priv_max_sizeENS_11move_detail17integral_constantIbLb1EEERKSH_ called 8 returned 100% blocks executed 100%
        8:  403:   inline static size_type priv_max_size(dtl::true_type, const Allocator &a) BOOST_NOEXCEPT_OR_NOTHROW
        8:  404:   {  return a.max_size();  }
        8:  404-block  0
        -:  405:
        -:  406:   inline static size_type priv_max_size(dtl::false_type, const Allocator &) BOOST_NOEXCEPT_OR_NOTHROW
        -:  407:   {  return size_type(-1)/sizeof(value_type);  }
        -:  408:
        -:  409:   inline static Allocator priv_select_on_container_copy_construction(dtl::true_type, const Allocator &a)
        -:  410:   {  return a.select_on_container_copy_construction();  }
        -:  411:
        -:  412:   inline static const Allocator &priv_select_on_container_copy_construction(dtl::false_type, const Allocator &a) BOOST_NOEXCEPT_OR_NOTHROW
        -:  413:   {  return a;  }
        -:  414:
        -:  415:   #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  416:      template<class T, class ...Args>
        -:  417:      inline static void priv_construct(dtl::true_type, Allocator &a, T *p, BOOST_FWD_REF(Args) ...args)
        -:  418:      {  a.construct( p, ::boost::forward<Args>(args)...);  }
        -:  419:
        -:  420:      template<class T, class ...Args>
function _ZN5boost9container16allocator_traitsINS0_13new_allocatorINS0_3dtl4pairINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10shared_ptrIN8drug_lib4data12DataPropertyEEEEEEE14priv_constructISG_JSG_EEEvNS_11move_detail17integral_constantIbLb0EEERSH_PT_DpOT0_ called 8 returned 100% blocks executed 50%
        8:  421:      inline static void priv_construct(dtl::false_type, Allocator &, T *p, BOOST_FWD_REF(Args) ...args)
        8:  422:      {  ::new((void*)p, boost_container_new_t()) T(::boost::forward<Args>(args)...); }
        8:  422-block  0
branch  0 taken 8
branch  1 taken 0
        8:  422-block  1
    $$$$$:  422-block  2
    $$$$$:  422-block  3
        -:  423:   #else // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  424:      public:
        -:  425:
        -:  426:      #define BOOST_CONTAINER_ALLOCATOR_TRAITS_CONSTRUCT_IMPL(N) \
        -:  427:      template<class T BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  428:      inline static void construct(Allocator &a, T *p BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -:  429:      {\
        -:  430:         static const bool value = ::boost::move_detail::and_ \
        -:  431:            < dtl::is_not_std_allocator<Allocator> \
        -:  432:            , boost::container::dtl::has_member_function_callable_with_construct \
        -:  433:                  < Allocator, T* BOOST_MOVE_I##N BOOST_MOVE_FWD_T##N > \
        -:  434:            >::value; \
        -:  435:         dtl::bool_<value> flag;\
        -:  436:         (priv_construct)(flag, a, p BOOST_MOVE_I##N BOOST_MOVE_FWD##N);\
        -:  437:      }\
        -:  438:      //
        -:  439:      BOOST_MOVE_ITERATE_0TO8(BOOST_CONTAINER_ALLOCATOR_TRAITS_CONSTRUCT_IMPL)
        -:  440:      #undef BOOST_CONTAINER_ALLOCATOR_TRAITS_CONSTRUCT_IMPL
        -:  441:
        -:  442:      private:
        -:  443:      /////////////////////////////////
        -:  444:      // priv_construct
        -:  445:      /////////////////////////////////
        -:  446:      #define BOOST_CONTAINER_ALLOCATOR_TRAITS_PRIV_CONSTRUCT_IMPL(N) \
        -:  447:      template<class T BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  448:      inline static void priv_construct(dtl::true_type, Allocator &a, T *p BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -:  449:      {  a.construct( p BOOST_MOVE_I##N BOOST_MOVE_FWD##N );  }\
        -:  450:      \
        -:  451:      template<class T BOOST_MOVE_I##N BOOST_MOVE_CLASS##N >\
        -:  452:      inline static void priv_construct(dtl::false_type, Allocator &, T *p BOOST_MOVE_I##N BOOST_MOVE_UREF##N)\
        -:  453:      {  ::new((void*)p, boost_container_new_t()) T(BOOST_MOVE_FWD##N); }\
        -:  454:      //
        -:  455:      BOOST_MOVE_ITERATE_0TO8(BOOST_CONTAINER_ALLOCATOR_TRAITS_PRIV_CONSTRUCT_IMPL)
        -:  456:      #undef BOOST_CONTAINER_ALLOCATOR_TRAITS_PRIV_CONSTRUCT_IMPL
        -:  457:
        -:  458:   #endif   // #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
        -:  459:
        -:  460:   template<class T>
        -:  461:   inline static void priv_construct(dtl::false_type, Allocator &, T *p, const ::boost::container::default_init_t&)
        -:  462:   {  ::new((void*)p, boost_container_new_t()) T; }
        -:  463:
        -:  464:   inline static bool priv_storage_is_unpropagable(dtl::true_type, const Allocator &a, pointer p)
        -:  465:   {  return a.storage_is_unpropagable(p);  }
        -:  466:
        -:  467:   inline static bool priv_storage_is_unpropagable(dtl::false_type, const Allocator &, pointer)
        -:  468:   {  return false;  }
        -:  469:
        -:  470:   inline static bool priv_equal(dtl::true_type,  const Allocator &, const Allocator &)
        -:  471:   {  return true;  }
        -:  472:
        -:  473:   inline static bool priv_equal(dtl::false_type, const Allocator &a, const Allocator &b)
        -:  474:   {  return a == b;  }
        -:  475:
        -:  476:   #endif   //#if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  477:};
        -:  478:
        -:  479:#if !defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  480:
        -:  481:template<class T, class AllocatorOrVoid>
        -:  482:struct real_allocator
        -:  483:{
        -:  484:   typedef AllocatorOrVoid type;
        -:  485:};
        -:  486:
        -:  487:template<class T>
        -:  488:struct real_allocator<T, void>
        -:  489:{
        -:  490:   typedef new_allocator<T> type;
        -:  491:};
        -:  492:
        -:  493:#endif   //#if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)
        -:  494:
        -:  495:}  //namespace container {
        -:  496:}  //namespace boost {
        -:  497:
        -:  498:#include <boost/container/detail/config_end.hpp>
        -:  499:
        -:  500:#endif // ! defined(BOOST_CONTAINER_ALLOCATOR_ALLOCATOR_TRAITS_HPP)
