        -:    0:Source:/home/neo/.vcpkg-clion/vcpkg/installed/x64-linux/include/pqxx/zview.hxx
        -:    0:Graph:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcno
        -:    0:Data:/home/neo/MedicamentLibrary/cmake-build-ninja--vcpkg-dbg-rel-coverage/common/db/postgres/pqxx_impl/CMakeFiles/DrugLib_Common_Database_PqxxClient.dir/source/pqxx_client.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Zero-terminated string view.
        -:    2: *
        -:    3: * DO NOT INCLUDE THIS FILE DIRECTLY; include pqxx/zview instead.
        -:    4: *
        -:    5: * Copyright (c) 2000-2024, Jeroen T. Vermeulen.
        -:    6: *
        -:    7: * See COPYING for copyright license.  If you did not receive a file called
        -:    8: * COPYING with this source code, please notify the distributor of this
        -:    9: * mistake, or contact the author.
        -:   10: */
        -:   11:#ifndef PQXX_H_ZVIEW
        -:   12:#define PQXX_H_ZVIEW
        -:   13:
        -:   14:#include <string>
        -:   15:#include <string_view>
        -:   16:#include <type_traits>
        -:   17:
        -:   18:#include "pqxx/types.hxx"
        -:   19:
        -:   20:
        -:   21:namespace pqxx
        -:   22:{
        -:   23:/// Marker-type wrapper: zero-terminated `std::string_view`.
        -:   24:/** @warning Use this only if the underlying string is zero-terminated.
        -:   25: *
        -:   26: * When you construct a zview, you are promising that if the data pointer is
        -:   27: * non-null, the underlying string is zero-terminated.  It otherwise behaves
        -:   28: * exactly like a std::string_view.
        -:   29: *
        -:   30: * The terminating zero is not "in" the string, so it does not count as part of
        -:   31: * the view's length.
        -:   32: *
        -:   33: * The added guarantee lets the view be used as a C-style string, which often
        -:   34: * matters since libpqxx builds on top of a C library.  For this reason, zview
        -:   35: * also adds a @ref c_str method.
        -:   36: */
        -:   37:class zview : public std::string_view
        -:   38:{
        -:   39:public:
        -:   40:  constexpr zview() noexcept = default;
        -:   41:
        -:   42:  /// Convenience overload: construct using pointer and signed length.
        -:   43:  constexpr zview(char const text[], std::ptrdiff_t len) noexcept(
        -:   44:    noexcept(std::string_view{text, static_cast<std::size_t>(len)})) :
        -:   45:          std::string_view{text, static_cast<std::size_t>(len)}
        -:   46:  {}
        -:   47:
        -:   48:  /// Convenience overload: construct using pointer and signed length.
        -:   49:  constexpr zview(char text[], std::ptrdiff_t len) noexcept(
        -:   50:    noexcept(std::string_view{text, static_cast<std::size_t>(len)})) :
        -:   51:          std::string_view{text, static_cast<std::size_t>(len)}
        -:   52:  {}
        -:   53:
        -:   54:  /// Explicitly promote a `string_view` to a `zview`.
        -:   55:  explicit constexpr zview(std::string_view other) noexcept :
        -:   56:          std::string_view{other}
        -:   57:  {}
        -:   58:
        -:   59:  /// Construct from any initialiser you might use for `std::string_view`.
        -:   60:  /** @warning Only do this if you are sure that the string is zero-terminated.
        -:   61:   */
        -:   62:  template<typename... Args>
        -:   63:  explicit constexpr zview(Args &&...args) :
        -:   64:          std::string_view(std::forward<Args>(args)...)
        -:   65:  {}
        -:   66:
        -:   67:  // C++20: constexpr.
        -:   68:  /// @warning There's an implicit conversion from `std::string`.
function _ZN4pqxx5zviewC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 100101 returned 100% blocks executed 100%
   100101:   69:  zview(std::string const &str) noexcept :
   100101:   70:          std::string_view{str.c_str(), str.size()}
   100101:   71:  {}
   100101:   71-block  0
        -:   72:
        -:   73:  /// Construct a `zview` from a C-style string.
        -:   74:  /** @warning This scans the string to discover its length.  So if you need to
        -:   75:   * do it many times, it's probably better to create the `zview` once and
        -:   76:   * re-use it.
        -:   77:   */
function _ZN4pqxx5zviewC2EPKc called 440 returned 100% blocks executed 100%
      440:   78:  constexpr zview(char const str[]) noexcept(noexcept(std::string_view{str})) :
      440:   79:          std::string_view{str}
      440:   80:  {}
      440:   80-block  0
        -:   81:
        -:   82:  /// Construct a `zview` from a string literal.
        -:   83:  /** A C++ string literal ("foo") normally looks a lot like a pointer to
        -:   84:   * char const, but that's not really true.  It's actually an array of char,
        -:   85:   * which _devolves_ to a pointer when you pass it.
        -:   86:   *
        -:   87:   * For the purpose of creating a `zview` there is one big difference: if we
        -:   88:   * know the array's size, we don't need to scan through the string in order
        -:   89:   * to find out its length.
        -:   90:   */
        -:   91:  template<size_t size>
        -:   92:  constexpr zview(char const (&literal)[size]) : zview(literal, size - 1)
        -:   93:  {}
        -:   94:
        -:   95:  /// Either a null pointer, or a zero-terminated text buffer.
function _ZNKR4pqxx5zview5c_strEv called 460 returned 100% blocks executed 100%
      460:   96:  [[nodiscard]] constexpr char const *c_str() const & noexcept
        -:   97:  {
      460:   98:    return data();
      460:   98-block  0
        -:   99:  }
        -:  100:};
        -:  101:
        -:  102:
        -:  103:/// Support @ref zview literals.
        -:  104:/** You can "import" this selectively into your namespace, without pulling in
        -:  105: * all of the @ref pqxx namespace:
        -:  106: *
        -:  107: * ```cxx
        -:  108: * using pqxx::operator"" _zv;
        -:  109: * ```
        -:  110: */
        -:  111:constexpr zview operator"" _zv(char const str[], std::size_t len) noexcept
        -:  112:{
        -:  113:  return zview{str, len};
        -:  114:}
        -:  115:} // namespace pqxx
        -:  116:
        -:  117:
        -:  118:#if defined(PQXX_HAVE_CONCEPTS)
        -:  119:/// A zview is a view.
        -:  120:template<> inline constexpr bool std::ranges::enable_view<pqxx::zview>{true};
        -:  121:
        -:  122:
        -:  123:/// A zview is a borrowed range.
        -:  124:template<>
        -:  125:inline constexpr bool std::ranges::enable_borrowed_range<pqxx::zview>{true};
        -:  126:
        -:  127:namespace pqxx::internal
        -:  128:{
        -:  129:/// Concept: T is a known zero-terminated string type.
        -:  130:/** There's no unified API for these string types.  It's just a check for some
        -:  131: * known types.  Any code that makes use of the concept will still have to
        -:  132: * support each of these individually.
        -:  133: */
        -:  134:template<typename T>
        -:  135:concept ZString = std::is_convertible_v<strip_t<T>, char const *> or
        -:  136:                  std::is_convertible_v<strip_t<T>, zview> or
        -:  137:                  std::is_convertible_v<T, std::string const &>;
        -:  138:} // namespace pqxx::internal
        -:  139:#endif // PQXX_HAVE_CONCEPTS
        -:  140:
        -:  141:
        -:  142:namespace pqxx::internal
        -:  143:{
        -:  144:/// Get a raw C string pointer.
        -:  145:inline constexpr char const *as_c_string(char const str[]) noexcept
        -:  146:{
        -:  147:  return str;
        -:  148:}
        -:  149:/// Get a raw C string pointer.
        -:  150:template<std::size_t N>
        -:  151:inline constexpr char const *as_c_string(char (&str)[N]) noexcept
        -:  152:{
        -:  153:  return str;
        -:  154:}
        -:  155:/// Get a raw C string pointer.
        -:  156:inline constexpr char const *as_c_string(pqxx::zview str) noexcept
        -:  157:{
        -:  158:  return str.c_str();
        -:  159:}
        -:  160:// C++20: Make this constexpr.
        -:  161:/// Get a raw C string pointer.
        -:  162:inline char const *as_c_string(std::string const &str) noexcept
        -:  163:{
        -:  164:  return str.c_str();
        -:  165:}
        -:  166:} // namespace pqxx::internal
        -:  167:#endif
